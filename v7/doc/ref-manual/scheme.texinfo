\input texinfo @c -*-texinfo-*-
@iftex
@finalout
@end iftex
@comment $Id: scheme.texinfo,v 1.40 1993/12/05 16:17:38 adams Exp $
@comment %**start of header (This is for running Texinfo on a region.)
@setfilename scheme
@settitle MIT Scheme Reference
@comment %**end of header (This is for running Texinfo on a region.)
@setchapternewpage odd
@syncodeindex vr cp
@syncodeindex fn cp

@clear sicpstuff

@comment Parts of this document are essentially plagiarized from "Common
@comment Lisp: The Language".  Those parts are marked by the following
@comment comment lines:
@comment
@comment **** begin CLTL ****
@comment **** end CLTL ****

@comment This TeX macro is used in the description of the entry formats.
@comment It is similar to the @deffn macro, but doesn't screw around
@comment with the left margin or make an entry in the index.
@tex

\gdef\defnameexample #1#2{%
\advance \hsize by -\leftskip %
\advance \hsize by -\rightskip %
\noindent        %
\setbox0=\hbox{\hskip \deflastargmargin{\rm #2}\hskip \deftypemargin}%
\dimen0=\hsize \advance \dimen0 by -\wd0 % compute size for first line
\dimen1=\hsize \advance \dimen1 by -\defargsindent %size for continuations
\parshape 2 0in \dimen0 \defargsindent \dimen1     %
% Now output arg 2 ("Function" or some such)
% ending at \deftypemargin from the right margin,
% but stuck inside a box of width 0 so it does not interfere with linebreaking
\rlap{\rightline{{\rm #2}\hskip \deftypemargin}}%
\tolerance=10000 \hbadness=10000    % Make all lines underfull and no complaints
\hskip \deftypemargin  % Indent function name slightly
{\df #1}\enskip        % Generate function name
}

\gdef\deffnheaderexample #1#2#3{%
\begingroup\defnameexample {#2}{#1}\defunargs{#3}\endgroup}

\gdef\defmethparsebodyexample #1#2#3#4 {\begingroup\inENV %
\medbreak %
% Define the end token that this defining construct specifies
% so that it will exit this group.
\def#1{\endgraf\endgroup\medbreak}%
\def#2##1 {\begingroup\obeylines\activeparens\spacesplit{#3{##1}}}%
\parindent=0in %
\begingroup\obeylines\activeparens\spacesplit{#3{#4}}}

\gdef\deffnexample{\defmethparsebodyexample\Edeffnexample\deffnexamplex\deffnheaderexample}

% Don't let TeX put extra vspace around math displays ($$ ... $$),
% because these always appear inside @tex ... @end tex commands
% that put space there to begin with.
\abovedisplayskip=0pt plus 3pt
\abovedisplayshortskip=0pt plus 3pt
\belowdisplayskip=0pt plus 3pt
\belowdisplayshortskip=0pt plus 3pt

@end tex

@ifinfo
This file documents the MIT Scheme system.

Copyright @copyright{} 1988-93 Massachusetts Institute of Technology

This material was developed by the Scheme project at the Massachusetts
Institute of Technology, Department of Electrical Engineering and Computer
Science.  Permission to copy this document, to redistribute it, and to use
it for any purpose is granted, subject to the following restrictions and
understandings.

@enumerate
@item
Any copy made of this document must include this copyright notice in
full.

@item
Users of this document agree to make their best efforts (a) to return to
the MIT Scheme project any improvements or extensions that they make, so
that these may be included in future releases; and (b) to inform MIT of
noteworthy uses of this document.

@item
All materials developed as a consequence of the use of this document shall
duly acknowledge such use, in accordance with the usual standards of
acknowledging credit in academic research.

@item
MIT has made no warrantee or representation that the contents of this
document will be error-free, and MIT is under no obligation to provide any
services, by way of maintenance, update, or otherwise.

@item
In conjunction with products arising from the use of this material, there
shall be no use of the name of the Massachusetts Institute of Technology
nor of any adaptation thereof in any advertising, promotional, or sales
literature without prior written consent from MIT in each case.
@end enumerate
@end ifinfo

@titlepage
@title{MIT Scheme Reference Manual}
@subtitle Edition 1.37 alpha
@subtitle for Scheme Release 7.2
@subtitle 12 November 1993
@author by Chris Hanson
@author the MIT Scheme Team
@author and a cast of thousands

@page

@vskip 0pt plus 1filll
Copyright @copyright{} 1988-93 Massachusetts Institute of Technology

This material was developed by the Scheme project at the Massachusetts
Institute of Technology, Department of Electrical Engineering and Computer
Science.  Permission to copy this document, to redistribute it, and to use
it for any purpose is granted, subject to the following restrictions and
understandings.

@enumerate
@item
Any copy made of this document must include this copyright notice in
full.

@item
Users of this document agree to make their best efforts (a) to return to
the MIT Scheme project any improvements or extensions that they
make, so that these may be included in future releases; and (b) to
inform MIT of noteworthy uses of this document.

@item
All materials developed as a consequence of the use of this document shall
duly acknowledge such use, in accordance with the usual standards of
acknowledging credit in academic research.

@item
MIT has made no warrantee or representation that the contents of
this document will be error-free, and MIT is under no obligation to
provide any services, by way of maintenance, update, or otherwise.

@item
In conjunction with products arising from the use of this material,
there shall be no use of the name of the Massachusetts Institute of
Technology nor of any adaptation thereof in any advertising,
promotional, or sales literature without prior written consent from
MIT in each case.
@end enumerate
@end titlepage

@node Top, Acknowledgements, (dir), (dir)

@ifinfo
Scheme is the UnCommon Lisp.  This Info file is the programmer reference
document for the MIT implementation of Scheme.  It describes the
facilities available for developing programs in MIT Scheme, and the
``public'' parts of the implementation.
@end ifinfo

@menu
* Acknowledgements::            
* Overview::                    
* Special Forms::               
* Equivalence Predicates::      
* Numbers::                     
* Characters::                  
* Strings::                     
* Lists::                       
* Vectors::                     
* Bit Strings::                 
* Miscellaneous Datatypes::     
* Associations::                
* Procedures::                  
* Environments::                
* Input/Output::                
* File-System Interface::       
* Error System::                
* Graphics::                    
* Win32 Package Reference::     
* Index::                       

 --- The Detailed Node Listing ---

Overview

* Notational Conventions::      
* Scheme Concepts::             
* Lexical Conventions::         
* Expressions::                 

Notational Conventions

* Errors::                      
* Examples::                    
* Entry Format::                

Scheme Concepts

* Variable Bindings::           
* Environment Concepts::        
* Initial and Current Environments::  
* Static Scoping::              
* True and False::              
* External Representations::    
* Disjointness of Types::       
* Storage Model::               

Lexical Conventions

* Whitespace::                  
* Delimiters::                  
* Identifiers::                 
* Uppercase and Lowercase::     
* Naming Conventions::          
* Comments::                    
* Additional Notations::        

Expressions

* Literal Expressions::         
* Variable References::         
* Special Form Syntax::         
* Procedure Call Syntax::       

Special Forms

* Lambda Expressions::          
* Lexical Binding::             
* Fluid Binding::               
* Definitions::                 
* Assignments::                 
* Quoting::                     
* Conditionals::                
* Sequencing::                  
* Iteration::                   
* Structure Definitions::       

Definitions

* Top-Level Definitions::       
* Internal Definitions::        

Numbers

* Numerical types::             
* Exactness::                   
* Implementation restrictions::  
* Syntax of numerical constants::  
* Numerical operations::        
* Numerical input and output::  
* Fixnum and Flonum Operations::  
* Random Numbers::              

Fixnum and Flonum Operations

* Fixnum Operations::           
* Flonum Operations::           

Characters

* External Representation of Characters::  
* Comparison of Characters::    
* Miscellaneous Character Operations::  
* Internal Representation of Characters::  
* ASCII Characters::            
* Character Sets::              

Strings

* Construction of Strings::     
* Selecting String Components::  
* Comparison of Strings::       
* Alphabetic Case in Strings::  
* Cutting and Pasting Strings::  
* Searching Strings::           
* Matching Strings::            
* Modification of Strings::     
* Variable-Length Strings::     
* Byte Vectors::                

Lists

* Pairs::                       
* Construction of Lists::       
* Selecting List Components::   
* Cutting and Pasting Lists::   
* Filtering Lists::             
* Searching Lists::             
* Mapping of Lists::            
* Reduction of Lists::          
* Miscellaneous List Operations::  

Vectors

* Construction of Vectors::     
* Selecting Vector Components::  
* Cutting Vectors::             
* Modifying Vectors::           

Bit Strings

* Construction of Bit Strings::  
* Selecting Bit String Components::  
* Cutting and Pasting Bit Strings::  
* Bitwise Operations on Bit Strings::  
* Modification of Bit Strings::  
* Integer Conversions of Bit Strings::  

Miscellaneous Datatypes

* Booleans::                    
* Symbols::                     
* Cells::                       
* Records::                     
* Promises::                    
* Streams::                     
* Weak Pairs::                  

Associations

* Association Lists::           
* 1D Tables::                   
* The Association Table::       
* Hash Tables::                 
* Object Hashing::              
* Red-Black Trees::             
* Weight-Balanced Trees::       

Hash Tables

* Construction of Hash Tables::  
* Basic Hash Table Operations::  
* Resizing of Hash Tables::     
* Address Hashing::             
* Low-Level Hash Table Operations::  

Weight-Balanced Trees

* Construction of Weight-Balanced Trees::  
* Basic Operations on Weight-Balanced Trees::  
* Advanced Operations on Weight-Balanced Trees::  
* Indexing Operations on Weight-Balanced Trees::  

Procedures

* Procedure Operations::        
* Primitive Procedures::        
* Continuations::               
* Application Hooks::           

Environments

* Environment Operations::      
* Environment Variables::       
* REPL Environment::            
* Interpreter Environments::    

Input/Output

* Ports::                       
* File Ports::                  
* String Ports::                
* Input Procedures::            
* Output Procedures::           
* Format::                      
* Custom Output::               
* Prompting::                   
* Port Primitives::             

Port Primitives

* Constructors and Accessors for Ports::  
* Blocking Mode::               
* Terminal Mode::               
* Input Port Operations::       
* Output Port Operations::      

File-System Interface

* Pathnames::                   
* Working Directory::           
* File Manipulation::           
* Directory Reader::            

Pathnames

* Filenames and Pathnames::     
* Components of Pathnames::     
* Operations on Pathnames::     
* Miscellaneous Pathnames::     

Error System

* Simple Errors::               
* Error Handler::               
* Error Messages::              
* Condition Types::             
* Condition Instances::         
* Condition Signalling::        
* Condition Handling::          
* Predefined Errors::           

Graphics

* Opening and Closing of Graphics Devices::  
* Coordinates for Graphics::    
* Drawing Graphics::            
* Characteristics of Graphics Output::  
* Buffering of Graphics Output::  
* Clipping of Graphics Output::  
* Custom Graphics Operations::  
* Images::                      
* Win32 Graphics::              Graphics on Microsoft Windows and Windows NT
* X Graphics::                  
* Starbase Graphics::           

Win32 Graphics

* Win32 Graphics Type::         
* Custom Operations for Win32 Graphics::  Custom Operations for Win32 Graphics Devices

X Graphics

* X Graphics Type::             
* Utilities for X Graphics::    
* Custom Operations on X Graphics Devices::  

Win32 Package Reference

* Win32 Package Overview::      
* Foreign function interface::  
* Device Independent Bitmap Utilities::  

Foreign Function Interface

* Windows Types::               
* Windows Foreign Procedures::  
* Win32 API names and procedures::  

Device Independent Bitmap Utilities

* DIB procedures::              
* Other parts of the DIB Utilities implementation::  
@end menu

@node Acknowledgements, Overview, Top, Top
@unnumbered Acknowledgements

While "a cast of thousands" may be an overstatement, it is certainly the
case that this document represents the work of many people.  First and
foremost, thanks go to the authors of the @cite{Revised^4 Report on the
Algorithmic Language Scheme}, from which much of this document is
derived.  Thanks also to BBN Advanced Computers Inc.@: for the use of
parts of their @cite{Butterfly Scheme Reference}, and to Margaret
O'Connell for translating it from BBN's text-formatting language to
ours.

Special thanks to Richard Stallman, Bob Chassell, and Brian Fox, all of
the Free Software Foundation, for creating and maintaining the Texinfo
formatting language in which this document is written.

This report describes research done at the Artificial Intelligence
Laboratory and the Laboratory for Computer Science, both of the
Massachusetts Institute of Technology.  Support for this research is
provided in part by the Advanced Research Projects Agency of the
Department of Defense under Office of Naval Research contract
N00014-92-J-4097 and by the National Science Foundation under grant
number MIP-9001651.

@node Overview, Special Forms, Acknowledgements, Top
@chapter Overview

@cindex runtime system
This manual is a detailed description of the MIT Scheme runtime system.
It is intended to be a reference document for programmers.  It does not
describe how to run Scheme or how to interact with it --- that is the
subject of the @cite{MIT Scheme User's Manual}.

This chapter summarizes the semantics of Scheme, briefly describes the
MIT Scheme programming environment, and explains the syntactic and
lexical conventions of the language.  Subsequent chapters describe
special forms, numerous data abstractions, and facilities for input and
output.

@cindex standard Scheme (defn)
@cindex Scheme standard
@cindex R4RS
Throughout this manual, we will make frequent references to
@dfn{standard Scheme}, which is the language defined by the document
@cite{Revised^4 Report on the Algorithmic Language Scheme}, by William
Clinger, Jonathan Rees, et al.@:, or by @sc{ieee} Std. 1178-1990,
@cite{IEEE Standard for the Scheme Programming Language} (in fact,
several parts of this document are copied from the @cite{Revised
Report}).  MIT Scheme is an extension of standard Scheme.

These are the significant semantic characteristics of the Scheme
language:

@table @asis
@item Variables are statically scoped
@cindex static scoping (defn)
@cindex scope (see region)
Scheme is a @dfn{statically scoped} programming language, which means that
each use of a variable is associated with a lexically apparent binding
of that variable.  Algol is another statically scoped language.

@item Types are latent
@cindex latent types (defn)
@cindex manifest types (defn)
@cindex weak types (defn)
@cindex strong types (defn)
@cindex dynamic types (defn)
@cindex static types (defn)
@cindex types, latent (defn)
@cindex types, manifest (defn)
Scheme has @dfn{latent} types as opposed to @dfn{manifest} types, which
means that Scheme associates types with values (or objects) rather than
with variables.  Other languages with latent types (also referred to as
@dfn{weakly} typed or @dfn{dynamically} typed languages) include APL,
Snobol, and other dialects of Lisp.  Languages with manifest types
(sometimes referred to as @dfn{strongly} typed or @dfn{statically} typed
languages) include Algol 60, Pascal, and C.

@item Objects have unlimited extent
@cindex extent, of objects
All objects created during a Scheme computation, including procedures
and continuations, have unlimited extent; no Scheme object is ever
destroyed.  The system doesn't run out of memory because the garbage
collector reclaims the storage occupied by an object when the object
cannot possibly be needed by a future computation.  Other languages in
which most objects have unlimited extent include APL and other Lisp
dialects.

@item Proper tail recursion
@cindex proper tail recursion (defn)
@cindex tail recursion (defn)
@cindex recursion (see tail recursion)
Scheme is @dfn{properly tail-recursive}, which means that iterative
computation can occur in constant space, even if the iterative
computation is described by a syntactically recursive procedure.  With a
tail-recursive implementation, you can express iteration using the
ordinary procedure-call mechanics; special iteration expressions are
provided only for syntactic convenience.

@item Procedures are objects
Scheme procedures are objects, which means that you can create them
dynamically, store them in data structures, return them as the results
of other procedures, and so on.  Other languages with such procedure
objects include Common Lisp and ML.

@item Continuations are explicit
In most other languages, continuations operate behind the scenes.  In
Scheme, continuations are objects; you can use continuations for
implementing a variety of advanced control constructs, including
non-local exits, backtracking, and coroutines.

@item Arguments are passed by value
Arguments to Scheme procedures are passed by value, which means that
Scheme evaluates the argument expressions before the procedure gains
control, whether or not the procedure needs the result of the
evaluations.  ML, C, and APL are three other languages that pass
arguments by value.  In languages such as SASL and Algol 60, argument
expressions are not evaluated unless the values are needed by the
procedure.
@end table

@findex read
Scheme uses a parenthesized-list Polish notation to describe programs
and (other) data.  The syntax of Scheme, like that of most Lisp
dialects, provides for great expressive power, largely due to its
simplicity.  An important consequence of this simplicity is the
susceptibility of Scheme programs and data to uniform treatment by other
Scheme programs.  As with other Lisp dialects, the @code{read} primitive
parses its input; that is, it performs syntactic as well as lexical
decomposition of what it reads.

@menu
* Notational Conventions::      
* Scheme Concepts::             
* Lexical Conventions::         
* Expressions::                 
@end menu

@node Notational Conventions, Scheme Concepts,  , Overview
@section Notational Conventions
@cindex notational conventions
@cindex conventions, notational

This section details the notational conventions used throughout the rest
of this document.

@menu
* Errors::                      
* Examples::                    
* Entry Format::                
@end menu

@node Errors, Examples,  , Notational Conventions
@subsection Errors
@cindex errors, notational conventions

@cindex signal an error (defn)
@cindex must be, notational convention
@findex error
When this manual uses the phrase ``an error will be signalled,'' it
means that Scheme will call @code{error}, which normally halts execution
of the program and prints an error message.

When this manual uses the phrase ``it is an error,'' it means that the
specified action is not valid in Scheme, but the system may or may not
signal the error.  When this manual says that something ``must be,'' it
means that violating the requirement is an error.

@node Examples, Entry Format, Errors, Notational Conventions
@subsection Examples
@cindex examples

@cindex => notational convention
@cindex result of evaluation, in examples
@cindex evaluation, in examples
@cindex specified result, in examples
This manual gives many examples showing the evaluation of expressions.
The examples have a common format that shows the expression being
evaluated on the left hand side, an ``arrow'' in the middle, and the
value of the expression written on the right.  For example:

@example
(+ 1 2)          @result{}  3
@end example

Sometimes the arrow and value will be moved under the expression, due to
lack of space.  Occasionally we will not care what the value is, in
which case both the arrow and the value are omitted.

@cindex error--> notational convention
@cindex error, in examples
If an example shows an evaluation that results in an error, an error
message is shown, prefaced by @samp{@error{}}:

@example
(+ 1 'foo)                      @error{} Illegal datum
@end example

@cindex -| notational convention
@cindex printed output, in examples
An example that shows printed output marks it with @samp{@print{}}:

@example
(begin (write 'foo) 'bar)
     @print{} foo
     @result{} bar
@end example

@cindex unspecified result (defn)
@cindex result, unspecified (defn)
When this manual indicates that the value returned by some expression is
@dfn{unspecified}, it means that the expression will evaluate to some
object without signalling an error, but that programs should not depend
on the value in any way.

@node Entry Format,  , Examples, Notational Conventions
@subsection Entry Format
@cindex entry format
@cindex format, entry

Each description of an MIT Scheme variable, special form, or
procedure begins with one or more header lines in this format:

@iftex
@deffnexample @var{category} @var{template}
@end deffnexample
@end iftex
@ifinfo
@display
* @var{category}: @var{template}
@end display
@end ifinfo

@noindent
where @var{category} specifies the kind of item (``variable'', ``special
form'', or ``procedure''), and how the item conforms to standard Scheme, as
follows:

@table @asis
@item @var{category}
@var{Category}, with no extra marking, indicates that the item is described
in the @cite{Revised^4 Report on the Algorithmic Language Scheme}.

@item @var{category}+
A plus sign after @var{category} indicates that the item is an MIT
Scheme extension.
@cindex + in entries
@cindex plus sign, in entries
@end table

@noindent
The form of @var{template} is interpreted depending on @var{category}.

@table @asis
@item Variable
@var{Template} consists of the variable's name.
@cindex variable, entry category

@item Special Form
@var{Template} starts with the syntactic keyword of the special form,
followed by a description of the special form's syntax.  The description
is written using the following conventions.
@cindex special form, entry category

@findex else
@findex cond
Named components are italicized in the printed manual, and uppercase in
the Info file.  ``Noise'' keywords, such as the @code{else} keyword in
the @code{cond} special form, are set in a fixed width font in the
printed manual; in the Info file they are not distinguished.
Parentheses indicate themselves.

@cindex ellipsis, in entries
@cindex ... in entries
A horizontal ellipsis (@dots{}) is describes repeated components.
Specifically,

@display
@var{thing} @dots{}
@end display

@noindent
indicates @emph{zero} or more occurrences of @var{thing}, while

@display
@var{thing} @var{thing} @dots{}
@end display

@noindent
indicates @emph{one} or more occurrences of @var{thing}.

@cindex bracket, in entries
@cindex [ in entries
@cindex ] in entries
@cindex optional component, in entries
Brackets, @code{[ ]}, enclose optional components.

@cindex body, of special form (defn)
@findex lambda
Several special forms (e.g.@: @code{lambda}) have an internal component
consisting of a series of expressions; usually these expressions are
evaluated sequentially under conditions that are specified in the
description of the special form.  This sequence of expressions is commonly
referred to as the @dfn{body} of the special form.

@item Procedure
@var{Template} starts with the name of the variable to which the
procedure is bound, followed by a description of the procedure's
arguments.  The arguments are described using ``lambda list'' notation
(@pxref{Lambda Expressions}), except that brackets are used to denote
optional arguments, and ellipses are used to denote ``rest'' arguments.
@cindex procedure, entry format

The names of the procedure's arguments are italicized in the printed
manual, and uppercase in the Info file.

When an argument names a Scheme data type, it indicates that the
argument must be that type of data object.  For example,

@iftex
@deffnexample procedure cdr pair
@end deffnexample
@end iftex
@ifinfo
@display
* procedure: cdr PAIR
@end display
@end ifinfo

@noindent
indicates that the standard Scheme procedure @code{cdr} takes one argument,
which must be a pair.

Many procedures signal an error when an argument is of the wrong type;
usually this error is a condition of type
@code{condition-type:wrong-type-argument}.
@findex condition-type:wrong-type-argument

In addition to the standard data-type names (@var{pair}, @var{list},
@var{boolean}, @var{string}, etc.), the following names as arguments
also imply type restrictions:

@itemize @bullet
@item
@var{object}: any object
@item
@var{thunk}: a procedure of no arguments
@item
@var{x}, @var{y}: real numbers
@item
@var{q}, @var{n}: integers
@item
@var{k}: an exact non-negative integer
@end itemize
@end table

Some examples:

@iftex
@deffnexample procedure list object @dots{}
@end deffnexample
@end iftex
@ifinfo
@display
* procedure: list OBJECT @dots{}
@end display
@end ifinfo

@noindent
indicates that the standard Scheme procedure @code{list} takes zero or
more arguments, each of which may be any Scheme object.

@iftex
@deffnexample procedure write-char char [output-port]
@end deffnexample
@end iftex
@ifinfo
@display
* procedure: write-char CHAR [OUTPUT-PORT]
@end display
@end ifinfo

@noindent
indicates that the standard Scheme procedure @code{write-char} must be
called with a character, @var{char}, and may also be called with a
character and an output port.

@node Scheme Concepts, Lexical Conventions, Notational Conventions, Overview
@section Scheme Concepts
@cindex scheme concepts

@menu
* Variable Bindings::           
* Environment Concepts::        
* Initial and Current Environments::  
* Static Scoping::              
* True and False::              
* External Representations::    
* Disjointness of Types::       
* Storage Model::               
@end menu

@node Variable Bindings, Environment Concepts,  , Scheme Concepts
@subsection Variable Bindings
@cindex variable binding
@cindex binding, of variable

@cindex bound variable (defn)
@cindex value, of variable (defn)
@cindex name, of value (defn)
@cindex location, of variable
Any identifier that is not a syntactic keyword may be used as a variable
(@pxref{Identifiers}).  A variable may name a location where a value can
be stored.  A variable that does so is said to be @dfn{bound} to the
location.  The value stored in the location to which a variable is bound
is called the variable's @dfn{value}.  (The variable is sometimes said
to @dfn{name} the value or to be @dfn{bound to} the value.)

@cindex unassigned variable (defn)
@cindex error, unassigned variable
A variable may be bound but still not have a value; such a variable is
said to be @dfn{unassigned}.  Referencing an unassigned variable is an
error.  When this error is signalled, it is a condition of type
@code{condition-type:unassigned-variable}; sometimes the compiler does
not generate code to signal the error.  Unassigned variables are useful
only in combination with side effects (@pxref{Assignments}).
@findex condition-type:unassigned-variable

@node Environment Concepts, Initial and Current Environments, Variable Bindings, Scheme Concepts
@subsection Environment Concepts

@cindex environment (defn)
@cindex unbound variable (defn)
@cindex error, unbound variable (defn)
An @dfn{environment} is a set of variable bindings.  If an environment
has no binding for a variable, that variable is said to be @dfn{unbound}
in that environment.  Referencing an unbound variable signals a
condition of type @code{condition-type:unbound-variable}.
@findex condition-type:unbound-variable

@cindex extension, of environment (defn)
@cindex environment, extension (defn)
@cindex shadowing, of variable binding (defn)
@cindex parent, of environment (defn)
@cindex child, of environment (defn)
@cindex inheritance, of environment bindings (defn)
A new environment can be created by @dfn{extending} an existing
environment with a set of new bindings.  Note that ``extending an
environment'' does @strong{not} modify the environment; rather, it
creates a new environment that contains the new bindings and the old
ones.  The new bindings @dfn{shadow} the old ones; that is, if an
environment that contains a binding for @code{x} is extended with a new
binding for @code{x}, then only the new binding is seen when @code{x} is
looked up in the extended environment.  Sometimes we say that the
original environment is the @dfn{parent} of the new one, or that the new
environment is a @dfn{child} of the old one, or that the new environment
@dfn{inherits} the bindings in the old one.

@findex let
@findex let*
@findex letrec
@findex do
@findex define
Procedure calls extend an environment, as do @code{let}, @code{let*},
@code{letrec}, and @code{do} expressions.  Internal definitions
(@pxref{Internal Definitions}) also extend an environment.  (Actually,
all the constructs that extend environments can be expressed in terms of
procedure calls, so there is really just one fundamental mechanism for
environment extension.)
A top-level definition (@pxref{Top-Level Definitions}) may add a binding to an existing environment.

@node Initial and Current Environments, Static Scoping, Environment Concepts, Scheme Concepts
@subsection Initial and Current Environments

@cindex initial environment (defn)
@cindex environment, initial (defn)
MIT Scheme provides an @dfn{initial environment} that contains all
of the variable bindings described in this manual.  Most environments
are ultimately extensions of this initial environment.  In Scheme, the
environment in which your programs execute is actually a child
(extension) of the environment containing the system's bindings.  Thus,
system names are visible to your programs, but your names do not
interfere with system programs.

@cindex current environment (defn)
@cindex environment, current (defn)
@cindex REP loop (defn)
@cindex REP loop, environment of
@findex user-initial-environment
@findex ge
The environment in effect at some point in a program is called the
@dfn{current environment} at that point.  In particular, every @sc{rep}
loop has a current environment.  (@sc{rep} stands for
``read-eval-print''; the @sc{rep} loop is the Scheme program that reads
your input, evaluates it, and prints the result.)  The environment of
the top-level @sc{rep} loop (the one you are in when Scheme starts up)
starts as @code{user-initial-environment}, although it can be changed by
the @code{ge} procedure.  When a new @sc{rep} loop is created, its
environment is determined by the program that creates it.

@node Static Scoping, True and False, Initial and Current Environments, Scheme Concepts
@subsection Static Scoping
@cindex scoping, static
@cindex static scoping

@cindex dynamic binding, versus static scoping
Scheme is a statically scoped language with block structure.  In this
respect, it is like Algol and Pascal, and unlike most other dialects of
Lisp except for Common Lisp.

@cindex binding expression (defn)
@cindex expression, binding (defn)
The fact that Scheme is statically scoped (rather than
dynamically bound) means that the environment that is extended (and
becomes current) when a procedure is called is the environment in which
the procedure was created (i.e.@: in which the procedure's defining
lambda expression was evaluated), not the environment in which the
procedure is called.  Because all the other Scheme @dfn{binding
expressions} can be expressed in terms of procedures, this determines
how all bindings behave.

Consider the following definitions, made at the top-level @sc{rep} loop
(in the initial environment):

@example
@group
(define x 1)
(define (f x) (g 2))
(define (g y) (+ x y))
(f 5)                                       @result{}  3 @r{; not} 7
@end group
@end example

Here @code{f} and @code{g} are bound to procedures created in the
initial environment.  Because Scheme is statically scoped, the call to
@code{g} from @code{f} extends the initial environment (the one in which
@code{g} was created) with a binding of @code{y} to @code{2}.  In this
extended environment, @code{y} is @code{2} and @code{x} is @code{1}.
(In a dynamically bound Lisp, the call to @code{g} would extend the
environment in effect during the call to @code{f}, in which @code{x} is
bound to @code{5} by the call to @code{f}, and the answer would be
@code{7}.)

@cindex lexical scoping (defn)
@cindex scoping, lexical (defn)
@cindex region, of variable binding (defn)
@cindex variable, binding region (defn)
@findex lambda
Note that with static scoping, you can tell what binding a variable
reference refers to just from looking at the text of the program; the
referenced binding cannot depend on how the program is used.  That is,
the nesting of environments (their parent-child relationship)
corresponds to the nesting of binding expressions in program text.
(Because of this connection to the text of the program, static scoping
is also called @dfn{lexical} scoping.)  For each place where a variable
is bound in a program there is a corresponding @dfn{region} of the
program text within which the binding is effective.  For example, the
region of a binding established by a @code{lambda} expression is the
entire body of the @code{lambda} expression.  The documentation of each
binding expression explains what the region of the bindings it makes is.
A use of a variable (that is, a reference to or assignment of a
variable) refers to the innermost binding of that variable whose region
contains the variable use.  If there is no such region, the use refers
to the binding of the variable in the global environment (which is an
ancestor of all other environments, and can be thought of as a region in
which all your programs are contained).

@node True and False, External Representations, Static Scoping, Scheme Concepts
@subsection True and False

@cindex boolean object
@cindex true, boolean object
@cindex false, boolean object
@findex #t
@findex #f
In Scheme, the boolean values true and false are denoted by @code{#t}
and @code{#f}.  However, any Scheme value can be treated as a boolean
for the purpose of a conditional test.  This manual uses the word
@dfn{true} to refer to any Scheme value that counts as true, and the
word @dfn{false} to refer to any Scheme value that counts as false.  In
conditional tests, all values count as true except for @code{#f}, which
counts as false (@pxref{Conditionals}).

Implementation note: In MIT Scheme, @code{#f} and the empty list
are the same object, and the printed representation of @code{#f} is
always @samp{()}.  As this contradicts the Scheme standard, MIT
Scheme will soon be changed to make @code{#f} and the empty list
different objects.

@node External Representations, Disjointness of Types, True and False, Scheme Concepts
@subsection External Representations

@cindex external representation (defn)
@cindex representation, external (defn)
An important concept in Scheme is that of the
@dfn{external representation} of an object as a sequence of characters.
For example, an external representation of the integer 28 is the
sequence of characters @samp{28}, and an external representation of a
list consisting of the integers 8 and 13 is the sequence of characters
@samp{(8 13)}.

The external representation of an object is not necessarily unique.  The
integer 28 also has representations @samp{#e28.000} and @samp{#x1c}, and
the list in the previous paragraph also has the representations @samp{(
08 13 )} and @samp{(8 . (13 . ( )))}.

Many objects have standard external representations, but some, such as
procedures and circular data structures, do not have standard
representations (although particular implementations may define
representations for them).

An external representation may be written in a program to obtain the
corresponding object (@pxref{Quoting}).

@findex read
@findex write
External representations can also be used for input and output.  The
procedure @code{read} parses external representations, and the procedure
@code{write} generates them.  Together, they provide an elegant and
powerful input/output facility.

Note that the sequence of characters @samp{(+ 2 6)} is @emph{not} an
external representation of the integer 8, even though it @emph{is} an
expression that evaluates to the integer 8; rather, it is an external
representation of a three-element list, the elements of which are the
symbol @code{+} and the integers @code{2} and @code{6}.  Scheme's syntax
has the property that any sequence of characters that is an expression
is also the external representation of some object.  This can lead to
confusion, since it may not be obvious out of context whether a given
sequence of characters is intended to denote data or program, but it is
also a source of power, since it facilitates writing programs such as
interpreters and compilers that treat programs as data or data as
programs.

@node Disjointness of Types, Storage Model, External Representations, Scheme Concepts
@subsection Disjointness of Types

Every object satisfies at most one of the following predicates (but
@pxref{True and False}, for an exception):

@example
@group
bit-string?     environment?    pathname?       string?
boolean?        null?           port?           symbol?
cell?           number?         procedure?      vector?
char?           pair?           promise?        weak-pair?
condition?
@end group
@end example

@node Storage Model,  , Disjointness of Types, Scheme Concepts
@subsection Storage Model

This section describes a model that can be used to understand Scheme's
use of storage.

@cindex location
@findex string-set!
Variables and objects such as pairs, vectors, and strings implicitly
denote locations or sequences of locations.  A string, for example,
denotes as many locations as there are characters in the string.  (These
locations need not correspond to a full machine word.)  A new value may
be stored into one of these locations using the @code{string-set!}
procedure, but the string continues to denote the same locations as
before.
  
@findex car
@findex vector-ref
@findex string-ref
@findex eqv?
An object fetched from a location, by a variable reference or by a
procedure such as @code{car}, @code{vector-ref}, or @code{string-ref},
is equivalent in the sense of @code{eqv?} to the object last stored in
the location before the fetch.

Every location is marked to show whether it is in use.  No variable or
object ever refers to a location that is not in use.  Whenever this
document speaks of storage being allocated for a variable or object,
what is meant is that an appropriate number of locations are chosen from
the set of locations that are not in use, and the chosen locations are
marked to indicate that they are now in use before the variable or
object is made to denote them.

@cindex constant
@cindex mutable
@cindex immutable
@findex symbol->string
In many systems it is desirable for constants (i.e.@: the values of
literal expressions) to reside in read-only memory.  To express this, it
is convenient to imagine that every object that denotes locations is
associated with a flag telling whether that object is mutable or
immutable.  The constants and the strings returned by
@code{symbol->string} are then the immutable objects, while all objects
created by other procedures are mutable.  It is an error to attempt to
store a new value into a location that is denoted by an immutable
object.  Note that the MIT Scheme compiler takes advantage of this
property to share constants, but that these constants are not immutable.
Instead, two constants that are @code{equal?} may be @code{eq?} in
compiled code.

@node Lexical Conventions, Expressions, Scheme Concepts, Overview
@section Lexical Conventions
@cindex lexical conventions
@cindex conventions, lexical

This section describes Scheme's lexical conventions.

@menu
* Whitespace::                  
* Delimiters::                  
* Identifiers::                 
* Uppercase and Lowercase::     
* Naming Conventions::          
* Comments::                    
* Additional Notations::        
@end menu

@node Whitespace, Delimiters,  , Lexical Conventions
@subsection Whitespace

@cindex whitespace, in programs (defn)
@cindex token, in programs (defn)
@dfn{Whitespace} characters are spaces, newlines, tabs, and page breaks.
Whitespace is used to improve the readability of your programs and to
separate tokens from each other, when necessary.  (A @dfn{token} is an
indivisible lexical unit such as an identifier or number.)  Whitespace
is otherwise insignificant.  Whitespace may occur between any two
tokens, but not within a token.  Whitespace may also occur inside a
string, where it is significant.

@node Delimiters, Identifiers, Whitespace, Lexical Conventions
@subsection Delimiters

@cindex delimiter, in programs (defn)
All whitespace characters are @dfn{delimiters}.  In addition, the
following characters act as delimiters:

@example
(  )  ;  "  '  `  |
@end example

Finally, these next characters act as delimiters, despite the fact that
Scheme does not define any special meaning for them:

@example
[  ]  @{  @}
@end example

For example, if the value of the variable @code{name} is
@code{"max"}:

@example
(list"Hi"name(+ 1 2))                   @result{}  ("Hi" "max" 3)
@end example

@node Identifiers, Uppercase and Lowercase, Delimiters, Lexical Conventions
@subsection Identifiers

@cindex identifier (defn)
An @dfn{identifier} is a sequence of one or more non-delimiter
characters.  Identifiers are used in several ways in Scheme
programs:

@itemize @bullet
@item
Certain identifiers are reserved for use as syntactic keywords; they
should not be used as variables (for a list of the initial syntactic
keywords, @pxref{Special Form Syntax}).
@cindex syntactic keyword, identifier as

@item
Any identifier that is not a syntactic keyword can be used as a
variable.
@cindex variable, identifier as

@item
When an identifier appears as a literal or within a literal, it denotes
a symbol.
@cindex literal, identifier as
@end itemize

Scheme accepts most of the identifiers that other programming languages
allow.  MIT Scheme allows all of the identifiers that standard
Scheme does, plus many more.

MIT Scheme defines a potential identifier to be a sequence of
non-delimiter characters that does not begin with either of the
characters @samp{#} or @samp{,}.  Any such sequence of characters that
is not a syntactically valid number (@pxref{Numbers}) is considered to
be a valid identifier.  Note that, although it is legal for @samp{#} and
@samp{,} to appear in an identifier (other than in the first character
position), it is poor programming practice.

Here are some examples of identifiers:

@example
lambda             q
list->vector       soup
+                  V17a
<=?                a34kTMNs
the-word-recursion-has-many-meanings
@end example

@node Uppercase and Lowercase, Naming Conventions, Identifiers, Lexical Conventions
@subsection Uppercase and Lowercase
@cindex uppercase
@cindex lowercase

@cindex alphabetic case-insensitivity of programs (defn)
@cindex case-insensitivity of programs (defn)
@cindex sensitivity, to case in programs (defn)
@cindex insensitivity, to case in programs (defn)
Scheme doesn't distinguish uppercase and lowercase forms of a letter
except within character and string constants; in other words, Scheme is
@dfn{case-insensitive}.  For example, @samp{Foo} is the same identifier
as @samp{FOO}, and @samp{#x1AB} is the same number as @samp{#X1ab}.  But
@samp{#\a} and @samp{#\A} are different characters.

@node Naming Conventions, Comments, Uppercase and Lowercase, Lexical Conventions
@subsection Naming Conventions
@cindex naming conventions
@cindex conventions, naming

@cindex predicate (defn)
@cindex ? in predicate names
A @dfn{predicate} is a procedure that always returns a boolean value
(@code{#t} or @code{#f}).  By convention, predicates usually have names
that end in @samp{?}.

@cindex mutation procedure (defn)
@cindex ! in mutation procedure names
A @dfn{mutation procedure} is a procedure that alters a data structure.
By convention, mutation procedures usually have names that end in
@samp{!}.

@node Comments, Additional Notations, Naming Conventions, Lexical Conventions
@subsection Comments

@cindex comment, in programs (defn)
@cindex semicolon, as external representation
@cindex ; as external representation
The beginning of a comment is indicated with a semicolon (@code{;}).
Scheme ignores everything on a line in which a semicolon appears, from
the semicolon until the end of the line.  The entire comment, including
the newline character that terminates it, is treated as
whitespace.

@cindex extended comment, in programs (defn)
@cindex comment, extended, in programs (defn)
@cindex #| as external representation
An alternative form of comment (sometimes called an @dfn{extended
comment}) begins with the characters @samp{#|} and ends with the
characters @samp{|#}.  This alternative form is an MIT Scheme extension.
As with ordinary comments, all of the characters in an extended comment,
including the leading @samp{#|} and trailing @samp{|#}, are treated as
whitespace.  Comments of this form may extend over multiple lines, and
additionally may be nested (unlike the comments of the programming
language C, which have a similar syntax).

@example
@group
;;; This is a comment about the FACT procedure.  Scheme
;;; ignores all of this comment.  The FACT procedure computes
;;; the factorial of a non-negative integer.
@end group

@group
#|
This is an extended comment.
Such comments are useful for commenting out code fragments.
|#
@end group

@group
(define fact
  (lambda (n)
    (if (= n 0)                      ;This is another comment:
        1                            ;Base case: return 1
        (* n (fact (- n 1))))))
@end group
@end example

@node Additional Notations,  , Comments, Lexical Conventions
@subsection Additional Notations

@cindex characters, special, in programs
@cindex special characters, in programs
The following list describes additional notations used in Scheme.
@xref{Numbers} for a description of the notations used for numbers.

@table @code
@item + - .
The plus sign, minus sign, and period are used in numbers, and may also
occur in an identifier.  A delimited period (not occurring within a
number or identifier) is used in the notation for pairs and to indicate
a ``rest'' parameter in a formal parameter list
(@pxref{Lambda Expressions}).

@item ( )
Parentheses are used for grouping and to notate lists (@pxref{Lists}).

@item "
The double quote delimits strings (@pxref{Strings}).

@item \
The backslash is used in the syntax for character constants
(@pxref{Characters}) and as an escape character within string constants
(@pxref{Strings}).

@item ;
The semicolon starts a comment.

@item '
The single quote indicates literal data; it suppresses evaluation
(@pxref{Quoting}).

@item `
The backquote indicates almost-constant data (@pxref{Quoting}).

@item ,
The comma is used in conjunction with the backquote (@pxref{Quoting}).

@item ,@@
A comma followed by an at-sign is used in conjunction with the backquote
(@pxref{Quoting}).

@item #
The sharp (or pound) sign has different uses, depending on the character
that immediately follows it:

@item #t #f
These character sequences denote the boolean constants
(@pxref{Booleans}).

@item #\
This character sequence introduces a character constant
(@pxref{Characters}).

@item #(
This character sequence introduces a vector constant (@pxref{Vectors}).
A close parenthesis, @samp{)}, terminates a vector constant.

@item #e #i #b #o #d #x
These character sequences are used in the notation for numbers
(@pxref{Numbers}).

@item #|
This character sequence introduces an extended comment.  The comment is
terminated by the sequence @samp{|#}.  This notation is an MIT Scheme
extension.

@item #!
This character sequence is used to denote a small set of named
constants.  Currently there are only two of these, @code{#!optional} and
@code{#!rest}, both of which are used in the @code{lambda} special form
to mark certain parameters as being ``optional'' or ``rest'' parameters.
This notation is an MIT Scheme extension.
@findex #!optional
@findex #!rest
@findex lambda

@item #*
This character sequence introduces a bit string (@pxref{Bit Strings}).
This notation is an MIT Scheme extension.
@end table

@node Expressions,  , Lexical Conventions, Overview
@section Expressions

@cindex expression (defn)
A Scheme @dfn{expression} is a construct that returns a value.  An
expression may be a @emph{literal}, a @emph{variable reference}, a
@emph{special form}, or a @emph{procedure call}.

@menu
* Literal Expressions::         
* Variable References::         
* Special Form Syntax::         
* Procedure Call Syntax::       
@end menu

@node Literal Expressions, Variable References,  , Expressions
@subsection Literal Expressions

@cindex literal expression (defn)
@cindex constant expression (defn)
@cindex expression, literal (defn)
@cindex expression, constant (defn)
@dfn{Literal} constants may be written by using an external
representation of the data.  In general, the external representation
must be @emph{quoted} (@pxref{Quoting}); but some external
representations can be used without quotation.

@example
"abc"                                   @result{}  "abc"
145932                                  @result{}  145932
#t                                      @result{}  #t
#\a                                     @result{}  #\a
@end example

The external representation of numeric constants, string constants,
character constants, and boolean constants evaluate to the constants
themselves.  Symbols, pairs, lists, and vectors require quoting.

@node Variable References, Special Form Syntax, Literal Expressions, Expressions
@subsection Variable References

@cindex variable reference (defn)
@cindex reference, variable (defn)
@cindex unbound variable
@cindex unassigned variable
An expression consisting of an identifier (@pxref{Identifiers}) is a
@dfn{variable reference}; the identifier is the name of the variable
being referenced.  The value of the variable reference is the value
stored in the location to which the variable is bound.  An error is
signalled if the referenced variable is unbound or unassigned.

@example
(define x 28)
x                                       @result{}  28
@end example

@node Special Form Syntax, Procedure Call Syntax, Variable References, Expressions
@subsection Special Form Syntax

@example
(@var{keyword} @var{component} @dots{})
@end example

@cindex expression, special form (defn)
@cindex special form (defn)
@cindex form, special (defn)
@cindex keyword, of special form (defn)
@cindex syntactic keyword (defn)
A parenthesized expression that starts with a @dfn{syntactic keyword} is
a @dfn{special form}.  Each special form has its own syntax, which is
described later in the manual.  The following list contains all of the
syntactic keywords that are defined when MIT Scheme is initialized:

@example
@group
access                  define-syntax           macro
and                     delay                   make-environment
begin                   do                      named-lambda
bkpt                    fluid-let               or
case                    if                      quasiquote
cond                    in-package              quote
cons-stream             lambda                  scode-quote
declare                 let                     sequence
default-object?         let*                    set!
define                  let-syntax              the-environment
define-integrable       letrec                  unassigned?
define-macro            local-declare           using-syntax
define-structure
@end group
@end example

@node Procedure Call Syntax,  , Special Form Syntax, Expressions
@subsection Procedure Call Syntax

@example
(@var{operator} @var{operand} @dots{})
@end example

@cindex expression, procedure call (defn)
@cindex procedure call (defn)
@cindex operator, of procedure call (defn)
@cindex operand, of procedure call (defn)
A @dfn{procedure call} is written by simply enclosing in parentheses
expressions for the procedure to be called (the @dfn{operator}) and the
arguments to be passed to it (the @dfn{operands}).  The @var{operator}
and @var{operand} expressions are evaluated and the resulting procedure
is passed the resulting arguments.  @xref{Lambda Expressions}, for a
more complete description of this.

@cindex combination (defn)
Another name for the procedure call expression is @dfn{combination}.
This word is more specific in that it always refers to the expression;
``procedure call'' sometimes refers to the @emph{process} of calling a
procedure.

@cindex order, of argument evaluation
@cindex evaluation order, of arguments
@cindex argument evaluation order
Unlike some other dialects of Lisp, Scheme always evaluates the operator
expression and the operand expressions with the same evaluation rules,
and the order of evaluation is unspecified.

@example
@group
(+ 3 4)                                 @result{}  7
((if #f = *) 3 4)                       @result{}  12
@end group
@end example

@findex +
@findex *
@findex lambda
A number of procedures are available as the values of variables in the
initial environment; for example, the addition and multiplication
procedures in the above examples are the values of the variables
@code{+} and @code{*}.  New procedures are created by evaluating
@code{lambda} expressions.

@cindex syntactic keyword
@findex apply
If the @var{operator} is a syntactic keyword, then the expression is not
treated as a procedure call: it is a special form.  Thus you should not
use syntactic keywords as procedure names.  If you were to bind one of
these keywords to a procedure, you would have to use @code{apply} to
call the procedure.  MIT Scheme signals an error when such a
binding is attempted.

@node Special Forms, Equivalence Predicates, Overview, Top
@chapter Special Forms

@cindex special form
A special form is an expression that follows special evaluation rules.
This chapter describes the basic Scheme special forms.

@menu
* Lambda Expressions::          
* Lexical Binding::             
* Fluid Binding::               
* Definitions::                 
* Assignments::                 
* Quoting::                     
* Conditionals::                
* Sequencing::                  
* Iteration::                   
* Structure Definitions::       
@end menu

@node Lambda Expressions, Lexical Binding,  , Special Forms
@section Lambda Expressions

@deffn {special form} lambda formals expression expression @dots{}
@cindex lambda expression (defn)
@cindex procedure, construction
@cindex procedure, closing environment (defn)
@cindex procedure, invocation environment (defn)
@cindex construction, of procedure
@cindex closing environment, of procedure (defn)
@cindex invocation environment, of procedure (defn)
@cindex environment, of procedure
@cindex environment, procedure closing (defn)
@cindex environment, procedure invocation (defn)
A @code{lambda} expression evaluates to a procedure.  The environment in
effect when the @code{lambda} expression is evaluated is remembered as
part of the procedure; it is called the @dfn{closing environment}.  When
the procedure is later called with some arguments, the closing
environment is extended by binding the variables in the formal parameter
list to fresh locations, and the locations are filled with the arguments
according to rules about to be given.  The new environment created by
this process is referred to as the @dfn{invocation environment}.

@cindex region of variable binding, lambda
@cindex variable binding, lambda
Once the invocation environment has been constructed, the
@var{expression}s in the body of the @code{lambda} expression are
evaluated sequentially in it.  This means that the region of the
variables bound by the @code{lambda} expression is all of the
@var{expression}s in the body.  The result of evaluating the last
@var{expression} in the body is returned as the result of the procedure
call.

@cindex lambda list (defn)
@cindex parameter list, of lambda (defn)
@cindex formal parameter list, of lambda (defn)
@var{Formals}, the formal parameter list, is often referred to as a
@dfn{lambda list}.

The process of matching up formal parameters with arguments is somewhat
involved.  There are three types of parameters, and the matching treats
each in sequence:

@need 1000
@table @asis
@item Required
All of the @dfn{required} parameters are matched against the arguments
first.  If there are fewer arguments than required parameters, an error
of type @code{condition-type:wrong-number-of-arguments} is signalled;
this error is also signalled if there are more arguments than required
parameters and there are no further parameters.
@cindex required parameter (defn)
@cindex parameter, required (defn)
@findex condition-type:wrong-number-of-arguments

@item Optional
Once the required parameters have all been matched, the @dfn{optional}
parameters are matched against the remaining arguments.  If there are
fewer arguments than optional parameters, the unmatched parameters are
bound to special objects called @dfn{default objects}.  If there are
more arguments than optional parameters, and there are no further
parameters, an error of type
@code{condition-type:wrong-number-of-arguments} is signalled.
@cindex optional parameter (defn)
@cindex parameter, optional (defn)
@cindex default object (defn)
@findex condition-type:wrong-number-of-arguments

@findex default-object?
The predicate @code{default-object?}, which is true only of default
objects, can be used to determine which optional parameters were
supplied, and which were defaulted.

@item Rest
Finally, if there is a @dfn{rest} parameter (there can only be one), any
remaining arguments are made into a list, and the list is bound to the
rest parameter.  (If there are no remaining arguments, the rest
parameter is bound to the empty list.)
@cindex rest parameter (defn)
@cindex parameter, rest (defn)

In Scheme, unlike some other Lisp implementations, the list to which a
rest parameter is bound is always freshly allocated.  It has infinite
extent and may be modified without affecting the procedure's caller.
@end table

@findex #!optional
@findex #!rest
Specially recognized keywords divide the @var{formals} parameters into
these three classes.  The keywords used here are @samp{#!optional},
@samp{.}, and @samp{#!rest}.  Note that only @samp{.} is defined by
standard Scheme --- the other keywords are MIT Scheme extensions.
@samp{#!rest} has the same meaning as @samp{.} in @var{formals}.

The use of these keywords is best explained by means of examples.  The
following are typical lambda lists, followed by descriptions of which
parameters are required, optional, and rest.  We will use @samp{#!rest}
in these examples, but anywhere it appears @samp{.} could be used
instead.

@table @code
@item (a b c)
@code{a}, @code{b}, and @code{c} are all required.  The procedure must
be passed exactly three arguments.

@item (a b #!optional c)
@code{a} and @code{b} are required, @code{c} is optional.  The procedure
may be passed either two or three arguments.

@item (#!optional a b c)
@code{a}, @code{b}, and @code{c} are all optional.  The procedure may be
passed any number of arguments between zero and three, inclusive.

@item a
@itemx (#!rest a)
These two examples are equivalent.  @code{a} is a rest parameter.  The
procedure may be passed any number of arguments.  Note: this is the only
case in which @samp{.} cannot be used in place of @samp{#!rest}.

@item (a b #!optional c d #!rest e)
@code{a} and @code{b} are required, @code{c} and @code{d} are optional,
and @code{e} is rest.  The procedure may be passed two or more
arguments.
@end table

Some examples of @code{lambda} expressions:

@example
(lambda (x) (+ x x))            @result{}  #[compound-procedure 53]

((lambda (x) (+ x x)) 4)                @result{}  8

(define reverse-subtract
  (lambda (x y)
    (- y x)))
(reverse-subtract 7 10)                 @result{}  3

(define foo
  (let ((x 4))
    (lambda (y) (+ x y))))
(foo 6)                                 @result{}  10
@end example
@end deffn

@deffn {special form+} named-lambda formals expression expression @dots{}
@cindex named lambda (defn)
The @code{named-lambda} special form is similar to @code{lambda}, except
that the first ``required parameter'' in @var{formals} is not a
parameter but the @dfn{name} of the resulting procedure; thus
@var{formals} must have at least one required parameter.  This name has
no semantic meaning, but is included in the external representation of
the procedure, making it useful for debugging.  In MIT Scheme,
@code{lambda} is implemented as @code{named-lambda}, with a special name
that means ``unnamed''.

@example
@group
(named-lambda (f x) (+ x x))    @result{}  #[compound-procedure 53 f]
((named-lambda (f x) (+ x x)) 4)        @result{}  8
@end group
@end example
@end deffn

@node Lexical Binding, Fluid Binding, Lambda Expressions, Special Forms
@section Lexical Binding

@cindex lexical binding expression
@cindex binding expression, lexical
@cindex block structure
The three binding constructs @code{let}, @code{let*}, and @code{letrec},
give Scheme block structure.  The syntax of the three constructs is
identical, but they differ in the regions they establish for their
variable bindings.  In a @code{let} expression, the initial values are
computed before any of the variables become bound.  In a @code{let*}
expression, the evaluations and bindings are sequentially interleaved.
And in a @code{letrec} expression, all the bindings are in effect while
the initial values are being computed (thus allowing mutually recursive
definitions).

@deffn {special form} let ((@var{variable} @var{init}) @dots{}) expression expression @dots{}
@cindex region of variable binding, let
@cindex variable binding, let
The @var{init}s are evaluated in the current environment (in some
unspecified order), the @var{variable}s are bound to fresh locations
holding the results, the @var{expression}s are evaluated sequentially in
the extended environment, and the value of the last @var{expression} is
returned.  Each binding of a @var{variable} has the @var{expression}s as
its region.

MIT Scheme allows any of the @var{init}s to be omitted, in which
case the corresponding @var{variable}s are unassigned.

@cindex lambda, implicit in let
Note that the following are equivalent:

@example
(let ((@var{variable} @var{init}) @dots{}) @var{expression} @var{expression} @dots{})
((lambda (@var{variable} @dots{}) @var{expression} @var{expression} @dots{}) @var{init} @dots{})
@end example

Some examples:

@example
@group
(let ((x 2) (y 3))
  (* x y))                              @result{}  6
@end group

@group
(let ((x 2) (y 3))
  (let ((foo (lambda (z) (+ x y z)))
        (x 7))
    (foo 4)))                           @result{}  9
@end group
@end example

@xref{Iteration}, for information on ``named @code{let}''.
@end deffn

@deffn {special form} let* ((@var{variable} @var{init}) @dots{}) expression expression @dots{}
@cindex region of variable binding, let*
@cindex variable binding, let*
@code{let*} is similar to @code{let}, but the bindings are performed
sequentially from left to right, and the region of a binding is that
part of the @code{let*} expression to the right of the binding.  Thus
the second binding is done in an environment in which the first binding
is visible, and so on.

Note that the following are equivalent:

@example
@group
(let* ((@var{variable1} @var{init1})
       (@var{variable2} @var{init2})
       @dots{}
       (@var{variableN} @var{initN}))
   @var{expression}
   @var{expression} @dots{})
@end group

@group
(let ((@var{variable1} @var{init1}))
  (let ((@var{variable2} @var{init2}))
    @dots{}
      (let ((@var{variableN} @var{initN}))
        @var{expression}
        @var{expression} @dots{})
    @dots{}))
@end group
@end example

An example:

@example
@group
(let ((x 2) (y 3))
  (let* ((x 7)
         (z (+ x y)))
    (* z x)))                           @result{}  70
@end group
@end example
@end deffn

@deffn {special form} letrec ((@var{variable} @var{init}) @dots{}) expression expression @dots{}
@cindex region of variable binding, letrec
@cindex variable binding, letrec
The @var{variable}s are bound to fresh locations holding unassigned
values, the @var{init}s are evaluated in the extended environment (in
some unspecified order), each @var{variable} is assigned to the result
of the corresponding @var{init}, the @var{expression}s are evaluated
sequentially in the extended environment, and the value of the last
@var{expression} is returned.  Each binding of a @var{variable} has the
entire @code{letrec} expression as its region, making it possible to
define mutually recursive procedures.

MIT Scheme allows any of the @var{init}s to be omitted, in which
case the corresponding @var{variable}s are unassigned.

@example
@group
(letrec ((even?
          (lambda (n)
            (if (zero? n)
                #t
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (zero? n)
                #f
                (even? (- n 1))))))
  (even? 88))                           @result{}  #t
@end group
@end example

@findex lambda
@findex delay
One restriction on @code{letrec} is very important: it shall be possible
to evaluated each @var{init} without assigning or referring to the value
of any @var{variable}.  If this restriction is violated, then it is an
error.  The restriction is necessary because Scheme passes arguments by
value rather than by name.  In the most common uses of @code{letrec},
all the @var{init}s are @code{lambda} or @code{delay} expressions and
the restriction is satisfied automatically.
@end deffn

@node Fluid Binding, Definitions, Lexical Binding, Special Forms
@section Fluid Binding

@deffn {special form+} fluid-let ((@var{variable} @var{init}) @dots{}) expression expression @dots{}
@cindex binding expression, fluid (or dynamic)
@cindex fluid binding
@cindex dynamic binding
@cindex variable binding, fluid-let
The @var{init}s are evaluated in the current environment (in some
unspecified order), the current values of the @var{variable}s are saved,
the results are assigned to the @var{variable}s, the @var{expression}s
are evaluated sequentially in the current environment, the
@var{variable}s are restored to their original values, and the value of
the last @var{expression} is returned.

@findex let
The syntax of this special form is similar to that of @code{let}, but
@code{fluid-let} temporarily rebinds existing variables.  Unlike
@code{let}, @code{fluid-let} creates no new bindings; instead it
@emph{assigns} the values of each @var{init} to the binding (determined
by the rules of lexical scoping) of its corresponding @var{variable}.

@cindex unassigned variable, and dynamic bindings
MIT Scheme allows any of the @var{init}s to be omitted, in which
case the corresponding @var{variable}s are temporarily unassigned.

An error of type @code{condition-type:unbound-variable} is signalled if
any of the @var{variable}s are unbound.  However, because
@code{fluid-let} operates by means of side effects, it is valid for any
@var{variable} to be unassigned when the form is entered.
@findex condition-type:unbound-variable

Here is an example showing the difference between @code{fluid-let} and
@code{let}.  First see how @code{let} affects the binding of a variable:

@example
@group
(define variable #t)
(define (access-variable) variable)
variable                                @result{}  #t
(let ((variable #f))
  (access-variable))                    @result{}  #t
variable                                @result{}  #t
@end group
@end example

@code{access-variable} returns @code{#t} in this case because it
is defined in an environment with @code{variable} bound to
@code{#t}.  @code{fluid-let}, on the other hand, temporarily reuses an
existing variable:

@example
@group
variable                                @result{}  #t
(fluid-let ((variable #f))              @r{;reuses old binding}
  (access-variable))                    @result{}  #f
variable                                @result{}  #t
@end group
@end example

@cindex extent, of dynamic binding (defn)
The @dfn{extent} of a dynamic binding is defined to be the time period
during which the variable contains the new value.  Normally this time
period begins when the body is entered and ends when it is exited; on a
sequential machine it is normally a contiguous time period.  However,
because Scheme has first-class continuations, it is possible to leave
the body and then reenter it, as many times as desired.  In this
situation, the extent becomes non-contiguous.

@cindex dynamic binding, and continuations
@cindex continuation, and dynamic binding
When the body is exited by invoking a continuation, the new value is
saved, and the variable is set to the old value.  Then, if the body is
reentered by invoking a continuation, the old value is saved, and the
variable is set to the new value.  In addition, side effects to the
variable that occur both inside and outside of body are preserved, even
if continuations are used to jump in and out of body repeatedly.

Here is a complicated example that shows the interaction between dynamic
binding and continuations:

@page
@example
@group
(define (complicated-fluid-binding)
  (let ((variable 1)
        (inside-continuation))
    (write-line variable)
    (call-with-current-continuation
     (lambda (outside-continuation)
       (fluid-let ((variable 2))
         (write-line variable)
         (set! variable 3)
         (call-with-current-continuation
          (lambda (k)
            (set! inside-continuation k)
            (outside-continuation #t)))
         (write-line variable)
         (set! inside-continuation #f))))
    (write-line variable)
    (if inside-continuation
        (begin
          (set! variable 4)
          (inside-continuation #f)))))
@end group
@end example

@noindent
Evaluating @samp{(complicated-fluid-binding)} writes the following on
the console:

@example
@group
1
2
1
3
4
@end group
@end example

@noindent
Commentary: the first two values written are the initial binding of
@code{variable} and its new binding after the @code{fluid-let}'s body is
entered.  Immediately after they are written, @code{variable} is set to
@samp{3}, and then @code{outside-continuation} is invoked, causing us to
exit the body.  At this point, @samp{1} is written, demonstrating that
the original value of @code{variable} has been restored, because we have
left the body.  Then we set @code{variable} to @samp{4} and reenter the
body by invoking @code{inside-continuation}.  At this point, @samp{3} is
written, indicating that the side effect that previously occurred within
the body has been preserved.  Finally, we exit body normally, and write
@samp{4}, demonstrating that the side effect that occurred outside of
the body was also preserved.
@end deffn

@node Definitions, Assignments, Fluid Binding, Special Forms
@section Definitions
@cindex definition

@deffn {special form} define variable [expression]
@deffnx {special form} define @var{formals} expression expression @dots{}
@cindex variable, adding to environment
@cindex definition, top-level (defn)
@cindex definition, internal (defn)
@cindex top-level definition (defn)
@cindex internal definition (defn)
@findex lambda
@findex let
@findex let*
@findex letrec
@findex fluid-let
Definitions are valid in some but not all contexts where expressions are
allowed.  Definitions may only occur at the top level of a program and
at the beginning of a lambda body (that is, the body of a @code{lambda},
@code{let}, @code{let*}, @code{letrec}, @code{fluid-let}, or ``procedure
@code{define}'' expression).  A definition that occurs at the top level
of a program is called a @dfn{top-level definition}, and a definition
that occurs at the beginning of a body is called an @dfn{internal
definition}.

@cindex lambda, implicit in define
@cindex procedure define (defn)
@cindex define, procedure (defn)
@findex named-lambda
In the second form of @code{define} (called ``@dfn{procedure
@code{define}}''), the component @var{formals} is identical to the
component of the same name in a @code{named-lambda} expression.  In
fact, these two expressions are equivalent:

@example
@group
(define (@var{name1} @var{name2} @dots{})
  @var{expression}
  @var{expression} @dots{})
@end group

@group
(define @var{name1}
  (named-lambda (@var{name1} @var{name2} @dots{})
    @var{expression}
    @var{expression} @dots{}))
@end group
@end example
@end deffn

@menu
* Top-Level Definitions::       
* Internal Definitions::        
@end menu

@node Top-Level Definitions, Internal Definitions,  , Definitions
@subsection Top-Level Definitions
@cindex top-level definition
@cindex definition, top-level

@cindex variable binding, top-level definition
A top-level definition,

@example
(define @var{variable} @var{expression})
@end example

@noindent
has essentially the same effect as this assignment expression, if
@var{variable} is bound:

@example
(set! @var{variable} @var{expression})
@end example

@cindex unassigned variable, and definition
@findex set!
If @var{variable} is not bound, however, @code{define} binds
@var{variable} to a new location in the current environment before
performing the assignment (it is an error to perform a @code{set!} on an
unbound variable).  If you omit @var{expression}, the variable becomes
unassigned; an attempt to reference such a variable is an error.

@example
(define add3
   (lambda (x) (+ x 3)))                @result{}  @r{unspecified}
(add3 3)                                @result{}  6

(define first car)                      @result{}  @r{unspecified}
(first '(1 2))                          @result{}  1

(define bar)                            @result{}  @r{unspecified}
bar                                     @error{} Unassigned variable
@end example

@node Internal Definitions,  , Top-Level Definitions, Definitions
@subsection Internal Definitions

@cindex internal definition
@cindex definition, internal
@cindex region of variable binding, internal definition
@cindex variable binding, internal definition
@findex lambda
@findex let
@findex let*
@findex letrec
@findex fluid-let
@findex define
An @dfn{internal definition} is a definition that occurs at the
beginning of a @var{body} (that is, the body of a @code{lambda},
@code{let}, @code{let*}, @code{letrec}, @code{fluid-let}, or ``procedure
@code{define}'' expression), rather than at the top level of a program.
The variable defined by an internal definition is local to the
@var{body}.  That is, @var{variable} is bound rather than assigned, and
the region of the binding is the entire @var{body}.  For example,

@example
@group
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))                        @result{}  45
@end group
@end example

@findex letrec
A @var{body} containing internal definitions can always be converted
into a completely equivalent @code{letrec} expression.  For example, the
@code{let} expression in the above example is equivalent to

@cindex letrec, implicit in define
@example
@group
(let ((x 5))
  (letrec ((foo (lambda (y) (bar x y)))
           (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))
@end group
@end example

@need 1000
@node Assignments, Quoting, Definitions, Special Forms
@section Assignments
@cindex assignment

@deffn {special form} set! variable [expression]
@cindex variable, assigning values to
@cindex unassigned variable, and assignment
If @var{expression} is specified, evaluates @var{expression} and stores
the resulting value in the location to which @var{variable} is bound.
If @var{expression} is omitted, @var{variable} is altered to be
unassigned; a subsequent reference to such a @var{variable} is an error.
In either case, the value of the @code{set!} expression is unspecified.

@var{Variable} must be bound either in some region enclosing the
@code{set!} expression, or at the top level.  However, @var{variable} is
permitted to be unassigned when the @code{set!} form is entered.

@example
@group
(define x 2)                            @result{}  @r{unspecified}
(+ x 1)                                 @result{}  3
(set! x 4)                              @result{}  @r{unspecified}
(+ x 1)                                 @result{}  5
@end group
@end example

@cindex access, used with set!
@findex access
@var{Variable} may be an @code{access} expression
(@pxref{Environments}).  This allows you to assign variables in an
arbitrary environment.  For example,

@example
@group
(define x (let ((y 0)) (the-environment)))
(define y 'a)
y                                       @result{}  a
(access y x)                            @result{}  0
(set! (access y x) 1)                   @result{}  @r{unspecified}
y                                       @result{}  a
(access y x)                            @result{}  1
@end group
@end example
@end deffn

@node Quoting, Conditionals, Assignments, Special Forms
@section Quoting
@cindex quoting

This section describes the expressions that are used to modify or
prevent the evaluation of objects.

@deffn {special form} quote datum
@cindex external representation, and quote
@cindex literal, and quote
@cindex constant, and quote
@code{(quote @var{datum})} evaluates to @var{datum}.  @var{Datum} may be
any external representation of a Scheme object
(@pxref{External Representations}).
Use @code{quote} to include literal constants in
Scheme code.

@example
@group
(quote a)                               @result{}  a
(quote #(a b c))                        @result{}  #(a b c)
(quote (+ 1 2))                         @result{}  (+ 1 2)
@end group
@end example

@cindex ' as external representation
@cindex apostrophe, as external representation
@cindex quote, as external representation
@findex '
@code{(quote @var{datum})} may be abbreviated as @code{'@var{datum}}.
The two notations are equivalent in all respects.

@example
@group
'a                                      @result{}  a
'#(a b c)                               @result{}  #(a b c)
'(+ 1 2)                                @result{}  (+ 1 2)
'(quote a)                              @result{}  'a
''a                                     @result{}  'a
@end group
@end example

Numeric constants, string constants, character constants, and boolean
constants evaluate to themselves, so they don't need to be quoted.

@example
@group
'"abc"                                  @result{}  "abc"
"abc"                                   @result{}  "abc"
'145932                                 @result{}  145932
145932                                  @result{}  145932
'#t                                     @result{}  #t
#t                                      @result{}  #t
'#\a                                    @result{}  #\a
#\a                                     @result{}  #\a
@end group
@end example
@end deffn

@deffn {special form} quasiquote template
@cindex external representation, and quasiquote
@cindex literal, and quasiquote
@cindex constant, and quasiquote
@findex equal?
``Backquote'' or ``quasiquote'' expressions are useful for constructing
a list or vector structure when most but not all of the desired
structure is known in advance.  If no commas appear within the
@var{template}, the result of evaluating @code{`@var{template}} is
equivalent (in the sense of @code{equal?}) to the result of evaluating
@code{'@var{template}}.  If a comma appears within the @var{template},
however, the expression following the comma is evaluated (``unquoted'')
and its result is inserted into the structure instead of the comma and
the expression.  If a comma appears followed immediately by an at-sign
(@@), then the following expression shall evaluate to a list; the
opening and closing parentheses of the list are then ``stripped away''
and the elements of the list are inserted in place of the comma at-sign
expression sequence.

@example
`(list ,(+ 1 2) 4)                           @result{}  (list 3 4)

(let ((name 'a)) `(list ,name ',name))       @result{}  (list a 'a)

`(a ,(+ 1 2) ,@@(map abs '(4 -5 6)) b)        @result{}  (a 3 4 5 6 b)

`((foo ,(- 10 3)) ,@@(cdr '(c)) . ,(car '(cons)))
                                             @result{}  ((foo 7) . cons)

`#(10 5 ,(sqrt 4) ,@@(map sqrt '(16 9)) 8)
                                             @result{}  #(10 5 2 4 3 8)

`,(+ 2 3)                                    @result{}  5
@end example

@cindex nesting, of quasiquote expressions
Quasiquote forms may be nested.  Substitutions are made only for
unquoted components appearing at the same nesting level as the outermost
backquote.  The nesting level increases by one inside each successive
quasiquotation, and decreases by one inside each unquotation.

@example
@group
`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)
     @result{}  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)

(let ((name1 'x)
      (name2 'y))
   `(a `(b ,,name1 ,',name2 d) e))
     @result{}  (a `(b ,x ,'y d) e)
@end group
@end example

@cindex backquote, as external representation
@cindex ` as external representation
@cindex comma, as external representation
@cindex , as external representation
@cindex ,@@ as external representation
@findex unquote
@findex unquote-splicing
@findex `
@findex ,
@findex ,@@
The notations @code{`@var{template}} and (@code{quasiquote
@var{template}}) are identical in all respects.
@code{,@var{expression}} is identical to @code{(unquote
@var{expression})} and @code{,@@@var{expression}} is identical to
@code{(unquote-splicing @var{expression})}.

@example
@group
(quasiquote (list (unquote (+ 1 2)) 4))
     @result{}  (list 3 4)

'(quasiquote (list (unquote (+ 1 2)) 4))
     @result{}  `(list ,(+ 1 2) 4)
     @emph{i.e.,} (quasiquote (list (unquote (+ 1 2)) 4))
@end group
@end example

Unpredictable behavior can result if any of the symbols
@code{quasiquote}, @code{unquote}, or @code{unquote-splicing} appear in
a @var{template} in ways otherwise than as described above.
@end deffn

@node Conditionals, Sequencing, Quoting, Special Forms
@section Conditionals

@cindex expression, conditional (defn)
@cindex conditional expression (defn)
@cindex true, in conditional expression (defn)
@cindex false, in conditional expression (defn)
@findex #f
@findex #t
The behavior of the @dfn{conditional expressions} is determined by
whether objects are true or false.  The conditional expressions count
only @code{#f} as false.  They count everything else, including
@code{#t}, pairs, symbols, numbers, strings, vectors, and procedures as
true (but @pxref{True and False}).

In the descriptions that follow, we say that an object has ``a true
value'' or ``is true'' when the conditional expressions treat it as
true, and we say that an object has ``a false value'' or ``is false''
when the conditional expressions treat it as false.

@deffn {special form} if predicate consequent [alternative]
@var{Predicate}, @var{consequent}, and @var{alternative} are
expressions.  An @code{if} expression is evaluated as follows: first,
@var{predicate} is evaluated.  If it yields a true value, then
@var{consequent} is evaluated and its value is returned.  Otherwise
@var{alternative} is evaluated and its value is returned.  If
@var{predicate} yields a false value and no @var{alternative} is
specified, then the result of the expression is unspecified.

An @code{if} expression evaluates either @var{consequent} or
@var{alternative}, never both.  Programs should not depend on the value
of an @code{if} expression that has no @var{alternative}.

@example
(if (> 3 2) 'yes 'no)                   @result{}  yes
(if (> 2 3) 'yes 'no)                   @result{}  no
(if (> 3 2)
    (- 3 2)
    (+ 3 2))                            @result{}  1
@end example
@end deffn

@deffn {special form} cond clause clause @dots{}
@cindex cond clause
@cindex clause, of cond expression
Each @var{clause} has this form:

@example
(@var{predicate} @var{expression} @dots{})
@end example

@noindent
@cindex else clause, of cond expression (defn)
@findex else
where @var{predicate} is any expression.  The last @var{clause} may be
an @dfn{@code{else} clause}, which has the form:

@example
(else @var{expression} @var{expression} @dots{})
@end example

A @code{cond} expression does the following:

@enumerate
@item
Evaluates the @var{predicate} expressions of successive @var{clause}s in
order, until one of the @var{predicate}s evaluates to a true
value.

@item
When a @var{predicate} evaluates to a true value, @code{cond} evaluates
the @var{expression}s in the associated @var{clause} in left to right
order, and returns the result of evaluating the last @var{expression} in
the @var{clause} as the result of the entire @code{cond} expression.

If the selected @var{clause} contains only the @var{predicate} and no
@var{expression}s, @code{cond} returns the value of the @var{predicate}
as the result.

@item
If all @var{predicate}s evaluate to false values, and there is no
@code{else} clause, the result of the conditional expression is
unspecified; if there is an @code{else} clause, @code{cond} evaluates
its @var{expression}s (left to right) and returns the value of the last
one.
@end enumerate

@example
@group
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less))                  @result{}  greater

(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal))                    @result{}  equal
@end group
@end example

Normally, programs should not depend on the value of a @code{cond}
expression that has no @code{else} clause.  However, some Scheme
programmers prefer to write @code{cond} expressions in which at least
one of the @var{predicate}s is always true.  In this style, the final
@var{clause} is equivalent to an @code{else} clause.

@cindex => in cond clause
@findex =>
Scheme supports an alternative @var{clause} syntax:

@example
(@var{predicate} => @var{recipient})
@end example

@noindent
where @var{recipient} is an expression.  If @var{predicate} evaluates to
a true value, then @var{recipient} is evaluated.  Its value must be a
procedure of one argument; this procedure is then invoked on the value
of the @var{predicate}.

@example
(cond ((assv 'b '((a 1) (b 2))) => cadr)
      (else #f))                        @result{}  2
@end example
@end deffn

@deffn {special form} case key clause clause @dots{}
@cindex case clause
@cindex clause, of case expression
@var{Key} may be any expression.  Each @var{clause} has this
form:

@example
((@var{object} @dots{}) @var{expression} @var{expression} @dots{})
@end example

@cindex else clause, of case expression (defn)
@findex else
No @var{object} is evaluated, and all the @var{object}s must be
distinct.  The last @var{clause} may be an @dfn{@code{else} clause},
which has the form:

@example
(else @var{expression} @var{expression} @dots{})
@end example

A @code{case} expression does the following:

@enumerate
@item
Evaluates @var{key} and compares the result with each
@var{object}.

@item
If the result of evaluating @var{key} is equivalent (in the sense of
@code{eqv?}; @pxref{Equivalence Predicates}) to an @var{object},
@code{case} evaluates the @var{expression}s in the corresponding
@var{clause} from left to right and returns the result of evaluating the
last @var{expression} in the @var{clause} as the result of the
@code{case} expression.
@findex eqv?

@item
If the result of evaluating @var{key} is different from every
@var{object}, and if there's an @code{else} clause, @code{case}
evaluates its @var{expression}s and returns the result of the last one
as the result of the @code{case} expression.  If there's no @code{else}
clause, @code{case} returns an unspecified result.  Programs should not
depend on the value of a @code{case} expression that has no @code{else}
clause.
@end enumerate

For example,

@example
(case (* 2 3)
   ((2 3 5 7) 'prime)
   ((1 4 6 8 9) 'composite))            @result{}  composite

(case (car '(c d))
   ((a) 'a)
   ((b) 'b))                            @result{}  @r{unspecified}

(case (car '(c d))
   ((a e i o u) 'vowel)
   ((w y) 'semivowel)
   (else 'consonant))                   @result{}  consonant
@end example
@end deffn

@deffn {special form} and expression @dots{}
The @var{expression}s are evaluated from left to right, and the value of
the first @var{expression} that evaluates to a false value is returned.
Any remaining @var{expression}s are not evaluated.  If all the
@var{expression}s evaluate to true values, the value of the last
@var{expression} is returned.  If there are no @var{expression}s then
@code{#t} is returned.

@example
@group
(and (= 2 2) (> 2 1))                   @result{}  #t
(and (= 2 2) (< 2 1))                   @result{}  #f
(and 1 2 'c '(f g))                     @result{}  (f g)
(and)                                   @result{}  #t
@end group
@end example
@end deffn

@deffn {special form} or expression @dots{}
The @var{expression}s are evaluated from left to right, and the value of
the first @var{expression} that evaluates to a true value is returned.
Any remaining @var{expression}s are not evaluated.  If all
@var{expression}s evaluate to false values, the value of the last
@var{expression} is returned.  If there are no @var{expression}s then
@code{#f} is returned.

@example
@group
(or (= 2 2) (> 2 1))                    @result{}  #t
(or (= 2 2) (< 2 1))                    @result{}  #t
(or #f #f #f)                           @result{}  #f
(or (memq 'b '(a b c)) (/ 3 0))         @result{}  (b c)
@end group
@end example
@end deffn

@node Sequencing, Iteration, Conditionals, Special Forms
@section Sequencing
@cindex sequencing expressions

@deffn {special form} begin expression expression @dots{}
The @var{expression}s are evaluated sequentially from left to right, and
the value of the last @var{expression} is returned.  This expression
type is used to sequence side effects such as input and output.

@example
@group
(define x 0)
(begin (set! x 5)
       (+ x 1))                 @result{}  6

(begin (display "4 plus 1 equals ")
       (display (+ 4 1)))
                                @print{}  4 plus 1 equals 5
                                @result{}  @r{unspecified}
@end group
@end example

@cindex implicit begin
Often the use of @code{begin} is unnecessary, because many special forms
already support sequences of expressions (that is, they have an implicit
@code{begin}).  Some of these special forms are:

@example
@group
case
cond
define          @r{;``procedure @code{define}'' only}
do
fluid-let
lambda
let
let*
letrec
named-lambda
@end group
@end example
@findex case
@findex cond
@findex define
@findex do
@findex fluid-let
@findex lambda
@findex let
@findex let*
@findex letrec
@findex named-lambda

@findex sequence
The obsolete special form @code{sequence} is identical to @code{begin}.
It should not be used in new code.
@end deffn

@node Iteration, Structure Definitions, Sequencing, Special Forms
@section Iteration

@cindex expression, iteration (defn)
@cindex iteration expression (defn)
@cindex looping (see iteration expressions)
@cindex tail recursion, vs. iteration expression
The @dfn{iteration expressions} are: ``named @code{let}'' and @code{do}.
They are also binding expressions, but are more commonly referred to as
iteration expressions.  Because Scheme is properly tail-recursive, you
don't need to use these special forms to express iteration; you can
simply use appropriately written ``recursive'' procedure calls.

@deffn {special form} let name ((@var{variable} @var{init}) @dots{}) expression expression @dots{}
@cindex named let (defn)
MIT Scheme permits a variant on the syntax of @code{let} called
``named @code{let}'' which provides a more general looping construct
than @code{do}, and may also be used to express recursions.

Named @code{let} has the same syntax and semantics as ordinary
@code{let} except that @var{name} is bound within the @var{expression}s
to a procedure whose formal arguments are the @var{variable}s and whose
body is the @var{expression}s.  Thus the execution of the
@var{expression}s may be repeated by invoking the procedure named by
@var{name}.

@cindex unassigned variable, and named let
MIT Scheme allows any of the @var{init}s to be omitted, in which
case the corresponding @var{variable}s are unassigned.

Note: the following expressions are equivalent:

@example
@group
(let @var{name} ((@var{variable} @var{init}) @dots{})
  @var{expression}
  @var{expression} @dots{})

((letrec ((@var{name}
           (named-lambda (@var{name} @var{variable} @dots{})
             @var{expression}
             @var{expression} @dots{})))
   @var{name})
 @var{init} @dots{})
@end group
@end example

Here is an example:

@example
@group
(let loop
     ((numbers '(3 -2 1 6 -5))
      (nonneg '())
      (neg '()))
  (cond ((null? numbers)
         (list nonneg neg))
        ((>= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        (else
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg)))))

     @result{}  ((6 1 3) (-5 -2))
@end group
@end example
@end deffn

@deffn {special form} do ((@var{variable} @var{init} @var{step}) @dots{}) (@var{test} @var{expression} @dots{}) command @dots{}
@code{do} is an iteration construct.  It specifies a set of variables to
be bound, how they are to be initialized at the start, and how they are
to be updated on each iteration.  When a termination condition is met,
the loop exits with a specified result value.

@code{do} expressions are evaluated as follows: The @var{init}
expressions are evaluated (in some unspecified order), the
@var{variable}s are bound to fresh locations, the results of the
@var{init} expressions are stored in the bindings of the
@var{variable}s, and then the iteration phase begins.

Each iteration begins by evaluating @var{test}; if the result is false,
then the @var{command} expressions are evaluated in order for effect,
the @var{step} expressions are evaluated in some unspecified order, the
@var{variable}s are bound to fresh locations, the results of the
@var{step}s are stored in the bindings of the @var{variable}s, and the
next iteration begins.

If @var{test} evaluates to a true value, then the @var{expression}s are
evaluated from left to right and the value of the last @var{expression}
is returned as the value of the @code{do} expression.  If no
@var{expression}s are present, then the value of the @code{do}
expression is unspecified in standard Scheme; in MIT Scheme, the
value of @var{test} is returned.

@cindex region of variable binding, do
@cindex variable binding, do
The region of the binding of a @var{variable} consists of the entire
@code{do} expression except for the @var{init}s.  It is an error for a
@var{variable} to appear more than once in the list of @code{do}
variables.

A @var{step} may be omitted, in which case the effect is the same as if
@code{(@var{variable} @var{init} @var{variable})} had been written
instead of @code{(@var{variable} @var{init})}.

@example
@group
(do ((vec (make-vector 5))
      (i 0 (+ i 1)))
    ((= i 5) vec)
   (vector-set! vec i i))               @result{}  #(0 1 2 3 4)
@end group

@group
(let ((x '(1 3 5 7 9)))
   (do ((x x (cdr x))
        (sum 0 (+ sum (car x))))
       ((null? x) sum)))                @result{}  25
@end group
@end example
@end deffn

@node Structure Definitions,  , Iteration, Special Forms
@section Structure Definitions

This section provides examples and describes the options and syntax of
@code{define-structure}, an MIT Scheme macro that is very similar to
@code{defstruct} in Common Lisp.  The differences between them are
summarized at the end of this section.  For more information, see
Steele's Common Lisp book.

@deffn {special form+} define-structure (name structure-option @dots{}) slot-description @dots{}
Each @var{slot-description} takes one of the following forms:

@example
@var{slot-name}
(@var{slot-name} @var{default-init} [@var{slot-option} @var{value}]*)
@end example

@cindex keyword constructor
@cindex BOA constructor
The fields @var{name} and @var{slot-name} must both be symbols.  The
field @var{default-init} is an expression for the initial value of the
slot.  It is evaluated each time a new instance is constructed.  If it
is not specified, the initial content of the slot is undefined.  Default
values are only useful with a @sc{boa} constructor with argument list or
a keyword constructor (see below).

Evaluation of a @code{define-structure} expression defines a structure
descriptor and a set of procedures to manipulate instances of the
structure.  These instances are represented as records by default
(@pxref{Records}) but may alternately be lists or vectors.  The
accessors and modifiers are marked with compiler declarations so that
calls to them are automatically transformed into appropriate references.
Often, no options are required, so a simple call to
@code{define-structure} looks like:

@example
(define-structure foo a b c)
@end example

This defines a type descriptor @code{foo}, a constructor
@code{make-foo}, a predicate @code{foo?}, accessors @code{foo-a},
@code{foo-b}, and @code{foo-c}, and modifiers @code{set-foo-a!},
@code{set-foo-b!}, and @code{set-foo-c!}.

In general, if no options are specified, @code{define-structure} defines
the following (using the simple call above as an example):

@table @asis
@item type descriptor
The name of the type descriptor is the same as the name of the
structure, e.g.@: @samp{foo}.  The type descriptor satisfies the
predicate @code{record-type?}.

@item constructor
The name of the constructor is @code{"make-"} followed by the name of
the structure, e.g.@: @samp{make-foo}.  The number of arguments accepted
by the constructor is the same as the number of slots; the arguments are
the initial values for the slots, and the order of the arguments matches
the order of the slot definitions.

@item predicate
The name of the predicate is the name of the structure followed by
@code{"?"}, e.g.@: @samp{foo?}.  The predicate is a procedure of one
argument, which returns @code{#t} if its argument is a record of the
type defined by this structure definition, and @code{#f} otherwise.

@item accessors
For each slot, an accessor is defined.  The name of the accessor is
formed by appending the name of the structure, a hyphen, and the name of
the slot, e.g.@: @samp{foo-a}.  The accessor is a procedure of one
argument, which must be a record of the type defined by this structure
definition.  The accessor extracts the contents of the corresponding
slot in that record and returns it.

@item modifiers
For each slot, a modifier is defined.  The name of the modifier is
formed by appending @code{"set-"}, the name of the accessor, and
@code{"!"}, e.g.@: @samp{set-foo-a!}.  The modifier is a procedure of
two arguments, the first of which must be a record of the type defined
by this structure definition, and the second of which may be any object.
The modifier modifies the contents of the corresponding slot in that
record to be that object, and returns an unspecified value.
@end table

When options are not supplied, @code{(@var{name})} may be abbreviated to
@var{name}.  This convention holds equally for @var{structure-options}
and @var{slot-options}.  Hence, these are equivalent:

@example
(define-structure foo a b c)
(define-structure (foo) (a) b (c))
@end example

@noindent
as are

@example
(define-structure (foo keyword-constructor) a b c)
(define-structure (foo (keyword-constructor)) a b c)
@end example

When specified as option values, @code{false} and @code{nil} are
equivalent to @code{#f}, and @code{true} and @code{t} are equivalent to
@code{#t}.
@end deffn

Possible @var{slot-options} are:

@deffn {slot option} read-only value
When given a @var{value} other than @code{#f}, this specifies that no
modifier should be created for the slot.
@end deffn

@deffn {slot option} type type-descriptor
This is accepted but not presently used.
@end deffn

Possible @var{structure-options} are:

@deffn {structure option} predicate [name]
This option controls the definition of a predicate procedure for the
structure.  If @var{name} is not given, the predicate is defined with
the default name (see above).  If @var{name} is @code{#f}, the predicate
is not defined at all.  Otherwise, @var{name} must be a symbol, and
the predicate is defined with that symbol as its name.
@end deffn

@deffn {structure option} copier [name]
This option controls the definition of a procedure to copy instances of
the structure.  This is a procedure of one argument, a structure
instance, that makes a newly allocated copy of the structure and returns
it.  If @var{name} is not given, the copier is defined, and the name
of the copier is @code{"copy-"} followed by the structure name (e.g.@:
@samp{copy-foo}).  If @var{name} is @code{#f}, the copier is not
defined.  Otherwise, @var{name} must be a symbol, and the copier is
defined with that symbol as its name.
@end deffn

@deffn {structure option} print-procedure expression
Evaluating @var{expression} must yield a procedure of two arguments,
which is used to print instances of the structure.  The procedure is an
@dfn{unparser method} (@pxref{Custom Output}).  If the structure
instances are records, this option has the same effect as calling
@code{set-record-type-unparser-method!}.
@findex set-record-type-unparser-method!
@end deffn

@deffn {structure option} constructor [name [argument-list]]
@cindex BOA constructor (defn)
This option controls the definition of constructor procedures.  These
constructor procedures are called ``@sc{boa} constructors'', for ``By
Order of Arguments'', because the arguments to the constructor specify
the initial contents the structure's slots by the order in which they
are given.  This is as opposed to ``keyword constructors'', which
specify the initial contents using keywords, and in which the order of
arguments is irrelevant.

If @var{name} is not given, a constructor is defined with the default
name and arguments (see above).  If @var{name} is @code{#f}, no
constructor is defined; @var{argument-list} may not be specified in this
case.  Otherwise, @var{name} must be a symbol, and a constructor is
defined with that symbol as its name.  If @var{name} is a symbol,
@var{argument-list} is optionally allowed; if it is omitted, the
constructor accepts one argument for each slot in the structure
definition, in the same order in which the slots appear in the
definition.  Otherwise, @var{argument-list} must be a lambda list
(@pxref{Lambda Expressions}), and each of the parameters of the lambda
list must be the name of a slot in the structure.  The arguments
accepted by the constructor are defined by this lambda list.  Any slot
that is not specified by the lambda list is initialized to the
@var{default-init} as specified above; likewise for any slot specified
as an optional parameter when the corresponding argument is not
supplied.

If the @code{constructor} option is specified, the default constructor
is not defined.  Additionally, the @code{constructor} option may be
specified multiple times to define multiple constructors with
different names and argument lists.

@example
@group
(define-structure (foo (constructor make-foo (#!optional a b)))
  (a 6 read-only #t)
  (b 9))
@end group
@end example
@end deffn

@deffn {structure option} keyword-constructor [name]
@cindex keyword constructor (defn)
This option controls the definition of keyword constructor procedures.
A @dfn{keyword constructor} is a procedure that accepts arguments that
are alternating slot names and values.  If @var{name} is omitted, a
keyword constructor is defined, and the name of the constructor is
@code{"make-"} followed by the name of the structure (e.g.@:
@samp{make-foo}).  Otherwise, @var{name} must be a symbol, and a keyword
constructor is defined with this symbol as its name.

If the @code{keyword-constructor} option is specified, the default
constructor is not defined.  Additionally, the
@code{keyword-constructor} option may be specified multiple times to
define multiple keyword constructors; this is usually not done since
such constructors would all be equivalent.

@example
@group
(define-structure (foo (keyword-constructor make-bar)) a b)
(foo-a (make-bar 'b 20 'a 19))         @result{} 19
@end group
@end example
@end deffn

@deffn {structure option} conc-name [name]
By default, the prefix for naming accessors and modifiers is the name of
the structure followed by a hyphen.  The @code{conc-name} option can be
used to specify an alternative.  If @var{name} is not given, the prefix
is the name of the structure followed by a hyphen (the default).  If
@var{name} is @code{#f}, the slot names are used directly, without
prefix.  Otherwise, @var{name} must a symbol, and that symbol is used as
the prefix.

@example
@code{(define-structure (foo (conc-name moby/)) a b)}
@end example

@noindent
defines accessors @code{moby/a} and @code{moby/b}, and modifiers
@code{set-moby/a!} and @code{set-moby/b!}.

@example
@code{(define-structure (foo (conc-name #f)) a b)}
@end example

@noindent
defines accessors @code{a} and @code{b}, and modifiers @code{set-a!} and
@code{set-b!}.
@end deffn

@deffn {structure option} type representation-type
By default, structures are implemented as records.  The @code{type}
option overrides this default, allowing the programmer to specify that
the structure be implemented using another data type.  The option value
@var{representation-type} specifies the alternate data type; it is
allowed to be one of the symbols @code{vector} or @code{list}, and the
data type used is the one corresponding to the symbol.

If this option is given, and the @code{named} option is not specified,
the representation will not be tagged, and neither a predicate nor a
type descriptor will be defined; also, the @code{print-procedure}
option may not be given.

@example
(define-structure (foo (type list)) a b) 
(make-foo 1 2)                          @result{} (1 2)
@end example
@end deffn

@deffn {structure option} named [expression]
This is valid only in conjunction with the @code{type} option and
specifies that the structure instances be tagged to make them
identifiable as instances of this structure type.  In the usual case,
where @var{expression} is not given, the @code{named} option causes a
type descriptor and predicate to be defined for the structure (recall
that the @code{type} option without @code{named} suppresses their
definition), and also defines a default unparser method for the
structure instances (which can be overridden by the
@code{print-procedure} option).  The type descriptor is a unique object,
@emph{not} a record type, that describes the structure instances and is
additionally stored in the structure instances to identify them: if the
representation type is @code{vector}, the type descriptor is stored in
the zero-th slot of the vector, and if the representation type is
@code{list}, it is stored as the first element of the list.

@example
(define-structure (foo (type vector) named) a b c)
(vector-ref (make-foo 1 2 3) 0) @result{} #[structure-type 52]
@end example

If @var{expression} is specified, it is an expression that is evaluated
to yield a tag object.  The @var{expression} is evaluated once when the
structure definition is evaluated (to specify the unparser method), and
again whenever a predicate or constructor is called.  Because of this,
@var{expression} is normally a variable reference or a constant.  The
value yielded by @var{expression} may be any object at all.  That object
is stored in the structure instances in the same place that the type
descriptor is normally stored, as described above.  If @var{expression}
is specified, no type descriptor is defined, only a predicate.

@example
(define-structure (foo (type vector) (named 'foo)) a b c)
(vector-ref (make-foo 1 2 3) 0) @result{} foo
@end example
@end deffn

@deffn {structure option} initial-offset offset
This is valid only in conjunction with the @code{type} option.
@var{Offset} must be an exact non-negative integer and specifies the
number of slots to leave open at the beginning of the structure instance
before the specified slots are allocated.  Specifying an @var{offset} of
zero is equivalent to omitting the @code{initial-offset} option.

If the @code{named} option is specified, the structure tag appears in
the first slot, followed by the ``offset'' slots, and then the regular
slots.  Otherwise, the ``offset'' slots come first, followed by the
regular slots.

@example
(define-structure (foo (type vector) (initial-offset 3)) a b c)
(make-foo 1 2 3)                @result{} #(() () () 1 2 3)
@end example
@end deffn

The essential differences between MIT Scheme's @code{define-structure}
and Common Lisp's @code{defstruct} are:

@itemize @bullet
@item
The default constructor procedure takes positional arguments, in the
same order as specified in the definition of the structure.  A keyword
constructor may be specified by giving the option
@code{keyword-constructor}.

@item
@sc{boa} constructors are described using Scheme lambda lists.  Since there
is nothing corresponding to @code{&aux} in Scheme lambda lists, this
functionality is not implemented.

@item
By default, no @code{copier} procedure is defined.

@item
The side-effect procedure corresponding to the accessor @code{foo} is
given the name @code{set-foo!}.

@item
Keywords are ordinary symbols -- use @code{foo} instead of @code{:foo}.

@item
The option values @code{false}, @code{nil}, @code{true}, and @code{t}
are treated as if the appropriate boolean constant had been specified
instead.

@item
The @code{print-function} option is named @code{print-procedure}.  Its
argument is a procedure of two arguments (the unparser state and the
structure instance) rather than three as in Common Lisp.

@item
By default, named structures are tagged with a unique object of some
kind.  In Common Lisp, the structures are tagged with symbols.  This
depends on the Common Lisp package system to help generate unique tags;
MIT Scheme has no such way to generate unique symbols.

@item
The @code{named} option may optionally take an argument, which is
normally the name of a variable (any expression may be used, but it is
evaluated whenever the tag name is needed).  If used, structure
instances will be tagged with that variable's value.  The variable must
be defined when @code{define-structure} is evaluated.

@item
The @code{type} option is restricted to the values @code{vector} and
@code{list}.

@item
The @code{include} option is not implemented.
@end itemize

@node Equivalence Predicates, Numbers, Special Forms, Top
@chapter Equivalence Predicates

@cindex predicate (defn)
@cindex predicate, equivalence (defn)
@cindex equivalence predicate (defn)
@cindex comparison, for equivalence
@findex eq?
@findex eqv?
@findex equal?
A @dfn{predicate} is a procedure that always returns a boolean value
(@code{#t} or @code{#f}).  An @dfn{equivalence predicate} is the
computational analogue of a mathematical equivalence relation (it is
symmetric, reflexive, and transitive).  Of the equivalence predicates
described in this section, @code{eq?} is the finest or most
discriminating, and @code{equal?} is the coarsest.  @code{eqv?} is
slightly less discriminating than @code{eq?}.

@deffn procedure eqv? obj1 obj2
The @code{eqv?} procedure defines a useful equivalence relation on
objects.  Briefly, it returns @code{#t} if @var{obj1} and @var{obj2}
should normally be regarded as the same object.

The @code{eqv?} procedure returns @code{#t} if:

@itemize @bullet
@item
@var{obj1} and @var{obj2} are both @code{#t} or both @code{#f}.

@item
@var{obj1} and @var{obj2} are both interned symbols and

@example
(string=? (symbol->string @var{obj1})
          (symbol->string @var{obj2}))
     @result{} #t
@end example
@findex string=?
@findex symbol->string

@item
@var{obj1} and @var{obj2} are both numbers, are numerically equal
according to the @code{=} procedure, and are either both exact or both
inexact (@pxref{Numbers}).
@findex =

@item
@var{obj1} and @var{obj2} are both characters and are the same character
according to the @code{char=?} procedure (@pxref{Characters}).
@findex char=?

@item
both @var{obj1} and @var{obj2} are the empty list.

@item
@var{obj1} and @var{obj2} are procedures whose location tags are equal.

@item
@var{obj1} and @var{obj2} are pairs, vectors, strings, bit strings,
records, cells, or weak pairs that denote the same locations in the
store.
@end itemize

@noindent
The @code{eqv?} procedure returns @code{#f} if:

@itemize @bullet
@item
@var{obj1} and @var{obj2} are of different types.

@item
one of @var{obj1} and @var{obj2} is @code{#t} but the other is
@code{#f}.

@item
@var{obj1} and @var{obj2} are symbols but

@example
(string=? (symbol->string @var{obj1})
          (symbol->string @var{obj2}))
     @result{} #f
@end example
@findex string=?
@findex symbol->string

@item
one of @var{obj1} and @var{obj2} is an exact number but the other is an
inexact number.

@item
@var{obj1} and @var{obj2} are numbers for which the @code{=} procedure
returns @code{#f}.
@findex =

@item
@var{obj1} and @var{obj2} are characters for which the @code{char=?}
procedure returns @code{#f}.
@findex char=?

@item
one of @var{obj1} and @var{obj2} is the empty list but the other is not.

@item
@var{obj1} and @var{obj2} are procedures that would behave differently
(return a different value or have different side effects) for some
arguments.

@item
@var{obj1} and @var{obj2} are pairs, vectors, strings, bit strings,
records, cells, or weak pairs that denote distinct locations.
@end itemize

Some examples:

@example
@group
(eqv? 'a 'a)                    @result{}  #t
(eqv? 'a 'b)                    @result{}  #f
(eqv? 2 2)                      @result{}  #t
(eqv? '() '())                  @result{}  #t
(eqv? 100000000 100000000)      @result{}  #t
(eqv? (cons 1 2) (cons 1 2))    @result{}  #f
(eqv? (lambda () 1)
      (lambda () 2))            @result{}  #f
(eqv? #f 'nil)                  @result{}  #f
(let ((p (lambda (x) x)))
  (eqv? p p))                   @result{}  #t
@end group
@end example

The following examples illustrate cases in which the above rules do not
fully specify the behavior of @code{eqv?}.  All that can be said about
such cases is that the value returned by @code{eqv?} must be a boolean.

@example
@group
(eqv? "" "")                    @result{}  @r{unspecified}
(eqv? '#() '#())                @result{}  @r{unspecified}
(eqv? (lambda (x) x)
      (lambda (x) x))           @result{}  @r{unspecified}
(eqv? (lambda (x) x)
      (lambda (y) y))           @result{}  @r{unspecified}
@end group
@end example

The next set of examples shows the use of @code{eqv?} with procedures
that have local state.  @code{gen-counter} must return a distinct
procedure every time, since each procedure has its own internal counter.
@code{gen-loser}, however, returns equivalent procedures each time,
since the local state does not affect the value or side effects of the
procedures.

@example
@group
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
  (eqv? g g))                   @result{}  #t
(eqv? (gen-counter) (gen-counter))
                                @result{}  #f
@end group

@group
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
  (eqv? g g))                   @result{}  #t
(eqv? (gen-loser) (gen-loser))
                                @result{}  @r{unspecified}
@end group

@group
(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
         (g (lambda () (if (eqv? f g) 'both 'g)))
  (eqv? f g))
                                @result{}  @r{unspecified}

(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
         (g (lambda () (if (eqv? f g) 'g 'both)))
  (eqv? f g))
                                @result{}  #f
@end group
@end example

Objects of distinct types must never be regarded as the same object.

Since it is an error to modify constant objects (those returned by
literal expressions), the implementation may share structure between
constants where appropriate.  Thus the value of @code{eqv?} on constants
is sometimes unspecified.

@example
(let ((x '(a)))
  (eqv? x x))                    @result{}  #t
(eqv? '(a) '(a))                 @result{}  @r{unspecified}
(eqv? "a" "a")                   @result{}  @r{unspecified}
(eqv? '(b) (cdr '(a b)))         @result{}  @r{unspecified}
@end example

Rationale: The above definition of @code{eqv?} allows implementations
latitude in their treatment of procedures and literals: implementations
are free either to detect or to fail to detect that two procedures or
two literals are equivalent to each other, and can decide whether or not
to merge representations of equivalent objects by using the same pointer
or bit pattern to represent both.
@end deffn

@deffn procedure eq? obj1 obj2
@code{eq?} is similar to @code{eqv?} except that in some cases it is
capable of discerning distinctions finer than those detectable by
@code{eqv?}.

@code{eq?} and @code{eqv?} are guaranteed to have the same behavior on
symbols, booleans, the empty list, pairs, records, and non-empty strings
and vectors.  @code{eq?}'s behavior on numbers and characters is
implementation-dependent, but it will always return either true or
false, and will return true only when @code{eqv?} would also return
true.  @code{eq?} may also behave differently from @code{eqv?} on empty
vectors and empty strings.

@example
(eq? 'a 'a)                     @result{}  #t
(eq? '(a) '(a))                 @result{}  @r{unspecified}
(eq? (list 'a) (list 'a))       @result{}  #f
(eq? "a" "a")                   @result{}  @r{unspecified}
(eq? "" "")                     @result{}  @r{unspecified}
(eq? '() '())                   @result{}  #t
(eq? 2 2)                       @result{}  @r{unspecified}
(eq? #\A #\A)                   @result{}  @r{unspecified}
(eq? car car)                   @result{}  #t
(let ((n (+ 2 3)))
  (eq? n n))                    @result{}  @r{unspecified}
(let ((x '(a)))
  (eq? x x))                    @result{}  #t
(let ((x '#()))
  (eq? x x))                    @result{}  #t
(let ((p (lambda (x) x)))
  (eq? p p))                    @result{}  #t
@end example

Rationale: It will usually be possible to implement @code{eq?} much more
efficiently than @code{eqv?}, for example, as a simple pointer
comparison instead of as some more complicated operation.  One reason is
that it may not be possible to compute @code{eqv?} of two numbers in
constant time, whereas @code{eq?} implemented as pointer comparison will
always finish in constant time.  @code{eq?} may be used like @code{eqv?}
in applications using procedures to implement objects with state since
it obeys the same constraints as @code{eqv?}.
@end deffn

@deffn procedure equal? obj1 obj2
@cindex circular structure
@code{equal?} recursively compares the contents of pairs, vectors, and
strings, applying @code{eqv?} on other objects such as numbers, symbols,
and records.  A rule of thumb is that objects are generally
@code{equal?} if they print the same.  @code{equal?} may fail to
terminate if its arguments are circular data structures.

@example
@group
(equal? 'a 'a)                  @result{}  #t
(equal? '(a) '(a))              @result{}  #t
(equal? '(a (b) c)
        '(a (b) c))             @result{}  #t
(equal? "abc" "abc")            @result{}  #t
(equal? 2 2)                    @result{}  #t
(equal? (make-vector 5 'a)
        (make-vector 5 'a))     @result{}  #t
(equal? (lambda (x) x)
        (lambda (y) y))         @result{}  @r{unspecified}
@end group
@end example
@end deffn

@node Numbers, Characters, Equivalence Predicates, Top
@chapter Numbers
@cindex number

(This section is largely taken from the @cite{Revised^4 Report on the
Algorithmic Language Scheme}.)

Numerical computation has traditionally been neglected by the Lisp
community.  Until Common Lisp there was no carefully thought out
strategy for organizing numerical computation, and with the exception of
the MacLisp system little effort was made to execute numerical code
efficiently.  This report recognizes the excellent work of the Common
Lisp committee and accepts many of their recommendations.  In some ways
this report simplifies and generalizes their proposals in a manner
consistent with the purposes of Scheme.

It is important to distinguish between the mathematical numbers, the
Scheme numbers that attempt to model them, the machine representations
used to implement the Scheme numbers, and notations used to write
numbers.  This report uses the types @emph{number}, @emph{complex},
@emph{real}, @emph{rational}, and @emph{integer} to refer to both
mathematical numbers and Scheme numbers.  Machine representations such
as fixed point and floating point are referred to by names such as
@emph{fixnum} and @emph{flonum}.

@menu
* Numerical types::             
* Exactness::                   
* Implementation restrictions::  
* Syntax of numerical constants::  
* Numerical operations::        
* Numerical input and output::  
* Fixnum and Flonum Operations::  
* Random Numbers::              
@end menu

@node Numerical types, Exactness,  , Numbers
@section Numerical types
@cindex numerical types

Mathematically, numbers may be arranged into a tower of subtypes in
which each level is a subset of the level above it:

@display
@group
number
complex
real
rational
integer
@end group
@end display

For example, 3 is an integer.  Therefore 3 is also a rational, a real,
and a complex.  The same is true of the Scheme numbers that model 3.
For Scheme numbers, these types are defined by the predicates
@code{number?}, @code{complex?}, @code{real?}, @code{rational?}, and
@code{integer?}.

There is no simple relationship between a number's type and its
representation inside a computer.  Although most implementations of
Scheme will offer at least two different representations of 3, these
different representations denote the same integer.

Scheme's numerical operations treat numbers as abstract data, as
independent of their representation as possible.  Although an
implementation of Scheme may use fixnum, flonum, and perhaps other
representations for numbers, this should not be apparent to a casual
programmer writing simple programs.

It is necessary, however, to distinguish between numbers that are
represented exactly and those that may not be.  For example, indexes
into data structures must be known exactly, as must some polynomial
coefficients in a symbolic algebra system.  On the other hand, the
results of measurements are inherently inexact, and irrational numbers
may be approximated by rational and therefore inexact approximations.
In order to catch uses of inexact numbers where exact numbers are
required, Scheme explicitly distinguishes exact from inexact numbers.
This distinction is orthogonal to the dimension of type.

@node Exactness, Implementation restrictions, Numerical types, Numbers
@section Exactness
@cindex exactness

Scheme numbers are either @emph{exact} or @emph{inexact}.  A number is
exact if it was written as an exact constant or was derived from exact
numbers using only exact operations.  A number is inexact if it was
written as an inexact constant, if it was derived using inexact
ingredients, or if it was derived using inexact operations. Thus
inexactness is a contagious property of a number.

If two implementations produce exact results for a computation that did
not involve inexact intermediate results, the two ultimate results will
be mathematically equivalent.  This is generally not true of
computations involving inexact numbers since approximate methods such as
floating point arithmetic may be used, but it is the duty of each
implementation to make the result as close as practical to the
mathematically ideal result.

@findex +
Rational operations such as @code{+} should always produce exact results
when given exact arguments.  If the operation is unable to produce an
exact result, then it may either report the violation of an
implementation restriction or it may silently coerce its result to an
inexact value.  @xref{Implementation restrictions}.

@findex inexact->exact
With the exception of @code{inexact->exact}, the operations described in
this section must generally return inexact results when given any
inexact arguments.  An operation may, however, return an exact result if
it can prove that the value of the result is unaffected by the
inexactness of its arguments.  For example, multiplication of any number
by an exact zero may produce an exact zero result, even if the other
argument is inexact.

@node Implementation restrictions, Syntax of numerical constants, Exactness, Numbers
@section Implementation restrictions
@cindex implementation restriction

Implementations of Scheme are not required to implement the whole tower
of subtypes (@pxref{Numerical types}), but they must implement a
coherent subset consistent with both the purposes of the implementation
and the spirit of the Scheme language.  For example, an implementation
in which all numbers are real may still be quite useful.@footnote{MIT
Scheme implements the whole tower of numerical types.  It has
unlimited-precision exact integers and exact rationals.  Flonums are
used to implement all inexact reals; on machines that support @sc{ieee}
floating-point arithmetic these are double-precision floating-point
numbers.}

Implementations may also support only a limited range of numbers of any
type, subject to the requirements of this section.  The supported range
for exact numbers of any type may be different from the supported range
for inexact numbers of that type.  For example, an implementation that
uses flonums to represent all its inexact real numbers may support a
practically unbounded range of exact integers and rationals while
limiting the range of inexact reals (and therefore the range of inexact
integers and rationals) to the dynamic range of the flonum format.
Furthermore the gaps between the representable inexact integers and
rationals are likely to be very large in such an implementation as the
limits of this range are approached.

@findex length
@findex vector-length
@findex string-length
An implementation of Scheme must support exact integers throughout the
range of numbers that may be used for indexes of lists, vectors, and
strings or that may result from computing the length of a list, vector,
or string.  The @code{length}, @code{vector-length}, and
@code{string-length} procedures must return an exact integer, and it is
an error to use anything but an exact integer as an index.  Furthermore
any integer constant within the index range, if expressed by an exact
integer syntax, will indeed be read as an exact integer, regardless of
any implementation restrictions that may apply outside this range.
Finally, the procedures listed below will always return an exact integer
result provided all their arguments are exact integers and the
mathematically expected result is representable as an exact integer
within the implementation:

@example
@group
*                gcd                modulo
+                imag-part          numerator
-                inexact->exact     quotient
abs              lcm                rationalize
angle            magnitude          real-part
ceiling          make-polar         remainder
denominator      make-rectangular   round
expt             max                truncate
floor            min
@end group
@end example

@findex /
Implementations are encouraged, but not required, to support exact
integers and exact rationals of practically unlimited size and
precision, and to implement the above procedures and the @code{/}
procedure in such a way that they always return exact results when given
exact arguments.  If one of these procedures is unable to deliver an
exact result when given exact arguments, then it may either report a
violation of an implementation restriction or it may silently coerce its
result to an inexact number.  Such a coercion may cause an error
later.

An implementation may use floating point and other approximate
representation strategies for inexact numbers.  This report recommends,
but does not require, that the @sc{ieee} 32-bit and 64-bit floating
point standards be followed by implementations that use flonum
representations, and that implementations using other representations
should match or exceed the precision achievable using these floating
point standards.

@findex sqrt
In particular, implementations that use flonum representations must
follow these rules: A flonum result must be represented with at least as
much precision as is used to express any of the inexact arguments to
that operation.  It is desirable (but not required) for potentially
inexact operations such as @code{sqrt}, when applied to exact arguments,
to produce exact answers whenever possible (for example the square root
of an exact 4 ought to be an exact 2).  If, however, an exact number is
operated upon so as to produce an inexact result (as by @code{sqrt}),
and if the result is represented as a flonum, then the most precise
flonum format available must be used; but if the result is represented
in some other way then the representation must have at least as much
precision as the most precise flonum format available.

Although Scheme allows a variety of written notations for numbers, any
particular implementation may support only some of them.@footnote{MIT
Scheme implements all of the written notations for numbers.} For
example, an implementation in which all numbers are real need not
support the rectangular and polar notations for complex numbers.  If an
implementation encounters an exact numerical constant that it cannot
represent as an exact number, then it may either report a violation of
an implementation restriction or it may silently represent the constant
by an inexact number.

@node Syntax of numerical constants, Numerical operations, Implementation restrictions, Numbers
@section Syntax of numerical constants
@cindex number, external representation
@cindex external representation, for number

@findex #b
@findex #o
@findex #d
@findex #x
@cindex #b as external representation
@cindex #o as external representation
@cindex #d as external representation
@cindex #x as external representation
A number may be written in binary, octal, decimal, or hexadecimal by the
use of a radix prefix.  The radix prefixes are @code{#b} (binary),
@code{#o} (octal), @code{#d} (decimal), and @code{#x} (hexadecimal).
With no radix prefix, a number is assumed to be expressed in
decimal.

@findex #e
@findex #i
@findex #
@cindex #e as external representation
@cindex #i as external representation
@cindex # in external representation of number
A numerical constant may be specified to be either exact or inexact by a
prefix.  The prefixes are @code{#e} for exact, and @code{#i} for
inexact.  An exactness prefix may appear before or after any radix
prefix that is used.  If the written representation of a number has no
exactness prefix, the constant may be either inexact or exact.  It is
inexact if it contains a decimal point, an exponent, or a @code{#}
character in the place of a digit, otherwise it is exact.

@cindex s, as exponent marker in number
@cindex f, as exponent marker in number
@cindex d, as exponent marker in number
@cindex l, as exponent marker in number
@cindex e, as exponent marker in number
@cindex exponent marker (defn)
@cindex precision, of inexact number
@cindex numeric precision, inexact
@cindex internal representation, for inexact number
@cindex short precision, of inexact number
@cindex single precision, of inexact number
@cindex double precision, of inexact number
@cindex long precision, of inexact number
In systems with inexact numbers of varying precisions it may be useful
to specify the precision of a constant.  For this purpose, numerical
constants may be written with an @dfn{exponent marker} that indicates
the desired precision of the inexact representation.  The letters
@code{s}, @code{f}, @code{d}, and @code{l} specify the use of
@emph{short}, @emph{single}, @emph{double}, and @emph{long} precision,
respectively.  (When fewer than four internal inexact representations
exist, the four size specifications are mapped onto those available.
For example, an implementation with two internal representations may map
short and single together and long and double together.)  In addition,
the exponent marker @code{e} specifies the default precision for the
implementation.  The default precision has at least as much precision as
@emph{double}, but implementations may wish to allow this default to be
set by the user.

@example
@group
3.14159265358979F0
       @r{Round to single ---} 3.141593
0.6L0
       @r{Extend to long ---} .600000000000000
@end group
@end example

@node Numerical operations, Numerical input and output, Syntax of numerical constants, Numbers
@section Numerical operations
@cindex numerical operations

@xref{Entry Format} for a summary of the naming conventions used to
specify restrictions on the types of arguments to numerical routines.
The examples used in this section assume that any numerical constant
written using an exact notation is indeed represented as an exact
number.  Some examples also assume that certain numerical constants
written using an inexact notation can be represented without loss of
accuracy; the inexact constants were chosen so that this is likely to be
true in implementations that use flonums to represent inexact
numbers.

@deffn procedure number? object
@deffnx procedure complex? object
@deffnx procedure real? object
@deffnx procedure rational? object
@deffnx procedure integer? object
@cindex type predicate, for number
These numerical type predicates can be applied to any kind of argument,
including non-numbers.  They return @code{#t} if the object is of the
named type, and otherwise they return @code{#f}.  In general, if a type
predicate is true of a number then all higher type predicates are also
true of that number.  Consequently, if a type predicate is false of a
number, then all lower type predicates are also false of that
number.@footnote{In MIT Scheme the @code{rational?} procedure is the
same as @code{real?}, and the @code{complex?} procedure is the same as
@code{number?}.}

@findex zero?
@findex =
If @var{z} is an inexact complex number, then @code{(real? @var{z})} is
true if and only if @code{(zero? (imag-part @var{z}))} is true.  If
@var{x} is an inexact real number, then @code{(integer? @var{x})} is
true if and only if @code{(= @var{x} (round @var{x}))}.

@example
@group
(complex? 3+4i)         @result{}  #t
(complex? 3)            @result{}  #t
(real? 3)               @result{}  #t
(real? -2.5+0.0i)       @result{}  #t
(real? #e1e10)          @result{}  #t
(rational? 6/10)        @result{}  #t
(rational? 6/3)         @result{}  #t
(integer? 3+0i)         @result{}  #t
(integer? 3.0)          @result{}  #t
(integer? 8/4)          @result{}  #t
@end group
@end example

Note: The behavior of these type predicates on inexact numbers is
unreliable, since any inaccuracy may affect the result.

@end deffn

@deffn procedure exact? z
@deffnx procedure inexact? z
These numerical predicates provide tests for the exactness of a
quantity.  For any Scheme number, precisely one of these predicates is
true.
@end deffn

@deffn {procedure+} exact-integer? object
@deffnx {procedure+} exact-nonnegative-integer? object
@deffnx {procedure+} exact-rational? object
These procedures test for some very common types of numbers.  These
tests could be written in terms of simpler predicates, but are more
efficient.
@end deffn

@deffn procedure = z1 z2 z3 @dots{}
@deffnx procedure < x1 x2 x3 @dots{}
@deffnx procedure > x1 x2 x3 @dots{}
@deffnx procedure <= x1 x2 x3 @dots{}
@deffnx procedure >= x1 x2 x3 @dots{}
@cindex ordering, of numbers
@cindex comparison, of numbers
@cindex equivalence predicate, for numbers
These procedures return @code{#t} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing, monotonically
nondecreasing, or monotonically nonincreasing.

These predicates are transitive.  Note that the traditional
implementations of these predicates in Lisp-like languages are not
transitive.

Note: While it is not an error to compare inexact numbers using these
predicates, the results may be unreliable because a small inaccuracy may
affect the result; this is especially true of @code{=} and @code{zero?}.
When in doubt, consult a numerical analyst.
@end deffn

@deffn procedure zero? z
@deffnx procedure positive? x
@deffnx procedure negative? x
@deffnx procedure odd? x
@deffnx procedure even? x
@cindex zero
@cindex positive number
@cindex negative number
@cindex odd number
@cindex even number
These numerical predicates test a number for a particular property,
returning @code{#t} or @code{#f}.  See note above regarding inexact
numbers.
@end deffn

@deffn procedure max x1 x2 @dots{}
@deffnx procedure min x1 x2 @dots{}
@cindex minimum, of numbers
@cindex maximum, of numbers
These procedures return the maximum or minimum of their
arguments.

@example
@group
(max 3 4)              @result{}  4    @r{; exact}
(max 3.9 4)            @result{}  4.0  @r{; inexact}
@end group
@end example

Note: If any argument is inexact, then the result will also be inexact
(unless the procedure can prove that the inaccuracy is not large enough
to affect the result, which is possible only in unusual
implementations).  If @code{min} or @code{max} is used to compare
numbers of mixed exactness, and the numerical value of the result cannot
be represented as an inexact number without loss of accuracy, then the
procedure may report a violation of an implementation
restriction.@footnote{MIT Scheme signals an error of type
@code{condition-type:bad-range-argument} in this case.}
@findex condition-type:bad-range-argument
@end deffn

@deffn procedure + z1 @dots{}
@deffnx procedure * z1 @dots{}
@cindex addition, of numbers
@cindex sum, of numbers
@cindex identity, additive
@cindex multiplication, of numbers
@cindex product, of numbers
@cindex identity, multiplicative
These procedures return the sum or product of their arguments.

@example
@group
(+ 3 4)                 @result{}  7
(+ 3)                   @result{}  3
(+)                     @result{}  0
(* 4)                   @result{}  4
(*)                     @result{}  1
@end group
@end example
@end deffn

@deffn procedure - z1 z2 @dots{}
@deffnx procedure / z1 z2 @dots{}
@cindex subtraction, of numbers
@cindex difference, of numbers
@cindex inverse, additive, of number
@cindex division, of numbers
@cindex quotient, of numbers
@cindex inverse, multiplicative, of number
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one
argument, however, they return the additive or multiplicative inverse of
their argument.

@example
@group
(- 3 4)                 @result{}  -1
(- 3 4 5)               @result{}  -6
(- 3)                   @result{}  -3
(/ 3 4 5)               @result{}  3/20
(/ 3)                   @result{}  1/3
@end group
@end example
@end deffn

@deffn {procedure+} 1+ z
@deffnx {procedure+} -1+ z
@code{(1+ z)} is equivalent to @code{(+ z 1)}; @code{(-1+ z)} is
equivalent to @code{(- z 1)}.
@end deffn

@deffn procedure abs x
@cindex absolute value, of number
@cindex magnitude, of real number
@code{abs} returns the magnitude of its argument.

@example
(abs -7)                @result{}  7
@end example
@end deffn

@deffn procedure quotient n1 n2
@deffnx procedure remainder n1 n2
@deffnx procedure modulo n1 n2
@cindex division, of integers
@cindex quotient, of integers
@cindex remainder, of integers
@cindex modulus, of integers
@cindex integer division
These procedures implement number-theoretic (integer) division: for
positive integers @var{n1} and @var{n2}, if @var{n3} and @var{n4} are
integers such that
@tex
$$n_1=n_2n_3+n_4$$
$$0\leq n_4<n_2$$
@end tex
@ifinfo

@example
@var{n1} = (@var{n2} * @var{n3}) + @var{n4}

0 <= @var{n4} < @var{n2}
@end example

@end ifinfo
@noindent
then

@example
@group
(quotient @var{n1} @var{n2})        @result{}  @var{n3}
(remainder @var{n1} @var{n2})       @result{}  @var{n4}
(modulo @var{n1} @var{n2})          @result{}  @var{n4}
@end group
@end example

@noindent
For integers @var{n1} and @var{n2} with @var{n2} not equal to 0,

@example
@group
(= @var{n1} 
   (+ (* @var{n2} (quotient @var{n1} @var{n2}))
      (remainder @var{n1} @var{n2})))
                                    @result{}  #t
@end group
@end example

@noindent
provided all numbers involved in that computation are exact.

The value returned by @code{quotient} always has the sign of the product
of its arguments.  @code{remainder} and @code{modulo} differ on negative
arguments --- the @code{remainder} always has the sign of the dividend,
the @code{modulo} always has the sign of the divisor:

@example
@group
(modulo 13 4)           @result{}  1
(remainder 13 4)        @result{}  1

(modulo -13 4)          @result{}  3
(remainder -13 4)       @result{}  -1

(modulo 13 -4)          @result{}  -3
(remainder 13 -4)       @result{}  1

(modulo -13 -4)         @result{}  -1
(remainder -13 -4)      @result{}  -1

(remainder -13 -4.0)    @result{}  -1.0  @r{; inexact}
@end group
@end example

@findex integer-truncate
Note that @code{quotient} is the same as @code{integer-truncate}.
@end deffn

@deffn {procedure+} integer-floor n1 n2
@deffnx {procedure+} integer-ceiling n1 n2
@deffnx {procedure+} integer-truncate n1 n2
@deffnx {procedure+} integer-round n1 n2
These procedures combine integer division with rounding.  For example,
the following are equivalent:

@example
@group
(integer-floor @var{n1} @var{n2})
(floor (/ @var{n1} @var{n2}))
@end group
@end example

@noindent
However, the former is faster and does not produce an intermediate
result.

@findex quotient
Note that @code{integer-truncate} is the same as @code{quotient}.
@end deffn

@deffn {procedure+} integer-divide n1 n2
@deffnx {procedure+} integer-divide-quotient qr
@deffnx {procedure+} integer-divide-remainder qr
@findex quotient
@findex remainder
@code{integer-divide} is equivalent to performing both @code{quotient}
and @code{remainder} at once.  The result of @code{integer-divide} is an
object with two components; the procedures
@code{integer-divide-quotient} and @code{integer-divide-remainder}
select those components.  These procedures are useful when both the
quotient and remainder are needed; often computing both of these numbers
simultaneously is much faster than computing them separately.

For example, the following are equivalent:

@example
@group
(lambda (n d)
  (cons (quotient n d)
        (remainder n d)))

(lambda (n d)
  (let ((qr (integer-divide n d)))
    (cons (integer-divide-quotient qr)
          (integer-divide-remainder qr))))
@end group
@end example
@end deffn

@deffn procedure gcd n1 @dots{}
@deffnx procedure lcm n1 @dots{}
@cindex greatest common divisor, of numbers
@cindex least common multiple, of numbers
These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non-negative.

@example
@group
(gcd 32 -36)            @result{}  4
(gcd)                   @result{}  0

(lcm 32 -36)            @result{}  288
(lcm 32.0 -36)          @result{}  288.0  @r{; inexact}
(lcm)                   @result{}  1
@end group
@end example
@end deffn

@deffn procedure numerator q
@deffnx procedure denominator q
These procedures return the numerator or denominator of their argument;
the result is computed as if the argument was represented as a fraction
in lowest terms.  The denominator is always positive.  The denominator
of 0 is defined to be 1.

@example
@group
(numerator (/ 6 4))  @result{}  3
(denominator (/ 6 4))  @result{}  2
(denominator (exact->inexact (/ 6 4))) @result{} 2.0
@end group
@end example
@end deffn

@deffn procedure floor x
@deffnx procedure ceiling x
@deffnx procedure truncate x
@deffnx procedure round x
These procedures return integers.  @code{floor} returns the largest
integer not larger than @var{x}.  @code{ceiling} returns the smallest
integer not smaller than @var{x}.  @code{truncate} returns the integer
closest to @var{x} whose absolute value is not larger than the absolute
value of @var{x}.  @code{round} returns the closest integer to @var{x},
rounding to even when @var{x} is halfway between two integers.

Rationale: @code{round} rounds to even for consistency with the rounding
modes required by the @sc{ieee} floating point standard.

Note: If the argument to one of these procedures is inexact, then the
result will also be inexact.  If an exact value is needed, the result
should be passed to the @code{inexact->exact} procedure (or use one of
the procedures below).

@example
@group
(floor -4.3)          @result{}  -5.0
(ceiling -4.3)        @result{}  -4.0
(truncate -4.3)       @result{}  -4.0
(round -4.3)          @result{}  -4.0

(floor 3.5)           @result{}  3.0
(ceiling 3.5)         @result{}  4.0
(truncate 3.5)        @result{}  3.0
(round 3.5)           @result{}  4.0  @r{; inexact}

(round 7/2)           @result{}  4    @r{; exact}
(round 7)             @result{}  7
@end group
@end example
@end deffn

@deffn {procedure+} floor->exact x
@deffnx {procedure+} ceiling->exact x
@deffnx {procedure+} truncate->exact x
@deffnx {procedure+} round->exact x
These procedures are similar to the preceding procedures except that
they always return an exact result.  For example, the following are
equivalent

@example
@group
(floor->exact x)
(inexact->exact (floor x))
@end group
@end example

@noindent
except that the former is faster and has fewer range restrictions.
@end deffn

@deffn procedure rationalize x y
@deffnx {procedure+} rationalize->exact x y
@cindex simplest rational (defn)
@cindex rational, simplest (defn)
@code{rationalize} returns the @emph{simplest} rational number differing
from @var{x} by no more than @var{y}.  A rational number @var{r1} is
@emph{simpler} than another rational number @var{r2} if
@t{@var{r1}=@var{p1}/@var{q1}} and @t{@var{r2}=@var{p2}/@var{q2}} (both
in lowest terms) and @t{|@var{p1}|<=|@var{p2}|} and
@t{|@var{q1}|<=|@var{q2}|}.  Thus @t{3/5} is simpler than @t{4/7}.
Although not all rationals are comparable in this ordering (consider
@t{2/7} and @t{3/5}) any interval contains a rational number that is
simpler than every other rational number in that interval (the simpler
@t{2/5} lies between @t{2/7} and @t{3/5}).  Note that @t{0=0/1} is the
simplest rational of all.

@example
@group
(rationalize (inexact->exact .3) 1/10)  @result{} 1/3    @r{; exact}
(rationalize .3 1/10)                   @result{} #i1/3  @r{; inexact}
@end group
@end example

@code{rationalize->exact} is similar to @code{rationalize} except that
it always returns an exact result.
@end deffn

@deffn {procedure+} simplest-rational x y
@deffnx {procedure+} simplest-exact-rational x y
@code{simplest-rational} returns the simplest rational number between
@var{x} and @var{y} inclusive; @code{simplest-exact-rational} is similar
except that it always returns an exact result.

These procedures implement the same functionality as @code{rationalize}
and @code{rationalize->exact}, except that they specify the input range
by its endpoints; @code{rationalize} specifies the range by its center
point and its (half-) width.
@end deffn

@deffn procedure exp z
@deffnx procedure log z
@deffnx procedure sin z
@deffnx procedure cos z
@deffnx procedure tan z
@deffnx procedure asin z
@deffnx procedure acos z
@deffnx procedure atan z
@deffnx procedure atan y x
@findex angle
@findex make-rectangular
These procedures compute the usual transcendental functions.  @code{log}
computes the natural logarithm of @var{z} (not the base ten logarithm).
@code{asin}, @code{acos}, and @code{atan} compute arcsine, arccosine,
and arctangent, respectively.  The two-argument variant of @code{atan}
computes @code{(angle (make-rectangular @var{x} @var{y}))} (see
below).

In general, the mathematical functions log, arcsine, arccosine, and
arctangent are multiply defined.  For nonzero real @var{x}, the value of
log @var{x} is defined to be the one whose imaginary part lies in the
range minus @var{pi} (exclusive) to @var{pi} (inclusive).  log 0 is
undefined.  The value of log @var{z} when @var{z} is complex is defined
according to the formula
@tex
$$\log z = \log {\rm magnitude}(z) + i {\rm angle} (z)$$
@end tex
@ifinfo

@example
log @var{z} = log magnitude(@var{z}) + i angle(@var{z})
@end example

@end ifinfo
With log defined this way, the values of arcsine, arccosine, and
arctangent are according to the following formulae:
@tex
$$\sin^{-1} z = -i \log (i z + \sqrt{1 - z^2})$$
$$\cos^{-1} z = \pi / 2 - \sin^{-1} z$$
$$\tan^{-1} z = (\log (1 + i z) - \log (1 - i z)) / (2 i)$$
@end tex
@ifinfo

@example
arcsin(@var{z}) = -i log(i @var{z} + sqrt(1 - @var{z}^2))
arccos(@var{z}) = pi/2 - arcsin(@var{z})
arctan(@var{z}) = (log(1 + i @var{z}) + log(1 - i @var{z})) / (2 i)
@end example

@end ifinfo
The above specification follows @cite{Common Lisp: the Language}, which
in turn cites @cite{Principal Values and Branch Cuts in Complex APL};
refer to these sources for more detailed discussion of branch cuts,
boundary conditions, and implementation of these functions.  When it is
possible these procedures produce a real result from a real
argument.
@end deffn

@deffn procedure sqrt z
Returns the principal square root of @var{z}.  The result will have
either positive real part, or zero real part and non-negative imaginary
part.
@end deffn

@deffn procedure expt z1 z2
Returns @var{z1} raised to the power @var{z2}:
@tex
$${z_1}^{z_2} = e^{z_2 \log {z_1}}$$
$0^0$ is defined to be equal to 1.
@end tex
@ifinfo

@example
@var{z1}^@var{z2} = e^(@var{z2} log @var{z1})
@end example

@noindent
0^0 is defined to be equal to 1.
@end ifinfo
@end deffn

@deffn procedure make-rectangular x1 x2
@deffnx procedure make-polar x3 x4
@deffnx procedure real-part z
@deffnx procedure imag-part z
@deffnx procedure magnitude z
@deffnx procedure angle z
@deffnx {procedure+} conjugate z
Suppose @var{x1}, @var{x2}, @var{x3}, and @var{x4} are real numbers and
@var{z} is a complex number such that
@tex
 $$ z = x_1 + x_2\hbox{$i$}
 = x_3 \cdot e^{{\displaystyle{\hbox{$i$}} x_4}}$$
@end tex
@ifinfo

@example
@var{z} = @var{x1} + @var{x2} i = @var{x3} e^(i @var{x4})
@end example

@end ifinfo
@noindent
Then @code{make-rectangular} and @code{make-polar} return @var{z},
@code{real-part} returns @var{x1}, @code{imag-part} returns @var{x2},
@code{magnitude} returns @var{x3}, and @code{angle} returns @var{x4}.
In the case of @code{angle}, whose value is not uniquely determined by
the preceding rule, the value returned will be the one in the range
minus @var{pi} (exclusive) to @var{pi} (inclusive).

@code{conjugate} returns the complex conjugate of @var{z}.
@end deffn

@deffn procedure exact->inexact z
@deffnx procedure inexact->exact z
@code{exact->inexact} returns an inexact representation of @var{z}.  The
value returned is the inexact number that is numerically closest to the
argument.  If an exact argument has no reasonably close inexact
equivalent, then a violation of an implementation restriction may be
reported; MIT Scheme signals an error of type
@code{condition-type:bad-range-argument} in this case.
@findex condition-type:bad-range-argument

@code{inexact->exact} returns an exact representation of @var{z}.  The
value returned is the exact number that is numerically closest to the
argument.  If an inexact argument has no reasonably close exact
equivalent, then a violation of an implementation restriction may be
reported; in MIT Scheme this case does not occur because all inexact
numbers are representable as exact numbers.

These procedures implement the natural one-to-one correspondence between
exact and inexact integers throughout an implementation-dependent range.
@xref{Implementation restrictions}.
@end deffn

@node Numerical input and output, Fixnum and Flonum Operations, Numerical operations, Numbers
@section Numerical input and output
@cindex numerical input and output

@deffn procedure number->string number [radix]
@var{Radix} must be an exact integer, either 2, 8, 10, or 16.  If
omitted, @var{radix} defaults to 10.  The procedure
@code{number->string} takes a number and a radix and returns as a string
an external representation of the given number in the given radix such
that

@example
@group
(let ((number @var{number})
      (radix @var{radix}))
  (eqv? number
        (string->number (number->string number radix)
                        radix)))
@end group
@end example

@noindent
is true.  It is an error if no possible result makes this expression
true.

If @var{number} is inexact, the radix is 10, and the above expression
can be satisfied by a result that contains a decimal point, then the
result contains a decimal point and is expressed using the minimum
number of digits (exclusive of exponent and trailing zeroes) needed to
make the above expression true; otherwise the format of the result is
unspecified.

The result returned by @code{number->string} never contains an explicit
radix prefix.

Note: The error case can occur only when @var{number} is not a complex
number or is a complex number with an non-rational real or imaginary
part.

Rationale: If @var{number} is an inexact number represented using
flonums, and the radix is 10, then the above expression is normally
satisfied by a result containing a decimal point.  The unspecified case
allows for infinities, NaNs, and non-flonum representations.
@end deffn

@defvr {variable+} flonum-unparser-cutoff
This variable controls the action of @code{number->string} when
@var{number} is a flonum (and consequently controls all printing of
flonums); it can have the following values:

@itemize @bullet
@item
The symbol @code{normal}, which is the initial value of this variable,
causes flonums to be printed with full precision.  @code{number->string}
uses as many digits as are necessary to display all of the information
in the flonum.  This value may also be specified as a list @code{(normal
@var{n})} where @var{n} is an exact integer; @var{n} is ignored.

@item
The list @code{(relative @var{n})}, where @var{n} is an exact positive
integer, constrains @code{number->string} to represent the flonum using
at most @var{n} significant digits.  @code{number->string} rounds the
result so that it is as accurate as possible.  For example:

@example
@group
(number->string (* 4 (atan 1 1)))
                                    @result{} "3.141592653589793"
(fluid-let ((flonum-unparser-cutoff '(relative 5)))
  (number->string (* 4 (atan 1 1))))
                                    @result{} "3.1416"
(fluid-let ((flonum-unparser-cutoff '(relative 5)))
  (number->string (* 4000 (atan 1 1))))
                                    @result{} "3141.6"
@end group
@end example

@item
The list @code{(absolute @var{n})}, where @var{n} is an exact integer,
constrains @code{number->string} to represent the flonum by rounding it
at the @var{n}th digit to the right of the decimal point; if @var{n} is
negative, the number is rounded @code{(- @var{n})} digits to the left of
the decimal point.  For example:

@example
@group
(fluid-let ((flonum-unparser-cutoff '(absolute 5)))
  (number->string (* 4 (atan 1 1))))
                                    @result{} "3.14159"
(fluid-let ((flonum-unparser-cutoff '(absolute 5)))
  (number->string (* 4000 (atan 1 1))))
                                    @result{} "3141.59265"
(fluid-let ((flonum-unparser-cutoff '(absolute -4)))
  (number->string (* 4e10 (atan 1 1))))
                                    @result{} "31415930000."
(fluid-let ((flonum-unparser-cutoff '(absolute -5)))
  (number->string (* 4e10 (atan 1 1))))
                                    @result{} "31415900000."
@end group
@end example
@end itemize

@noindent
If @code{flonum-unparser-cutoff} is bound to a value different from
those described here, @code{number->string} issues a warning and acts as
though it had been bound to @code{normal}.
@end defvr

@deffn procedure string->number string [radix]
Returns a number of the maximally precise representation expressed by
the given @var{string}.  @var{Radix} must be an exact integer, either 2,
8, 10, or 16.  If supplied, @var{radix} is a default radix that may be
overridden by an explicit radix prefix in @var{string} (e.g.@:
@code{"#o177"}).  If @var{radix} is not supplied, then the default radix
is 10.  If @var{string} is not a syntactically valid notation for a
number, then @code{string->number} returns @code{#f}.

@example
@group
(string->number "100")        @result{}  100
(string->number "100" 16)     @result{}  256
(string->number "1e2")        @result{}  100.0
(string->number "15##")       @result{}  1500.0
@end group
@end example

@noindent
Note that a numeric representation using a decimal point or an exponent
marker is not recognized unless @var{radix} is @code{10}.
@end deffn

@node Fixnum and Flonum Operations, Random Numbers, Numerical input and output, Numbers
@section Fixnum and Flonum Operations

This section describes numerical operations that are restricted forms of
the operations described above.  These operations are useful because
they compile very efficiently.  However, care should be exercised: if
used improperly, these operations can return incorrect answers, or even
malformed objects that confuse the garbage collector.

@menu
* Fixnum Operations::           
* Flonum Operations::           
@end menu

@node Fixnum Operations, Flonum Operations,  , Fixnum and Flonum Operations
@subsection Fixnum Operations

@cindex fixnum (defn)
A @dfn{fixnum} is an exact integer that is small enough to fit in a
machine word.  In MIT Scheme, fixnums are typically 24 or 26 bits,
depending on the machine; it is reasonable to assume that fixnums are at
least 24 bits.  Fixnums are signed; they are encoded using 2's
complement.

All exact integers that are small enough to be encoded as fixnums are
always encoded as fixnums --- in other words, any exact integer that is
not a fixnum is too big to be encoded as such.  For this reason, small
constants such as @code{0} or @code{1} are guaranteed to be fixnums.

@deffn {procedure+} fix:fixnum? object
@cindex type predicate, for fixnum
Returns @code{#t} if @var{object} is a fixnum; otherwise returns
@code{#f}.
@end deffn

Here is an expression that determines the largest fixnum:

@example
@group
(let loop ((n 0))
  (let ((m (+ n 1)))
    (if (fix:fixnum? m)
        (loop m)
        n)))
@end group
@end example

@noindent
A similar expression determines the smallest fixnum.

@deffn {procedure+} fix:= fixnum fixnum
@deffnx {procedure+} fix:< fixnum fixnum
@deffnx {procedure+} fix:> fixnum fixnum
@deffnx {procedure+} fix:<= fixnum fixnum
@deffnx {procedure+} fix:>= fixnum fixnum
@cindex equivalence predicate, for fixnums
These are the standard order and equality predicates on fixnums.  When
compiled, they do not check the types of their arguments.
@end deffn

@deffn {procedure+} fix:zero? fixnum
@deffnx {procedure+} fix:positive? fixnum
@deffnx {procedure+} fix:negative? fixnum
These procedures compare their argument to zero.  When compiled, they do
not check the type of their argument.  The code produced by the
following expressions is identical:

@example
@group
(fix:zero? @var{fixnum})
(fix:= @var{fixnum} 0)
@end group
@end example

@noindent
Similarly, @code{fix:positive?} and @code{fix:negative?} produce code
identical to equivalent expressions using @code{fix:>} and @code{fix:<}.
@end deffn

@deffn {procedure+} fix:+ fixnum fixnum
@deffnx {procedure+} fix:- fixnum fixnum
@deffnx {procedure+} fix:* fixnum fixnum
@deffnx {procedure+} fix:quotient fixnum fixnum
@deffnx {procedure+} fix:remainder fixnum fixnum
@deffnx {procedure+} fix:gcd fixnum fixnum
@deffnx {procedure+} fix:1+ fixnum
@deffnx {procedure+} fix:-1+ fixnum
These procedures are the standard arithmetic operations on fixnums.
When compiled, they do not check the types of their arguments.
Furthermore, they do not check to see if the result can be encoded as a
fixnum.  If the result is too large to be encoded as a fixnum, a
malformed object is returned, with potentially disastrous effect on the
garbage collector.
@end deffn

@deffn {procedure+} fix:divide fixnum fixnum
@findex integer-divide
@findex integer-divide-quotient
@findex integer-divide-remainder
This procedure is like @code{integer-divide}, except that its arguments
and its results must be fixnums.  It should be used in conjunction with
@code{integer-divide-quotient} and @code{integer-divide-remainder}.
@end deffn

@cindex logical operations, on fixnums
@cindex bitwise-logical operations, on fixnums
The following are @dfn{bitwise-logical} operations on fixnums.

@deffn {procedure+} fix:not fixnum
This returns the bitwise-logical inverse of its argument.  When
compiled, it does not check the type of its argument.

@example
@group
(fix:not 0)                             @result{}  -1
(fix:not -1)                            @result{}  0
(fix:not 1)                             @result{}  -2
(fix:not -34)                           @result{}  33
@end group
@end example
@end deffn

@deffn {procedure+} fix:and fixnum fixnum
This returns the bitwise-logical ``and'' of its arguments.  When
compiled, it does not check the types of its arguments.

@example
@group
(fix:and #x43 #x0f)                     @result{}  3
(fix:and #x43 #xf0)                     @result{}  #x40
@end group
@end example
@end deffn

@deffn {procedure+} fix:andc fixnum fixnum
Returns the bitwise-logical ``and'' of the first argument with the
bitwise-logical inverse of the second argument.  When compiled, it does
not check the types of its arguments.

@example
@group
(fix:andc #x43 #x0f)                    @result{}  #x40
(fix:andc #x43 #xf0)                    @result{}  3
@end group
@end example
@end deffn

@deffn {procedure+} fix:or fixnum fixnum
This returns the bitwise-logical ``inclusive or'' of its arguments.
When compiled, it does not check the types of its arguments.

@example
@group
(fix:or #x40 3)                         @result{} #x43
(fix:or #x41 3)                         @result{} #x43
@end group
@end example
@end deffn

@deffn {procedure+} fix:xor fixnum fixnum
This returns the bitwise-logical ``exclusive or'' of its arguments.
When compiled, it does not check the types of its arguments.

@example
@group
(fix:xor #x40 3)                        @result{} #x43
(fix:xor #x41 3)                        @result{} #x42
@end group
@end example
@end deffn

@deffn {procedure+} fix:lsh fixnum1 fixnum2
This procedure returns the result of logically shifting @var{fixnum1} by
@var{fixnum2} bits.  If @var{fixnum2} is positive, @var{fixnum1} is
shifted left; if negative, it is shifted right.  When compiled, it does
not check the types of its arguments, nor the validity of its result.

@example
@group
(fix:lsh 1 10)                          @result{}  #x400
(fix:lsh #x432 -10)                     @result{}  1
(fix:lsh -1 3)                          @result{}  -8
(fix:lsh -128 -4)                       @result{}  #x3FFFF8
@end group
@end example
@end deffn

@node Flonum Operations,  , Fixnum Operations, Fixnum and Flonum Operations
@subsection Flonum Operations

@cindex flonum (defn)
A @dfn{flonum} is an inexact real number that is implemented as a
floating-point number.  In MIT Scheme, all inexact real numbers are
flonums.  For this reason, constants such as @code{0.} and @code{2.3}
are guaranteed to be flonums.

@deffn {procedure+} flo:flonum? object
@cindex type predicate, for flonum
Returns @code{#t} if @var{object} is a flonum; otherwise returns @code{#f}.
@end deffn

@deffn {procedure+} flo:= flonum1 flonum2
@deffnx {procedure+} flo:< flonum1 flonum2
@deffnx {procedure+} flo:> flonum1 flonum2
@cindex equivalence predicate, for flonums
These procedures are the standard order and equality predicates on
flonums.  When compiled, they do not check the types of their arguments.
@end deffn

@deffn {procedure+} flo:zero? flonum
@deffnx {procedure+} flo:positive? flonum
@deffnx {procedure+} flo:negative? flonum
Each of these procedures compares its argument to zero.  When compiled,
they do not check the type of their argument.
@end deffn

@deffn {procedure+} flo:+ flonum1 flonum2
@deffnx {procedure+} flo:- flonum1 flonum2
@deffnx {procedure+} flo:* flonum1 flonum2
@deffnx {procedure+} flo:/ flonum1 flonum2
These procedures are the standard arithmetic operations on flonums.
When compiled, they do not check the types of their arguments.
@end deffn

@deffn {procedure+} flo:negate flonum
This procedure returns the negation of its argument.  When compiled, it
does not check the type of its argument.  Equivalent to @code{(flo:- 0.
@var{flonum})}.
@end deffn

@deffn {procedure+} flo:abs flonum
@deffnx {procedure+} flo:exp flonum
@deffnx {procedure+} flo:log flonum
@deffnx {procedure+} flo:sin flonum
@deffnx {procedure+} flo:cos flonum
@deffnx {procedure+} flo:tan flonum
@deffnx {procedure+} flo:asin flonum
@deffnx {procedure+} flo:acos flonum
@deffnx {procedure+} flo:atan flonum
@deffnx {procedure+} flo:sqrt flonum
@deffnx {procedure+} flo:expt flonum1 flonum2
@deffnx {procedure+} flo:floor flonum
@deffnx {procedure+} flo:ceiling flonum
@deffnx {procedure+} flo:truncate flonum
@deffnx {procedure+} flo:round flonum
@deffnx {procedure+} flo:floor->exact flonum
@deffnx {procedure+} flo:ceiling->exact flonum
@deffnx {procedure+} flo:truncate->exact flonum
@deffnx {procedure+} flo:round->exact flonum
These procedures are flonum versions of the corresponding procedures.
When compiled, they do not check the types of their arguments.
@end deffn

@deffn {procedure+} flo:atan2 flonum1 flonum2
@findex atan
This is the flonum version of @code{atan} with two arguments.  When
compiled, it does not check the types of its arguments.
@end deffn

@node Random Numbers,  , Fixnum and Flonum Operations, Numbers
@section Random Numbers
@cindex random number
@cindex pseudo-random number
@cindex number, pseudo-random

MIT Scheme provides a facility for generating pseudo-random numbers.
The current implementation is a ``subtract-with-carry'' random-number
generator, based on the algorithm from @cite{A New Class of Random
Number Generators}, George Marsaglia and Arif Zaman, @cite{The Annals of
Applied Probability}, Vol.@: 1, No.@: 3, 1991.  At the time it was
implemented, this was a good algorithm for general purposes, but the
state of the art in random-number generation is constantly changing.  If
necessary, the implementation will be updated to use a new algorithm
while retaining the same interface.

The interface described here is essentially identical to that of Common
Lisp.

@deffn {procedure+} random modulus [state]
@var{Modulus} must be a positive real number.  @code{random} returns a
pseudo-random number between zero (inclusive) and @var{modulus}
(exclusive).  The exactness of the returned number is the same as the
exactness of @var{modulus}.  Additionally, if @var{modulus} is an exact
integer, the returned number will be also.  Usually, @var{modulus} is
either an exact integer or an inexact real; the current implementation
has been tuned to make these two cases fast.

If @var{state} is given and not @code{#f}, it must be a random-state
object; otherwise, it defaults to the value of the variable
@code{*random-state*}.  This object is used to maintain the state of the
pseudo-random-number generator and is altered as a side effect of the
@code{random} procedure.

@example
@group
(random 1.0)    @result{} .32744744667719056
(random 1.0)    @result{} .01668326768172354
(random 10)     @result{} 3
(random 10)     @result{} 8
(random 100)    @result{} 38
(random 100)    @result{} 63
(random 100/3)  @result{} 130501475769920525/6755399441055744
(random 100/3)  @result{} 170571694016427575/13510798882111488
@end group
@end example
@end deffn

@defvr {variable+} *random-state*
This variable holds a data structure, a random-state object, that
encodes the internal state of the random-number generator that
@code{random} uses by default.  A call to @code{random} will perform a
side effect on this data structure.  This variable may be changed, using
@code{set!} or @code{fluid-let}, to hold a new random-state object.
@end defvr

@deffn {procedure+} make-random-state [state]
This procedure returns a new random-state object, suitable for use as
the value of the variable @code{*random-state*}, or as the @var{state}
argument to @code{random}.  If @var{state} is not given or @code{#f},
@code{make-random-state} returns a @emph{copy} of the current
random-number state object (the value of the variable
@code{*random-state*}).  If @var{state} is a random-state object, a copy
of that object is returned.  If @var{state} is @code{#t}, then a new
random-state object is returned that has been ``randomly'' initialized
by some means (such as by a time-of-day clock).
@end deffn

@deffn {procedure+} random-state? object
Returns @code{#t} if @var{object} is a random-state object, otherwise
returns @code{#f}.
@end deffn

@node Characters, Strings, Numbers, Top
@chapter Characters

@cindex character (defn)
Characters are objects that represent printed characters, such as
letters and digits.@footnote{Some of the details in this section depend
on the fact that the underlying operating system uses the @sc{ascii}
character set.  This may change when someone ports MIT Scheme to a
non-@sc{ascii} operating system.}

@menu
* External Representation of Characters::  
* Comparison of Characters::    
* Miscellaneous Character Operations::  
* Internal Representation of Characters::  
* ASCII Characters::            
* Character Sets::              
@end menu

@node External Representation of Characters, Comparison of Characters,  , Characters
@section External Representation of Characters
@cindex external representation, for character

@cindex #\ as external representation
@findex #\
Characters are written using the notation @code{#\@var{character}} or
@code{#\@var{character-name}}.  For example:

@example
#\a                     @r{; lowercase letter}
#\A                     @r{; uppercase letter}
#\(                     @r{; left parenthesis}
#\space                 @r{; the space character}
#\newline               @r{; the newline character}
@end example
@findex #\space
@findex #\newline

@noindent
Case is significant in @code{#\@var{character}}, but not in
@code{#\@var{character-name}}.  If @var{character} in
@code{#\@var{character}} is a letter, @var{character} must be followed
by a delimiter character such as a space or parenthesis.  Characters
written in the @code{#\} notation are self-evaluating; you don't need to
quote them.

@cindex bucky bit, prefix (defn)
@cindex control, bucky bit prefix (defn)
@cindex meta, bucky bit prefix (defn)
@cindex super, bucky bit prefix (defn)
@cindex hyper, bucky bit prefix (defn)
@cindex top, bucky bit prefix (defn)
A character name may include one or more @dfn{bucky bit} prefixes to
indicate that the character includes one or more of the keyboard shift
keys Control, Meta, Super, Hyper, or Top (note that the Control bucky
bit prefix is not the same as the @sc{ascii} control key).  The bucky
bit prefixes and their meanings are as follows (case is not
significant):

@example
@group
Key             Bucky bit prefix        Bucky bit
---             ----------------        ---------

Meta            M- or Meta-                 1
Control         C- or Control-              2
Super           S- or Super-                4
Hyper           H- or Hyper-                8
Top             T- or Top-                 16
@end group
@end example

@noindent
For example,

@example
@group
#\c-a                   @r{; Control-a}
#\meta-b                @r{; Meta-b}
#\c-s-m-h-a             @r{; Control-Meta-Super-Hyper-A}
@end group
@end example

@cindex character, named (defn)
@cindex name, of character
The following @var{character-name}s are supported, shown here with their
@sc{ascii} equivalents:

@example
@group
Character Name          ASCII Name
--------------          ----------

altmode                 ESC
backnext                US
backspace               BS
call                    SUB
linefeed                LF
page                    FF
return                  CR
rubout                  DEL
space
tab                     HT
@end group
@end example
@findex #\altmode
@findex #\backnext
@findex #\backspace
@findex #\call
@findex #\linefeed
@findex #\page
@findex #\return
@findex #\rubout
@findex #\space
@findex #\tab

@noindent
@cindex newline character (defn)
@findex #\newline
In addition, @code{#\newline} is either @code{#\linefeed} or
@code{#\return}, depending on the operating system that Scheme is
running under.  All of the standard @sc{ascii} names for non-printing
characters are supported:

@example
@group
NUL     SOH     STX     ETX     EOT     ENQ     ACK     BEL
BS      HT      LF      VT      FF      CR      SO      SI
DLE     DC1     DC2     DC3     DC4     NAK     SYN     ETB
CAN     EM      SUB     ESC     FS      GS      RS      US
DEL
@end group
@end example

@deffn {procedure+} char->name char [slashify?]
Returns a string corresponding to the printed representation of
@var{char}.  This is the @var{character} or @var{character-name}
component of the external representation, combined with the appropriate
bucky bit prefixes.

@example
(char->name #\a)                        @result{}  "a"
(char->name #\space)                    @result{}  "Space"
(char->name #\c-a)                      @result{}  "C-a"
(char->name #\control-a)                @result{}  "C-a"
@end example

@findex read
@var{Slashify?}, if specified and true, says to insert the necessary
backslash characters in the result so that @code{read} will parse it
correctly.  In other words, the following generates the external
representation of @var{char}:

@example
(string-append "#\\" (char->name @var{char} #t))
@end example

@noindent
If @var{slashify?} is not specified, it defaults to @code{#f}.
@end deffn

@deffn {procedure+} name->char string
Converts a string that names a character into the character specified.
If @var{string} does not name any character, @code{name->char} signals
an error.

@example
(name->char "a")                        @result{}  #\a
(name->char "space")                    @result{}  #\Space
(name->char "c-a")                      @result{}  #\C-a
(name->char "control-a")                @result{}  #\C-a
@end example
@end deffn

@node Comparison of Characters, Miscellaneous Character Operations, External Representation of Characters, Characters
@section Comparison of Characters
@cindex ordering, of characters
@cindex comparison, of characters
@cindex equivalence predicates, for characters

@deffn procedure char=? char1 char2
@deffnx procedure char<? char1 char2
@deffnx procedure char>? char1 char2
@deffnx procedure char<=? char1 char2
@deffnx procedure char>=? char1 char2
@deffnx {procedure} char-ci=? char1 char2
@deffnx {procedure} char-ci<? char1 char2
@deffnx {procedure} char-ci>? char1 char2
@deffnx {procedure} char-ci<=? char1 char2
@deffnx {procedure} char-ci>=? char1 char2
@cindex equivalence predicate, for characters
Returns @code{#t} if the specified characters are have the appropriate
order relationship to one another; otherwise returns @code{#f}.  The
@code{-ci} procedures don't distinguish uppercase and lowercase letters.

Character ordering follows these rules:

@itemize @bullet
@item
The digits are in order; for example, @code{(char<? #\0 #\9)} returns
@code{#t}.

@item
The uppercase characters are in order; for example, @code{(char<? #\A
#\B)} returns @code{#t}.

@item
The lowercase characters are in order; for example, @code{(char<? #\a
#\b)} returns @code{#t}.
@end itemize

@cindex standard character
@cindex character, standard
@findex char-standard?
In addition, MIT Scheme orders those characters that satisfy
@code{char-standard?} the same way that @sc{ascii} does.  Specifically,
all the digits precede all the uppercase letters, and all the upper-case
letters precede all the lowercase letters.

Characters are ordered by first comparing their bucky bits part and then
their code part.  In particular, characters without bucky bits come
before characters with bucky bits.
@end deffn

@node Miscellaneous Character Operations, Internal Representation of Characters, Comparison of Characters, Characters
@section Miscellaneous Character Operations

@deffn procedure char? object
@cindex type predicate, for character
Returns @code{#t} if @var{object} is a character; otherwise returns
@code{#f}.
@end deffn

@deffn procedure char-upcase char
@deffnx procedure char-downcase char
@cindex uppercase, character conversion
@cindex lowercase, character conversion
@cindex case conversion, of character
@findex char-ci=?
Returns the uppercase or lowercase equivalent of @var{char} if
@var{char} is a letter; otherwise returns @var{char}.  These procedures
return a character @var{char2} such that @code{(char-ci=? @var{char}
@var{char2})}.
@end deffn

@deffn {procedure+} char->digit char [radix]
If @var{char} is a character representing a digit in the given
@var{radix}, returns the corresponding integer value.  If you specify
@var{radix} (which must be an exact integer between 2 and 36 inclusive),
the conversion is done in that base, otherwise it is done in base 10.
If @var{char} doesn't represent a digit in base @var{radix},
@code{char->digit} returns @code{#f}.

Note that this procedure is insensitive to the alphabetic case of
@var{char}.

@example
@group
(char->digit #\8)                       @result{}  8
(char->digit #\e 16)                    @result{}  14
(char->digit #\e)                       @result{}  #f
@end group
@end example
@end deffn

@deffn {procedure+} digit->char digit [radix]
Returns a character that represents @var{digit} in the radix given by
@var{radix}.  @var{Radix} must be an exact integer between 2 and 36
(inclusive), and defaults to 10.  @var{Digit}, which must be an
exact non-negative integer, should be less than @var{radix}; if
@var{digit} is greater than or equal to @var{radix}, @code{digit->char}
returns @code{#f}.

@example
@group
(digit->char 8)                         @result{}  #\8
(digit->char 14 16)                     @result{}  #\E
@end group
@end example
@end deffn

@node Internal Representation of Characters, ASCII Characters, Miscellaneous Character Operations, Characters
@section Internal Representation of Characters
@cindex internal representation, for character

@cindex character code (defn)
@cindex character bits (defn)
@cindex code, of character (defn)
@cindex bucky bit, of character (defn)
@cindex ASCII character
An MIT Scheme character consists of a @dfn{code} part and a @dfn{bucky
bits} part.  The MIT Scheme set of characters can represent more
characters than @sc{ascii} can; it includes characters with Super,
Hyper, and Top bucky bits, as well as Control and Meta.  Every
@sc{ascii} character corresponds to some MIT Scheme character, but not
vice versa.@footnote{Note that the Control bucky bit is different from
the @sc{ascii} control key.  This means that @code{#\SOH} (@sc{ascii}
ctrl-A) is different from @code{#\C-A}.  In fact, the Control bucky bit
is completely orthogonal to the @sc{ascii} control key, making possible
such characters as @code{#\C-SOH}.}

MIT Scheme uses a 7-bit @sc{ascii} character code with 5 bucky
bits.  The least significant bucky bit, Meta, is stored adjacent to the
MSB of the character code, allowing the least significant 8 bits of a
character object to be interpreted as ordinary @sc{ascii} with a meta
bit.  This is compatible with standard practice for 8-bit characters
when meta bits are employed.

@deffn {procedure+} make-char code bucky-bits
@cindex construction, of character
Builds a character from @var{code} and @var{bucky-bits}.  Both
@var{code} and @var{bucky-bits} must be exact non-negative integers in
the appropriate range.  Use @code{char-code} and @code{char-bits} to
extract the code and bucky bits from the character.  If @code{0} is
specified for @var{bucky-bits}, @code{make-char} produces an ordinary
character; otherwise, the appropriate bits are turned on as follows:

@example
@group
1               Meta
2               Control
4               Super
8               Hyper
16              Top
@end group
@end example

For example,

@example
@group
(make-char 97 0)                        @result{}  #\a
(make-char 97 1)                        @result{}  #\M-a
(make-char 97 2)                        @result{}  #\C-a
(make-char 97 3)                        @result{}  #\C-M-a
@end group
@end example
@end deffn

@deffn {procedure+} char-bits char
@cindex selection, of character component
@cindex component selection, of character
Returns the exact integer representation of @var{char}'s bucky bits.
For example,

@example
(char-bits #\a)                         @result{}  0
(char-bits #\m-a)                       @result{}  1
(char-bits #\c-a)                       @result{}  2
(char-bits #\c-m-a)                     @result{}  3
@end example
@end deffn

@deffn {procedure+} char-code char
Returns the character code of @var{char}, an exact integer.  For
example,

@example
(char-code #\a)                         @result{}  97
(char-code #\c-a)                       @result{}  97
@end example
@end deffn

@defvr {variable+} char-code-limit
@defvrx {variable+} char-bits-limit
These variables define the (exclusive) upper limits for the character
code and bucky bits (respectively).  The character code and bucky bits
are always exact non-negative integers, and are strictly less than the
value of their respective limit variable.
@end defvr

@deffn procedure char->integer char
@deffnx procedure integer->char k
@code{char->integer} returns the character code representation for
@var{char}.  @code{integer->char} returns the character whose character
code representation is @var{k}.

@findex char-ascii?
@findex char->ascii
In MIT Scheme, if @code{(char-ascii? @var{char})} is true, then

@example
(eqv? (char->ascii @var{char}) (char->integer @var{char}))
@end example

@noindent
However, this behavior is not required by the Scheme standard, and
code that depends on it is not portable to other implementations.

@findex char<=?
@findex <=
These procedures implement order isomorphisms between the set of
characters under the @code{char<=?} ordering and some subset of the
integers under the @code{<=} ordering.  That is, if

@example
(char<=? a b)  @result{}  #t    @r{and}    (<= x y)  @result{}  #t
@end example

and @code{x} and @code{y} are in the range of @code{char->integer},
then

@example
@group
(<= (char->integer a)
    (char->integer b))                  @result{}  #t
(char<=? (integer->char x)
         (integer->char y))             @result{}  #t
@end group
@end example
@end deffn

@defvr {variable+} char-integer-limit
The range of @code{char->integer} is defined to be the exact
non-negative integers that are less than the value of this variable
(exclusive).
@end defvr

@node ASCII Characters, Character Sets, Internal Representation of Characters, Characters
@section ASCII Characters

MIT Scheme internally uses @sc{ascii} codes for @sc{i/o}, and stores
character objects in a fashion that makes it convenient to convert
between @sc{ascii} codes and characters.  Also, character strings are
implemented as byte vectors whose elements are @sc{ascii} codes; these
codes are converted to character objects when accessed.  For these
reasons it is sometimes desirable to be able to convert between
@sc{ascii} codes and characters.

@cindex ASCII character (defn)
@cindex character, ASCII (defn)
Not all characters can be represented as @sc{ascii} codes.  A character
that has an equivalent @sc{ascii} representation is called an @dfn{ASCII
character}.

@deffn {procedure+} char-ascii? char
Returns the @sc{ascii} code for @var{char} if @var{char} has an
@sc{ascii} representation; otherwise returns @code{#f}.

@findex char-bits
In the current implementation, the characters that satisfy this
predicate are those in which the Control, Super, Hyper, and Top bucky
bits are turned off.  All characters for which the @code{char-bits}
procedure returns @code{0} or @code{1} (i.e.@: no bucky bits, or just
Meta) count as legal @sc{ascii} characters.
@end deffn

@deffn {procedure+} char->ascii char
Returns the @sc{ascii} code for @var{char}.  An error
@code{condition-type:bad-range-argument} is signalled if @var{char}
doesn't have an @sc{ascii} representation.
@findex condition-type:bad-range-argument
@end deffn

@deffn {procedure+} ascii->char code
@var{Code} must be the exact integer representation of an @sc{ascii}
code.  This procedure returns the character corresponding to @var{code}.
@end deffn

@node Character Sets,  , ASCII Characters, Characters
@section Character Sets
@cindex character set
@cindex set, of characters

MIT Scheme's character-set abstraction is used to represent groups
of characters, such as the letters or digits.  Character sets may
contain only @sc{ascii} characters; in the future this may be changed to
allow the full range of characters.

There is no meaningful external representation for character sets; use
@code{char-set-members} to examine their contents.  There is (at
present) no specific equivalence predicate for character sets; use
@code{equal?} for this purpose.

@deffn {procedure+} char-set? object
@cindex type predicate, for character set
Returns @code{#t} if @var{object} is a character set; otherwise returns
@code{#f}.@footnote{Because character sets are implemented as strings,
@code{string?} returns @code{#t} for character set objects.  However,
string operations aren't meaningful with character sets.}
@end deffn

@defvr {variable+} char-set:upper-case
@defvrx {variable+} char-set:lower-case
@defvrx {variable+} char-set:alphabetic
@defvrx {variable+} char-set:numeric
@defvrx {variable+} char-set:alphanumeric
@defvrx {variable+} char-set:whitespace
@defvrx {variable+} char-set:not-whitespace
@defvrx {variable+} char-set:graphic
@defvrx {variable+} char-set:not-graphic
@defvrx {variable+} char-set:standard
These variables contain predefined character sets.
To see the contents of one of these sets, use @code{char-set-members}.

@cindex alphabetic character (defn)
@cindex character, alphabetic (defn)
@cindex numeric character (defn)
@cindex character, numeric (defn)
@cindex alphanumeric character (defn)
@cindex character, alphanumeric (defn)
@cindex whitespace character (defn)
@cindex character, whitespace (defn)
@cindex graphic character (defn)
@cindex character, graphic (defn)
@cindex standard character (defn)
@cindex character, standard (defn)
@findex #\space
@findex #\tab
@findex #\page
@findex #\linefeed
@findex #\return
@findex #\newline
@dfn{Alphabetic} characters are the 52 upper and lower case letters.
@dfn{Numeric} characters are the 10 decimal digits.  @dfn{Alphanumeric}
characters are those in the union of these two sets.  @dfn{Whitespace}
characters are @code{#\space}, @code{#\tab}, @code{#\page},
@code{#\linefeed}, and @code{#\return}.  @var{Graphic} characters are
the printing characters and @code{#\space}.  @var{Standard} characters
are the printing characters, @code{#\space}, and @code{#\newline}.
These are the printing characters:

@example
@group
! " # $ % & ' ( ) * + , - . /
0 1 2 3 4 5 6 7 8 9
: ; < = > ? @@
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
[ \ ] ^ _ `
a b c d e f g h i j k l m n o p q r s t u v w x y z
@{ | @} ~
@end group
@end example
@end defvr

@deffn {procedure} char-upper-case? char
@deffnx {procedure} char-lower-case? char
@deffnx {procedure} char-alphabetic? char
@deffnx {procedure} char-numeric? char
@deffnx {procedure+} char-alphanumeric? char
@deffnx {procedure} char-whitespace? char
@deffnx {procedure+} char-graphic? char
@deffnx {procedure+} char-standard? object
These predicates are defined in terms of the respective character sets
defined above.
@end deffn

@deffn {procedure+} char-set-members char-set
Returns a newly allocated list of the characters in @var{char-set}.
@end deffn

@deffn {procedure+} char-set-member? char-set char
Returns @code{#t} if the @var{char} is in @var{char-set}; otherwise
returns @code{#f}.
@end deffn

@deffn {procedure+} char-set char @dots{}
@cindex construction, of character set
Returns a character set consisting of the specified @sc{ascii}
characters.  With no arguments, @code{char-set} returns an empty
character set.
@end deffn

@deffn {procedure+} chars->char-set chars
Returns a character set consisting of @var{chars}, which must be a list
of @sc{ascii} characters.  This is equivalent to @code{(apply char-set
@var{chars})}.
@end deffn

@deffn {procedure+} ascii-range->char-set lower upper
@var{Lower} and @var{upper} must be exact non-negative integers
representing @sc{ascii} character codes, and @var{lower} must be less
than or equal to @var{upper}.  This procedure creates and returns a new
character set consisting of the characters whose @sc{ascii} codes are
between @var{lower} (inclusive) and @var{upper} (exclusive).
@end deffn

@deffn {procedure+} predicate->char-set predicate
@var{Predicate} must be a procedure of one argument.
@code{predicate->char-set} creates and returns a character set
consisting of the @sc{ascii} characters for which @var{predicate} is
true.
@end deffn

@deffn {procedure+} char-set-difference char-set1 char-set2
Returns a character set consisting of the characters that are in
@var{char-set1} but aren't in @var{char-set2}.
@end deffn

@deffn {procedure+} char-set-intersection char-set1 char-set2
Returns a character set consisting of the characters that are in both
@var{char-set1} and @var{char-set2}.
@end deffn

@deffn {procedure+} char-set-union char-set1 char-set2
Returns a character set consisting of the characters that are in one or
both of @var{char-set1} and @var{char-set2}.
@end deffn

@deffn {procedure+} char-set-invert char-set
Returns a character set consisting of the @sc{ascii} characters that are
not in @var{char-set}.
@end deffn

@node Strings, Lists, Characters, Top
@chapter Strings

@cindex string, character (defn)
@findex char-ascii?
A @dfn{string} is a mutable sequence of characters.  In the current
implementation of MIT Scheme, the elements of a string must all
satisfy the predicate @code{char-ascii?}; if someone ports MIT
Scheme to a non-@sc{ascii} operating system this requirement will
change.

@cindex external representation, for string
@cindex " as external representation
@cindex double quote, as external representation
@cindex \ as escape character in string
@cindex backslash, as escape character in string
@cindex escape character, for string
@findex "
@findex \
A string is written as a sequence of characters enclosed within double
quotes @code{" "}.  To include a double quote inside a string, precede
the double quote with a backslash @code{\} (escape it), as in

@example
"The word \"recursion\" has many meanings."
@end example

@noindent
The printed representation of this string is

@example
The word "recursion" has many meanings.
@end example

@noindent
To include a backslash inside a string, precede it with another
backslash; for example,

@example
"Use #\\Control-q to quit."
@end example

@noindent
The printed representation of this string is

@example
Use #\Control-q to quit.
@end example

@findex \t
@findex \n
@findex \f
@findex #\tab
@findex #\newline
@findex #\page
The effect of a backslash that doesn't precede a double quote or
backslash is unspecified in standard Scheme, but MIT Scheme
specifies the effect for three other characters: @code{\t}, @code{\n},
and @code{\f}.  These escape sequences are respectively translated into
the following characters: @code{#\tab}, @code{#\newline}, and
@code{#\page}.  Finally, a backslash followed by exactly three octal
digits is translated into the character whose @sc{ascii} code is those
digits.

If a string literal is continued from one line to another, the string
will contain the newline character (@code{#\newline}) at the line break.
Standard Scheme does not specify what appears in a string literal at a
line break.

@cindex length, of string (defn)
@cindex index, of string (defn)
@cindex valid index, of string (defn)
@cindex string length (defn)
@cindex string index (defn)
The @dfn{length} of a string is the number of characters that it
contains.  This number is an exact non-negative integer that is
established when the string is created
(but @pxref{Variable-Length Strings}).
Each character in a string has an @dfn{index}, which is a
number that indicates the character's position in the string.  The index
of the first (leftmost) character in a string is 0, and the index of the
last character is one less than the length of the string.  The
@dfn{valid indexes} of a string are the exact non-negative integers less
than the length of the string.

@cindex substring (defn)
@cindex start, of substring (defn)
@cindex end, of substring (defn)
A number of the string procedures operate on substrings.  A
@dfn{substring} is a segment of a @var{string}, which is specified by
two integers @var{start} and @var{end} satisfying these relationships:

@example
0 <= @var{start} <= @var{end} <= (string-length @var{string})
@end example

@noindent
@var{Start} is the index of the first character in the substring, and
@var{end} is one greater than the index of the last character in the
substring.  Thus if @var{start} and @var{end} are equal, they refer to
an empty substring, and if @var{start} is zero and @var{end} is the
length of @var{string}, they refer to all of @var{string}.

@cindex case sensitivity, of string operations
@cindex -ci, in string procedure name
Some of the procedures that operate on strings ignore the difference
between uppercase and lowercase.  The versions that ignore case include
@samp{-ci} (for ``case insensitive'') in their names.

@menu
* Construction of Strings::     
* Selecting String Components::  
* Comparison of Strings::       
* Alphabetic Case in Strings::  
* Cutting and Pasting Strings::  
* Searching Strings::           
* Matching Strings::            
* Modification of Strings::     
* Variable-Length Strings::     
* Byte Vectors::                
@end menu

@node Construction of Strings, Selecting String Components,  , Strings
@section Construction of Strings
@cindex construction, of string

@deffn {procedure} make-string k [char]
Returns a newly allocated string of length @var{k}.  If you specify
@var{char}, all elements of the string are initialized to @var{char},
otherwise the contents of the string are unspecified.  @var{Char} must
satisfy the predicate @code{char-ascii?}.

@example
(make-string 10 #\x)              @result{}  "xxxxxxxxxx"
@end example
@end deffn

@deffn {procedure+} string char @dots{}
Returns a newly allocated string consisting of the specified characters.
The arguments must all satisfy @code{char-ascii?}.

@example
(string #\a)                                @result{}  "a"
(string #\a #\b #\c)                        @result{}  "abc"
(string #\a #\space #\b #\space #\c)        @result{}  "a b c"
(string)                                    @result{}  ""
@end example

@findex char->string
For compatibility with old code, @code{char->string} is a synonym for
this procedure.
@end deffn

@deffn procedure list->string char-list
@cindex list, converting to string
@findex string->list
@var{Char-list} must be a list of @sc{ascii} characters.
@code{list->string} returns a newly allocated string formed from the
elements of @var{char-list}.  This is equivalent to @code{(apply string
@var{char-list})}.  The inverse of this operation is
@code{string->list}.

@example
@group
(list->string '(#\a #\b))               @result{}  "ab"
(string->list "Hello")                  @result{}  (#\H #\e #\l #\l #\o)
@end group
@end example
@end deffn

@deffn {procedure} string-copy string
@cindex copying, of string
Returns a newly allocated copy of @var{string}.

Note regarding variable-length strings: the maximum length of the result
depends only on the length of @var{string}, not its maximum length.  If
you wish to copy a string and preserve its maximum length, do the
following:

@example
(define (string-copy-preserving-max-length string)
  (let ((length))
    (dynamic-wind 
     (lambda ()
       (set! length (string-length string))
       (set-string-length! string (string-maximum-length string)))
     (lambda ()
       (string-copy string))
     (lambda ()
       (set-string-length! string length)))))
@end example
@end deffn

@node Selecting String Components, Comparison of Strings, Construction of Strings, Strings
@section Selecting String Components
@cindex selection, of string component
@cindex component selection, of string

@deffn procedure string? object
@cindex type predicate, for string
Returns @code{#t} if @var{object} is a string; otherwise returns
@code{#f}.

@example
@group
(string? "Hi")                  @result{}  #t
(string? 'Hi)                   @result{}  #f
@end group
@end example
@end deffn

@deffn procedure string-length string
Returns the length of @var{string} as an exact non-negative integer.

@example
@group
(string-length "")              @result{}  0
(string-length "The length")    @result{}  10
@end group
@end example
@end deffn

@deffn procedure string-null? string
@cindex empty string, predicate for
@cindex null string, predicate for
Returns @code{#t} if @var{string} has zero length; otherwise returns
@code{#f}.

@example
@group
(string-null? "")               @result{}  #t
(string-null? "Hi")             @result{}  #f
@end group
@end example
@end deffn

@deffn procedure string-ref string k
Returns character @var{k} of @var{string}.  @var{K} must be a valid index
of @var{string}.

@example
@group
(string-ref "Hello" 1)          @result{}  #\e
(string-ref "Hello" 5)          @error{} 5 not in correct range
@end group
@end example
@end deffn

@deffn {procedure} string-set! string k char
Stores @var{char} in element @var{k} of @var{string} and returns an
unspecified value.  @var{K} must be a valid index of @var{string}, and
@var{char} must satisfy the predicate @code{char-ascii?}.

@example
@group
(define str "Dog")              @result{}  @r{unspecified}
(string-set! str 0 #\L)         @result{}  @r{unspecified}
str                             @result{}  "Log"
(string-set! str 3 #\t)         @error{} 3 not in correct range
@end group
@end example
@end deffn

@need 1000
@node Comparison of Strings, Alphabetic Case in Strings, Selecting String Components, Strings
@section Comparison of Strings
@cindex ordering, of strings
@cindex comparison, of strings

@deffn procedure string=? string1 string2
@deffnx {procedure+} substring=? string1 start end string2 start end
@deffnx {procedure} string-ci=? string1 string2
@deffnx {procedure+} substring-ci=? string1 start end string2 start end
@cindex equivalence predicate, for strings
Returns @code{#t} if the two strings (substrings) are the same length
and contain the same characters in the same (relative) positions;
otherwise returns @code{#f}.  @code{string-ci=?} and
@code{substring-ci=?} don't distinguish uppercase and lowercase letters,
but @code{string=?} and @code{substring=?} do.

@example
@group
(string=? "PIE" "PIE")                  @result{}  #t
(string=? "PIE" "pie")                  @result{}  #f
(string-ci=? "PIE" "pie")               @result{}  #t
(substring=? "Alamo" 1 3 "cola" 2 4)    @result{}  #t @r{; compares "la"}
@end group
@end example
@end deffn

@deffn procedure string<? string1 string2
@deffnx {procedure+} substring<? string1 start1 end1 string2 start2 end2
@deffnx procedure string>? string1 string2
@deffnx procedure string<=? string1 string2
@deffnx procedure string>=? string1 string2
@deffnx {procedure} string-ci<? string1 string2
@deffnx {procedure+} substring-ci<? string1 start1 end1 string2 start2 end2
@deffnx {procedure} string-ci>? string1 string2
@deffnx {procedure} string-ci<=? string1 string2
@deffnx {procedure} string-ci>=? string1 string2
These procedures compare strings (substrings) according to the order of
the characters they contain (also @pxref{Comparison of Characters}).
The arguments are compared using a lexicographic (or dictionary) order.
If two strings differ in length but are the same up to the length of the
shorter string, the shorter string is considered to be less than the
longer string.

@example
@group
(string<? "cat" "dog")          @result{}  #t
(string<? "cat" "DOG")          @result{}  #f
(string-ci<? "cat" "DOG")       @result{}  #t
(string>? "catkin" "cat")       @result{}  #t @r{; shorter is lesser}
@end group
@end example
@end deffn

@deffn {procedure+} string-compare string1 string2 if-eq if-lt if-gt
@deffnx {procedure+} string-compare-ci string1 string2 if-eq if-lt if-gt
@var{If-eq}, @var{if-lt}, and @var{if-gt} are procedures of no arguments
(thunks).  The two strings are compared; if they are equal, @var{if-eq}
is applied, if @var{string1} is less than @var{string2}, @var{if-lt} is
applied, else if @var{string1} is greater than @var{string2},
@var{if-gt} is applied.  The value of the procedure is the value of the
thunk that is applied.

@code{string-compare} distinguishes uppercase and lowercase letters;
@code{string-compare-ci} does not.

@example
@group
(define (cheer) (display "Hooray!"))
(define (boo)   (display "Boo-hiss!"))
(string-compare "a" "b"  cheer  (lambda() 'ignore)  boo)
        @print{}  Hooray!
        @result{}  @r{unspecified}
@end group
@end example
@end deffn

@deffn {procedure+} string-hash string
@deffnx {procedure+} string-hash-mod string k
@cindex hashing, of string
@findex string=?
@findex =
@code{string-hash} returns an exact non-negative integer that can be used
for storing the specified @var{string} in a hash table.  Equal strings
(in the sense of @code{string=?}) return equal (@code{=}) hash codes,
and non-equal but similar strings are usually mapped to distinct hash
codes.

@code{string-hash-mod} is like @code{string-hash}, except that it limits
the result to a particular range based on the exact non-negative integer
@var{k}.  The following are equivalent:

@example
@group
(string-hash-mod @var{string} @var{k})
(modulo (string-hash @var{string}) @var{k})
@end group
@end example
@end deffn

@node Alphabetic Case in Strings, Cutting and Pasting Strings, Comparison of Strings, Strings
@section Alphabetic Case in Strings
@cindex alphabetic case, of string
@cindex case, of string
@cindex capitalization, of string
@cindex uppercase, in string
@cindex lowercase, in string

@deffn {procedure+} string-capitalized? string
@deffnx {procedure+} substring-capitalized? string start end
These procedures return @code{#t} if the first word in the string
(substring) is capitalized, and any subsequent words are either lower
case or capitalized.  Otherwise, they return @code{#f}.  A word is
defined as a non-null contiguous sequence of alphabetic characters,
delimited by non-alphabetic characters or the limits of the string
(substring).  A word is capitalized if its first letter is upper case
and all its remaining letters are lower case.

@example
@group
(map string-capitalized? '(""    "A"    "art"  "Art"  "ART"))
                       @result{} (#f    #t     #f     #t     #f)
@end group
@end example
@end deffn

@deffn {procedure+} string-upper-case? string
@deffnx {procedure+} substring-upper-case? string start end
@deffnx {procedure+} string-lower-case? string
@deffnx {procedure+} substring-lower-case? string start end
These procedures return @code{#t} if all the letters in the string
(substring) are of the correct case, otherwise they return @code{#f}.
The string (substring) must contain at least one letter or the
procedures return @code{#f}.

@example
@group
(map string-upper-case?  '(""    "A"    "art"  "Art"  "ART"))
                       @result{} (#f    #t     #f     #f     #t)
@end group
@end example
@end deffn

@deffn {procedure+} string-capitalize string
@deffnx {procedure+} string-capitalize! string
@deffnx {procedure+} substring-capitalize! string start end
@code{string-capitalize} returns a newly allocated copy of @var{string}
in which the first alphabetic character is uppercase and the remaining
alphabetic characters are lowercase.  For example, @code{"abcDEF"}
becomes @code{"Abcdef"}.  @code{string-capitalize!} is the destructive
version of @code{string-capitalize}: it alters @var{string} and returns
an unspecified value.  @code{substring-capitalize!} destructively
capitalizes the specified part of @var{string}.
@end deffn

@deffn {procedure+} string-downcase string
@deffnx {procedure+} string-downcase! string
@deffnx {procedure+} substring-downcase! string start end
@code{string-downcase} returns a newly allocated copy of @var{string} in
which all uppercase letters are changed to lowercase.
@code{string-downcase!} is the destructive version of
@code{string-downcase}: it alters @var{string} and returns an
unspecified value.  @code{substring-downcase!} destructively changes the
case of the specified part of @var{string}.

@example
@group
(define str "ABCDEFG")          @result{}  @r{unspecified}
(substring-downcase! str 3 5)   @result{}  @r{unspecified}
str                             @result{}  "ABCdeFG"
@end group
@end example
@end deffn

@deffn {procedure+} string-upcase string
@deffnx {procedure+} string-upcase! string
@deffnx {procedure+} substring-upcase! string start end
@code{string-upcase} returns a newly allocated copy of @var{string} in
which all lowercase letters are changed to uppercase.
@code{string-upcase!} is the destructive version of
@code{string-upcase}: it alters @var{string} and returns an unspecified
value.  @code{substring-upcase!} destructively changes the case of the
specified part of @var{string}.
@end deffn

@node Cutting and Pasting Strings, Searching Strings, Alphabetic Case in Strings, Strings
@section Cutting and Pasting Strings
@cindex cutting, of string
@cindex pasting, of strings

@deffn {procedure} string-append string @dots{}
@cindex appending, of strings
Returns a newly allocated string made from the concatenation of the given
strings.  With no arguments, @code{string-append} returns the empty
string (@code{""}).

@example
@group
(string-append)                         @result{}  ""
(string-append "*" "ace" "*")           @result{}  "*ace*"
(string-append "" "" "")                @result{}  ""
(eq? str (string-append str))           @result{}  #f @r{; newly allocated}
@end group
@end example
@end deffn

@deffn procedure substring string start end
Returns a newly allocated string formed from the characters of
@var{string} beginning with index @var{start} (inclusive) and ending
with @var{end} (exclusive).

@example
@group
(substring "" 0 0)              @result{} ""
(substring "arduous" 2 5)       @result{} "duo"
(substring "arduous" 2 8)       @error{} 8 not in correct range

(define (string-copy s)
  (substring s 0 (string-length s)))
@end group
@end example
@end deffn

@deffn {procedure+} string-head string end
Returns a newly allocated copy of the initial substring of @var{string},
up to but excluding @var{end}.  It could have been defined by:

@example
(define (string-head string end)
  (substring string 0 end))
@end example
@end deffn

@deffn {procedure+} string-tail string start
Returns a newly allocated copy of the final substring of @var{string},
starting at index @var{start} and going to the end of @var{string}.  It
could have been defined by:

@example
(define (string-tail string start)
  (substring string start (string-length string)))

(string-tail "uncommon" 2)      @result{}  "common"
@end example
@end deffn

@deffn {procedure+} string-pad-left string k [char]
@deffnx {procedure+} string-pad-right string k [char]
@cindex padding, of string
@findex #\space
These procedures return a newly allocated string created by padding
@var{string} out to length @var{k}, using @var{char}.  If @var{char} is
not given, it defaults to @code{#\space}.  If @var{k} is less than the
length of @var{string}, the resulting string is a truncated form of
@var{string}.  @code{string-pad-left} adds padding characters or
truncates from the beginning of the string (lowest indices), while
@code{string-pad-right} does so at the end of the string (highest
indices).

@example
@group
(string-pad-left "hello" 4)             @result{}  "ello"
(string-pad-left "hello" 8)             @result{}  "   hello"
(string-pad-left "hello" 8 #\*)         @result{}  "***hello"
(string-pad-right "hello" 4)            @result{}  "hell"
(string-pad-right "hello" 8)            @result{}  "hello   "
@end group
@end example
@end deffn

@deffn {procedure+} string-trim string [char-set]
@deffnx {procedure+} string-trim-left string [char-set]
@deffnx {procedure+} string-trim-right string [char-set]
@cindex trimming, of string
@findex char-set:whitespace
Returns a newly allocated string created by removing all characters that
are not in @var{char-set} from: (@code{string-trim}) both ends of
@var{string}; (@code{string-trim-left}) the beginning of @var{string};
or (@code{string-trim-right}) the end of @var{string}.  @var{Char-set}
defaults to @code{char-set:not-whitespace}.

@example
@group
(string-trim "  in the end  ")          @result{}  "in the end"
(string-trim "              ")          @result{}  ""
(string-trim "100th" char-set:numeric)  @result{}  "100"
(string-trim-left "-.-+-=-" (char-set #\+))
                                        @result{}  "+-=-"
(string-trim "but (+ x y) is" (char-set #\( #\)))
                                        @result{}  "(+ x y)"
@end group
@end example
@end deffn

@node Searching Strings, Matching Strings, Cutting and Pasting Strings, Strings
@section Searching Strings
@cindex searching, of string
@cindex character, searching string for
@cindex substring, searching string for

@deffn {procedure+} substring? pattern string
Searches @var{string} to see if it contains the substring @var{pattern}.
Returns the index of the first substring of @var{string} that is equal
to @var{pattern}; or @code{#f} if @var{string} does not contain @var{pattern}.

@example
@group
(substring? "rat" "pirate")             @result{}  2
(substring? "rat" "outrage")            @result{}  #f
(substring? "" any-string)              @result{}  0
(if (substring "moon" text)
    (process-lunar text)
    'no-moon)
@end group
@end example
@end deffn

@deffn {procedure+} string-find-next-char string char
@deffnx {procedure+} substring-find-next-char string start end char
@deffnx {procedure+} string-find-next-char-ci string char
@deffnx {procedure+} substring-find-next-char-ci string start end char
Returns the index of the first occurrence of @var{char} in the string
(substring); returns @code{#f} if @var{char} does not appear in the
string.  For the substring procedures, the index returned is relative to
the entire string, not just the substring.  The @code{-ci} procedures
don't distinguish uppercase and lowercase letters.

@example
@group
(string-find-next-char "Adam" #\A)              @result{}  0 
(substring-find-next-char "Adam" 1 4 #\A)       @result{}  #f
(substring-find-next-char-ci "Adam" 1 4 #\A)    @result{}  2 
@end group
@end example
@end deffn

@deffn {procedure+} string-find-next-char-in-set string char-set
@deffnx {procedure+} substring-find-next-char-in-set string start end char-set
Returns the index of the first character in the string (or substring)
that is also in @var{char-set}, or returns @code{#f} if none of the
characters in @var{char-set} occur in @var{string}.
For the substring procedure, only the substring is searched, but the
index returned is relative to the entire string, not just the substring.

@example
@group
(string-find-next-char-in-set my-string char-set:alphabetic)
                @result{}  @r{start position of the first word in} my-string
@r{; Can be used as a predicate:}
(if (string-find-next-char-in-set my-string (char-set #\( #\) ))
    'contains-parentheses
    'no-parentheses)
@end group
@end example
@end deffn

@deffn {procedure+} string-find-previous-char string char
@deffnx {procedure+} substring-find-previous-char string start end char
@deffnx {procedure+} string-find-previous-char-ci string char
@deffnx {procedure+} substring-find-previous-char-ci string start end char
Returns the index of the last occurrence of @var{char} in the string
(substring); returns @code{#f} if @var{char} doesn't appear in the
string.  For the substring procedures, the index returned is relative to
the entire string, not just the substring.  The @code{-ci} procedures
don't distinguish uppercase and lowercase letters.
@end deffn

@deffn {procedure+} string-find-previous-char-in-set string char-set
@deffnx {procedure+} substring-find-previous-char-in-set string start end char-set
Returns the index of the last character in the string (substring) that
is also in @var{char-set}.  For the substring procedure, the index
returned is relative to the entire string, not just the substring.
@end deffn

@node Matching Strings, Modification of Strings, Searching Strings, Strings
@section Matching Strings
@cindex matching, of strings

@deffn {procedure+} string-match-forward string1 string2
@deffnx {procedure+} substring-match-forward string1 start end string2 start end
@deffnx {procedure+} string-match-forward-ci string1 string2
@deffnx {procedure+} substring-match-forward-ci string1 start end string2 start end
Compares the two strings (substrings), starting from the beginning, and
returns the number of characters that are the same.  If the two strings
(substrings) start differently, returns 0.  The @code{-ci} procedures
don't distinguish uppercase and lowercase letters.

@example
@group
(string-match-forward "mirror" "micro") @result{}  2  @r{; matches "mi"}
(string-match-forward "a" "b")          @result{}  0  @r{; no match}
@end group
@end example
@end deffn

@deffn {procedure+} string-match-backward string1 string2
@deffnx {procedure+} substring-match-backward string1 start end string2 start end
@deffnx {procedure+} string-match-backward-ci string1 string2
@deffnx {procedure+} substring-match-backward-ci string1 start end string2 start end
Compares the two strings (substrings), starting from the end and
matching toward the front, returning the number of characters that are
the same.  If the two strings (substrings) end differently, returns 0.
The @code{-ci} procedures don't distinguish uppercase and lowercase
letters.

@example
@group
(string-match-backward-ci "BULBOUS" "fractious")
                                        @result{}  3  @r{; matches "ous"}
@end group
@end example
@end deffn

@deffn {procedure+} string-prefix? string1 string2
@deffnx {procedure+} substring-prefix? string1 start1 end1 string2 start2 end2
@deffnx {procedure+} string-prefix-ci? string1 string2
@deffnx {procedure+} substring-prefix-ci? string1 start1 end1 string2 start2 end2
@cindex prefix, of string
These procedures return @code{#t} if the first string (substring) forms
the prefix of the second; otherwise returns @code{#f}.  The @code{-ci}
procedures don't distinguish uppercase and lowercase letters.

@example
(string-prefix? "abc" "abcdef")         @result{}  #t
(string-prefix? "" any-string)          @result{}  #t
@end example
@end deffn

@deffn {procedure+} string-suffix? string1 string2
@deffnx {procedure+} substring-suffix? string1 start1 end1 string2 start2 end2
@deffnx {procedure+} string-suffix-ci? string1 string2
@deffnx {procedure+} substring-suffix-ci? string1 start1 end1 string2 start2 end2
@cindex suffix, of string
These procedures return @code{#t} if the first string (substring) forms
the suffix of the second; otherwise returns @code{#f}.  The @code{-ci}
procedures don't distinguish uppercase and lowercase letters.

@example
(string-suffix? "ous" "bulbous")        @result{}  #t
(string-suffix? "" any-string)          @result{}  #t
@end example
@end deffn

@node Modification of Strings, Variable-Length Strings, Matching Strings, Strings
@section Modification of Strings
@cindex modification, of string
@cindex replacement, of string component
@cindex filling, of string
@cindex moving, of string elements

@deffn {procedure+} string-replace string char1 char2
@deffnx {procedure+} substring-replace string start end char1 char2
@deffnx {procedure+} string-replace! string char1 char2
@deffnx {procedure+} substring-replace! string start end char1 char2
These procedures replace all occurrences of @var{char1} with @var{char2}
in the original string (substring).  @code{string-replace} and
@code{substring-replace} return a newly allocated string containing the
result.  @code{string-replace!} and @code{substring-replace!}
destructively modify @var{string} and return an unspecified value.

@example
@group
(define str "a few words")              @result{}  @r{unspecified}
(string-replace str #\space #\-)        @result{}  "a-few-words"
(substring-replace str 2 9 #\space #\-) @result{}  "a few-words"
str                                     @result{}  "a few words"
(string-replace! str #\space #\-)       @result{}  @r{unspecified}
str                                     @result{}  "a-few-words"
@end group
@end example
@end deffn

@deffn {procedure} string-fill! string char
Stores @var{char} in every element of @var{string} and returns an
unspecified value.
@end deffn

@deffn {procedure+} substring-fill! string start end char
Stores @var{char} in elements @var{start} (inclusive) to @var{end}
(exclusive) of @var{string} and returns an unspecified value.

@example
@group
(define s (make-string 10 #\space))     @result{}  @r{unspecified}
(substring-fill! s 2 8 #\*)             @result{}  @r{unspecified}
s                                       @result{}  "  ******  "
@end group
@end example
@end deffn

@deffn {procedure+} substring-move-left! string1 start1 end1 string2 start2
@deffnx {procedure+} substring-move-right! string1 start1 end1 string2 start2
@findex eqv?
Copies the characters from @var{start1} to @var{end1} of @var{string1}
into @var{string2} at the @var{start2}-th position.  The characters are
copied as follows (note that this is only important when @var{string1}
and @var{string2} are @code{eqv?}):

@table @code
@item substring-move-left!
The copy starts at the left end and moves toward the right (from smaller
indices to larger).  Thus if @var{string1} and @var{string2} are the
same, this procedure moves the characters toward the left inside the
string.

@item substring-move-right!
The copy starts at the right end and moves toward the left (from larger
indices to smaller).  Thus if @var{string1} and @var{string2} are the
same, this procedure moves the characters toward the right inside the
string.
@end table

The following example shows how these procedures can be used to build up
a string (it would have been easier to use @code{string-append}):
@example
@group
(define answer (make-string 9 #\*))             @result{}  @r{unspecified}
answer                                          @result{}  "*********"
(substring-move-left! "start" 0 5 answer 0)     @result{}  @r{unspecified}
answer                                          @result{}  "start****"
(substring-move-left! "-end" 0 4 answer 5)      @result{}  @r{unspecified}
answer                                          @result{}  "start-end"
@end group
@end example
@end deffn

@node Variable-Length Strings, Byte Vectors, Modification of Strings, Strings
@section Variable-Length Strings

@cindex length, of string
@cindex maximum length, of string (defn)
MIT Scheme allows the length of a string to be dynamically adjusted in a
limited way.  This feature works as follows.  When a new string is
allocated, by whatever method, it has a specific length.  At the time of
allocation, it is also given a @dfn{maximum length}, which is guaranteed
to be at least as large as the string's length.  (Sometimes the maximum
length will be slightly larger than the length, but it is a bad idea to
count on this.  Programs should assume that the maximum length is the
same as the length at the time of the string's allocation.)  After the
string is allocated, the operation @code{set-string-length!} can be used
to alter the string's length to any value between 0 and the string's
maximum length, inclusive.

@deffn {procedure+} string-maximum-length string
Returns the maximum length of @var{string}.  The following is
guaranteed:

@example
@group
(<= (string-length string)
    (string-maximum-length string))     @result{}  #t
@end group
@end example
@findex string-length

The maximum length of a string @emph{never} changes.
@end deffn

@deffn {procedure+} set-string-length! string k
Alters the length of @var{string} to be @var{k}, and returns an
unspecified value.  @var{K} must be less than or equal to the maximum
length of @var{string}.  @code{set-string-length!} does not change the
maximum length of @var{string}.
@end deffn

@node Byte Vectors,  , Variable-Length Strings, Strings
@section Byte Vectors
@cindex byte vector
@cindex vector, byte

@findex string-ref
MIT Scheme implements strings as packed vectors of 8-bit @sc{ascii}
bytes.  Most of the string operations, such as @code{string-ref}, coerce
these 8-bit codes into character objects.  However, some lower-level
operations are made available for use.

@deffn {procedure+} vector-8b-ref string k
Returns character @var{k} of @var{string} as an @sc{ascii} code.
@var{K} must be a valid index of @var{string}.

@example
@group
(vector-8b-ref "abcde" 2)               @result{}  99 @r{; ascii for `c'}
@end group
@end example
@end deffn

@deffn {procedure+} vector-8b-set! string k ascii
Stores @var{ascii} in element @var{k} of @var{string} and returns an
unspecified value.  @var{K} must be a valid index of @var{string}, and
@var{ascii} must be a valid @sc{ascii} code.
@end deffn

@deffn {procedure+} vector-8b-fill! string start end ascii
Stores @var{ascii} in elements @var{start} (inclusive) to @var{end}
(exclusive) of @var{string} and returns an unspecified value.
@var{Ascii} must be a valid @sc{ascii} code.
@end deffn

@deffn {procedure+} vector-8b-find-next-char string start end ascii
@deffnx {procedure+} vector-8b-find-next-char-ci string start end ascii
Returns the index of the first occurrence of @var{ascii} in the given
substring; returns @code{#f} if @var{ascii} does not appear.  The index
returned is relative to the entire string, not just the substring.
@var{Ascii} must be a valid @sc{ascii} code.

@code{vector-8b-find-next-char-ci} doesn't distinguish uppercase and
lowercase letters.
@end deffn

@deffn {procedure+} vector-8b-find-previous-char string start end ascii
@deffnx {procedure+} vector-8b-find-previous-char-ci string start end ascii
Returns the index of the last occurrence of @var{ascii} in the given
substring; returns @code{#f} if @var{ascii} does not appear.  The index
returned is relative to the entire string, not just the substring.
@var{Ascii} must be a valid @sc{ascii} code.

@code{vector-8b-find-previous-char-ci} doesn't distinguish uppercase and
lowercase letters.
@end deffn

@node Lists, Vectors, Strings, Top
@chapter Lists

@cindex pair (defn)
@cindex dotted pair (see pair)
@cindex car field, of pair (defn)
@cindex cdr field, of pair (defn)
A @dfn{pair} (sometimes called a @dfn{dotted pair}) is a data structure
with two fields called the @dfn{car} and @dfn{cdr} fields (for
historical reasons).  Pairs are created by the procedure @code{cons}.
The car and cdr fields are accessed by the procedures @code{car} and
@code{cdr}.  The car and cdr fields are assigned by the procedures
@code{set-car!} and @code{set-cdr!}.

@cindex list (defn)
Pairs are used primarily to represent @dfn{lists}.  A list can be
defined recursively as either the empty list or a pair whose cdr is
a list.  More precisely, the set of lists is defined as the smallest set
@var{X} such that

@itemize @bullet
@item
The empty list is in @var{X}.

@item
If @var{list} is in @var{X}, then any pair whose cdr field contains
@var{list} is also in @var{X}.
@end itemize

@cindex element, of list (defn)
@cindex length, of list (defn)
@cindex empty list (defn)
The objects in the car fields of successive pairs of a list are the
@dfn{elements} of the list.  For example, a two-element list is a pair
whose car is the first element and whose cdr is a pair whose car is the
second element and whose cdr is the empty list.  The @dfn{length} of a
list is the number of elements, which is the same as the number of
pairs.  The @dfn{empty list} is a special object of its own type (it is
not a pair); it has no elements and its length is zero.@footnote{The
above definitions imply that all lists have finite length and are
terminated by the empty list.}

@cindex dotted notation, for pair (defn)
@cindex notation, dotted (defn)
@cindex external representation, for pair
@cindex pair, external representation
@cindex ( as external representation
@cindex ) as external representation
@cindex . as external representation
@cindex parenthesis, as external representation
@cindex dot, as external representation
@cindex period, as external representation
@findex (
@findex )
@findex .
The most general notation (external representation) for Scheme pairs is
the ``dotted'' notation @code{(@var{c1} . @var{c2})} where @var{c1} is
the value of the car field and @var{c2} is the value of the cdr field.
For example, @code{(4 . 5)} is a pair whose car is @code{4} and whose
cdr is @code{5}.  Note that @code{(4 . 5)} is the external
representation of a pair, not an expression that evaluates to a pair.

@cindex external representation, for list
@cindex list, external representation
@cindex external representation, for empty list
@cindex empty list, external representation
@findex ()
A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces.  The
empty list is written @code{()}.  For example, the following are
equivalent notations for a list of symbols:

@example
@group
(a b c d e)
(a . (b . (c . (d . (e . ())))))
@end group
@end example

@findex set-cdr!
Whether a given pair is a list depends upon what is stored in the cdr
field.  When the @code{set-cdr!} procedure is used, an object can be a
list one moment and not the next:

@example
@group
(define x (list 'a 'b 'c))
(define y x)
y                                       @result{}  (a b c)
(list? y)                               @result{}  #t
(set-cdr! x 4)                          @result{}  @r{unspecified}
x                                       @result{}  (a . 4)
(eqv? x y)                              @result{}  #t
y                                       @result{}  (a . 4)
(list? y)                               @result{}  #f
(set-cdr! x x)                          @result{}  @r{unspecified}
(list? y)                               @result{}  #f
@end group
@end example

@cindex improper list (defn)
@cindex list, improper (defn)
A chain of pairs that doesn't end in the empty list is called an
@dfn{improper list}.  Note that an improper list is not a list.  The
list and dotted notations can be combined to represent improper lists,
as the following equivalent notations show:

@example
@group
(a b c . d)
(a . (b . (c . d)))
@end group
@end example

@findex quote
@findex quasiquote
@findex unquote
@findex unquote-splicing
@findex '
@findex `
@findex ,
@findex ,@@
@findex read
Within literal expressions and representations of objects read by the
@code{read} procedure, the forms @code{'@var{datum}},
@code{`@var{datum}}, @code{,@var{datum}}, and @code{,@@@var{datum}}
denote two-element lists whose first elements are the symbols
@code{quote}, @code{quasiquote}, @code{unquote}, and
@code{unquote-splicing}, respectively.  The second element in each case
is @var{datum}.  This convention is supported so that arbitrary Scheme
programs may be represented as lists.  Among other things, this permits
the use of the @code{read} procedure to parse Scheme programs.

@menu
* Pairs::                       
* Construction of Lists::       
* Selecting List Components::   
* Cutting and Pasting Lists::   
* Filtering Lists::             
* Searching Lists::             
* Mapping of Lists::            
* Reduction of Lists::          
* Miscellaneous List Operations::  
@end menu

@node Pairs, Construction of Lists,  , Lists
@section Pairs

This section describes the simple operations that are available for
constructing and manipulating arbitrary graphs constructed from pairs.

@deffn procedure pair? object
@cindex type predicate, for pair
Returns @code{#t} if @var{object} is a pair; otherwise returns
@code{#f}.

@example
@group
(pair? '(a . b))                        @result{}  #t
(pair? '(a b c))                        @result{}  #t
(pair? '())                             @result{}  #f
(pair? '#(a b))                         @result{}  #f
@end group
@end example
@end deffn

@deffn procedure cons obj1 obj2
@cindex construction, of pair
@findex eqv?
Returns a newly allocated pair whose car is @var{obj1} and whose cdr is
@var{obj2}.  The pair is guaranteed to be different (in the sense of
@code{eqv?}) from every previously existing object.

@example
@group
(cons 'a '())                           @result{}  (a)
(cons '(a) '(b c d))                    @result{}  ((a) b c d)
(cons "a" '(b c))                       @result{}  ("a" b c)
(cons 'a 3)                             @result{}  (a . 3)
(cons '(a b) 'c)                        @result{}  ((a b) . c)
@end group
@end example
@end deffn

@deffn procedure car pair
@cindex selection, of pair component
@cindex component selection, of pair
Returns the contents of the car field of @var{pair}.  Note that it is an
error to take the @code{car} of the empty list.

@example
@group
(car '(a b c))                          @result{}  a
(car '((a) b c d))                      @result{}  (a)
(car '(1 . 2))                          @result{}  1
(car '())                               @error{} Illegal datum
@end group
@end example
@end deffn

@deffn procedure cdr pair
Returns the contents of the cdr field of @var{pair}.  Note that it is an
error to take the @code{cdr} of the empty list.

@example
@group
(cdr '((a) b c d))                      @result{}  (b c d)
(cdr '(1 . 2))                          @result{}  2
(cdr '())                               @error{} Illegal datum
@end group
@end example
@end deffn

@deffn procedure set-car! pair object
Stores @var{object} in the car field of @var{pair}.  The value returned
by @code{set-car!} is unspecified.

@example
@group
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)                        @result{}  @r{unspecified}
(set-car! (g) 3)                        @error{} Illegal datum
@end group
@end example
@end deffn

@deffn procedure set-cdr! pair object
Stores @var{object} in the cdr field of @var{pair}.  The value returned
by @code{set-cdr!} is unspecified.
@end deffn

@deffn procedure caar pair
@deffnx procedure cadr pair
@deffnx procedure cdar pair
@deffnx procedure cddr pair
@deffnx procedure caaar pair
@deffnx procedure caadr pair
@deffnx procedure cadar pair
@deffnx procedure caddr pair
@deffnx procedure cdaar pair
@deffnx procedure cdadr pair
@deffnx procedure cddar pair
@deffnx procedure cdddr pair
@deffnx procedure caaaar pair
@deffnx procedure caaadr pair
@deffnx procedure caadar pair
@deffnx procedure caaddr pair
@deffnx procedure cadaar pair
@deffnx procedure cadadr pair
@deffnx procedure caddar pair
@deffnx procedure cadddr pair
@deffnx procedure cdaaar pair
@deffnx procedure cdaadr pair
@deffnx procedure cdadar pair
@deffnx procedure cdaddr pair
@deffnx procedure cddaar pair
@deffnx procedure cddadr pair
@deffnx procedure cdddar pair
@deffnx procedure cddddr pair
These procedures are compositions of @code{car} and @code{cdr}; for
example, @code{caddr} could be defined by

@example
(define caddr (lambda (x) (car (cdr (cdr x)))))
@end example
@end deffn

@deffn {procedure+} general-car-cdr object path
This procedure is a generalization of @code{car} and @code{cdr}.
@var{Path} encodes a particular sequence of @code{car} and @code{cdr}
operations, which @code{general-car-cdr} executes on @var{object}.
@var{Path} is an exact non-negative integer that encodes the operations
in a bitwise fashion: a zero bit represents a @code{cdr} operation, and
a one bit represents a @code{car}.  The bits are executed LSB to MSB,
and the most significant one bit, rather than being interpreted as an
operation, signals the end of the sequence.@footnote{Note that
@var{path} is restricted to a machine-dependent range, usually the size
of a machine word.  On many machines, this means that the maximum length
of @var{path} will be 30 operations (32 bits, less the sign bit and the
``end-of-sequence'' bit).}

For example, the following are equivalent:
@example
(general-car-cdr @var{object} #b1011)
(cdr (car (car @var{object})))
@end example

Here is a partial table of path/operation equivalents:

@example
@group
#b10    cdr
#b11    car
#b100   cddr
#b101   cdar
#b110   cadr
#b111   caar
#b1000  cdddr
@end group
@end example
@end deffn

@deffn {procedure+} tree-copy tree
@cindex copying, of tree
@cindex tree, copying
This copies an arbitrary @var{tree} constructed from pairs, copying both
the car and cdr elements of every pair.  This could have been defined by

@example
@group
(define (tree-copy tree)
  (let loop ((tree tree))
    (if (pair? tree)
        (cons (loop (car tree)) (loop (cdr tree)))
        tree)))
@end group
@end example
@end deffn

@node Construction of Lists, Selecting List Components, Pairs, Lists
@section Construction of Lists
@cindex construction, of list

@deffn procedure list object @dots{}
Returns a list of its arguments.

@example
@group
(list 'a (+ 3 4) 'c)                    @result{}  (a 7 c)
(list)                                  @result{}  ()
@end group
@end example

These expressions are equivalent:

@example
@group
(list @var{obj1} @var{obj2} @dots{} @var{objN})
(cons @var{obj1} (cons @var{obj2} @dots{} (cons @var{objN} '()) @dots{}))
@end group
@end example
@end deffn

@deffn {procedure+} make-list k [element]
This procedure returns a newly allocated list of length @var{k},
whose elements are all @var{element}.  If @var{element} is not supplied,
it defaults to the empty list.
@end deffn

@deffn {procedure+} cons* object object @dots{}
@findex list
@code{cons*} is similar to @code{list}, except that @code{cons*} conses
together the last two arguments rather than consing the last argument
with the empty list.  If the last argument is not a list the result is
an improper list.  If the last argument is a list, the result is a list
consisting of the initial arguments and all of the items in the final
argument.  If there is only one argument, the result is the argument.

@example
@group
(cons* 'a 'b 'c)                        @result{}  (a b . c)
(cons* 'a 'b '(c d))                    @result{}  (a b c d)
(cons* 'a)                              @result{}  a
@end group
@end example

These expressions are equivalent:

@example
@group
(cons* @var{obj1} @var{obj2} @dots{} @var{objN-1} @var{objN})
(cons @var{obj1} (cons @var{obj2} @dots{} (cons @var{objN-1} @var{objN}) @dots{}))
@end group
@end example
@end deffn

@deffn {procedure+} list-copy list
Returns a newly allocated copy of @var{list}.  This copies each of the
pairs comprising @var{list}.  This could have been defined by

@example
@group
(define (list-copy list)
  (if (null? list)
      '()
      (cons (car list)
            (list-copy (cdr list)))))
@end group
@end example
@end deffn

@deffn procedure vector->list vector
@deffnx {procedure+} subvector->list vector start end
@cindex vector, converting to list
@findex list->vector
@code{vector->list} returns a newly allocated list of the elements of
@var{vector}.  @code{subvector->list} returns a newly allocated list of the
elements of the given subvector.  The inverse of @code{vector->list} is
@code{list->vector}.

@example
(vector->list '#(dah dah didah))        @result{}  (dah dah didah)
@end example
@end deffn

@deffn {procedure} string->list string
@deffnx {procedure} substring->list string start end
@cindex string, converting to list
@findex list->string
@code{string->list} returns a newly allocated list of the character
elements of @var{string}.@*
@code{substring->list} returns a newly allocated list of the character
elements of the given substring.  The inverse of @code{string->list} is
@code{list->string}.

@example
(string->list "abcd")                   @result{}  (#\a #\b #\c #\d)
(substring->list "abcdef" 1 3)          @result{}  (#\b #\c)
@end example
@end deffn

@node Selecting List Components, Cutting and Pasting Lists, Construction of Lists, Lists
@section Selecting List Components
@cindex selection, of list component
@cindex component selection, of list

@deffn {procedure+} list? object
@cindex type predicate, for list
@cindex circular list
Returns @code{#t} if @var{object} is a list, otherwise returns
@code{#f}.  By definition, all lists have finite length and are
terminated by the empty list.  This procedure returns an answer even for
circular structures.

@findex pair?
@findex null?
Any @var{object} satisfying this predicate will also satisfy exactly one
of @code{pair?} or @code{null?}.

@example
@group
(list? '(a b c))                        @result{}  #t
(list? '())                             @result{}  #t
(list? '(a . b))                        @result{}  #f
(let ((x (list 'a)))
  (set-cdr! x x)
  (list? x))                            @result{}  #f
@end group
@end example
@end deffn

@deffn procedure length list
Returns the length of @var{list}.

@example
@group
(length '(a b c))                       @result{}  3
(length '(a (b) (c d e)))               @result{}  3
(length '())                            @result{}  0
@end group
@end example
@end deffn

@deffn procedure null? object
@cindex type predicate, for empty list
@cindex empty list, predicate for
Returns @code{#t} if @var{object} is the empty list; otherwise returns
@code{#f} (but @pxref{True and False}).

@example
@group
(null? '(a . b))                        @result{}  #f
(null? '(a b c))                        @result{}  #f
(null? '())                             @result{}  #t
@end group
@end example
@end deffn

@deffn procedure list-ref list k
@cindex index, of list (defn)
@cindex valid index, of list (defn)
@cindex list index (defn)
Returns the @var{k}th element of @var{list}, using zero-origin indexing.
The @dfn{valid indexes} of a list are the exact non-negative integers
less than the length of the list.  The first element of a list has index
@code{0}, the second has index @code{1}, and so on.

@example
(list-ref '(a b c d) 2)                 @result{}  c
(list-ref '(a b c d)
          (inexact->exact (round 1.8)))
     @result{}  c
@end example

@findex list-tail
@code{(list-ref @var{list} @var{k})} is equivalent to @code{(car
(list-tail @var{list} @var{k}))}.
@end deffn

@deffn {procedure+} first list
@deffnx {procedure+} second list
@deffnx {procedure+} third list
@deffnx {procedure+} fourth list
@deffnx {procedure+} fifth list
@deffnx {procedure+} sixth list
@deffnx {procedure+} seventh list
@deffnx {procedure+} eighth list
@deffnx {procedure+} ninth list
@deffnx {procedure+} tenth list
Returns the specified element of @var{list}.  It is an error if
@var{list} is not long enough to contain the specified element (for
example, if the argument to @code{seventh} is a list that contains only
six elements).
@end deffn

@node Cutting and Pasting Lists, Filtering Lists, Selecting List Components, Lists
@section Cutting and Pasting Lists
@cindex cutting, of list
@cindex pasting, of lists

@deffn {procedure+} sublist list start end
@var{Start} and @var{end} must be exact integers satisfying

@example
0 <= @var{start} <= @var{end} <= (length @var{list})
@end example

@code{sublist} returns a newly allocated list formed from the elements
of @var{list} beginning at index @var{start} (inclusive) and ending at
@var{end} (exclusive).
@end deffn

@deffn {procedure+} list-head list k
Returns a newly allocated list consisting of the first @var{k} elements of
@var{list}.  @var{K} must not be greater than the length of
@var{list}.

We could have defined @code{list-head} this way:

@example
@group
(define (list-head list k)
  (sublist list 0 k))
@end group
@end example
@end deffn

@deffn procedure list-tail list k
Returns the sublist of @var{list} obtained by omitting the first @var{k}
elements.  The result, if it is not the empty list, shares structure
with @var{list}.  @var{K} must not be greater than the length of
@var{list}.
@end deffn

@deffn {procedure} append list @dots{}
@cindex appending, of lists
Returns a list consisting of the elements of the first @var{list}
followed by the elements of the other @var{list}s.

@example
@group
(append '(x) '(y))                      @result{}  (x y)
(append '(a) '(b c d))                  @result{}  (a b c d)
(append '(a (b)) '((c)))                @result{}  (a (b) (c))
(append)                                @result{}  ()
@end group
@end example

The resulting list is always newly allocated, except that it shares
structure with the last @var{list} argument.  The last argument may
actually be any object; an improper list results if the last argument is
not a proper list.

@example
@group
(append '(a b) '(c . d))                @result{}  (a b c . d)
(append '() 'a)                         @result{}  a
@end group
@end example
@end deffn

@deffn {procedure+} append! list @dots{}
Returns a list that is the argument @var{list}s concatenated together.
The arguments are changed rather than copied.  (Compare this with
@code{append}, which copies arguments rather than destroying them.)  For
example:

@example
@group
(define x '(a b c))
(define y '(d e f))
(define z '(g h))
(append! x y z)                         @result{}  (a b c d e f g h)
x                                       @result{}  (a b c d e f g h)
y                                       @result{}  (d e f g h)
z                                       @result{}  (g h)
@end group
@end example
@end deffn

@node Filtering Lists, Searching Lists, Cutting and Pasting Lists, Lists
@section Filtering Lists
@cindex filtering, of list
@cindex deletion, of list element

@deffn {procedure+} list-transform-positive list predicate
@deffnx {procedure+} list-transform-negative list predicate
These procedures return a newly allocated copy of @var{list} containing
only the elements for which @var{predicate} is (respectively) true or
false.  @var{Predicate} must be a procedure of one argument.

@example
@group
(list-transform-positive '(1 2 3 4 5) odd?) @result{} (1 3 5)
(list-transform-negative '(1 2 3 4 5) odd?) @result{} (2 4)
@end group
@end example
@end deffn

@deffn {procedure+} delq element list
@deffnx {procedure+} delv element list
@deffnx {procedure+} delete element list
@findex eq?
@findex eqv?
@findex equal?
Returns a newly allocated copy of @var{list} with all entries equal to
@var{element} removed.  @code{delq} uses @code{eq?} to compare
@var{element} with the entries in @var{list}, @code{delv} uses
@code{eqv?}, and @code{delete} uses @code{equal?}.
@end deffn

@deffn {procedure+} delq! element list
@deffnx {procedure+} delv! element list
@deffnx {procedure+} delete! element list
@findex eq?
@findex eqv?
@findex equal?
Returns a list consisting of the top-level elements of @var{list} with
all entries equal to @var{element} removed.  These procedures are like
@code{delq}, @code{delv}, and @code{delete} except that they
destructively modify @var{list}.  @code{delq!} uses @code{eq?} to
compare element with the entries in @var{list}, @code{delv!} uses
@code{eqv?}, and @code{delete!} uses @code{equal?}.  Because the result
may not be @code{eq?} to @var{list}, it is desirable to do something
like @code{(set! x (delete! x))}.

@example
@group
(define x '(a b c b))
(delete 'b x)                           @result{}  (a c)
x                                       @result{}  (a b c b)

(define x '(a b c b))
(delete! 'b x)                          @result{}  (a c)
x                                       @result{}  (a c)
@r{;; Returns correct result:}
(delete! 'a x)                          @result{}  (c)

@r{;; Didn't modify what x points to:}
x                                       @result{}  (a c)
@end group
@end example
@end deffn

@deffn {procedure+} delete-member-procedure deletor predicate
@findex list-deletor
@findex list-deletor!
@findex delv
@findex delete!
Returns a deletion procedure similar to @code{delv} or @code{delete!}.
@var{Deletor} should be one of the procedures @code{list-deletor} or
@code{list-deletor!}.  @var{Predicate} must be an equivalence predicate.
The returned procedure accepts exactly two arguments: first, an object
to be deleted, and second, a list of objects from which it is to be
deleted.  If @var{deletor} is @code{list-deletor}, the procedure
returns a newly allocated copy of the given list in which all entries
equal to the given object have been removed.  If @var{deletor} is
@code{list-deletor!}, the procedure returns a list consisting of the
top-level elements of the given list with all entries equal to the given
object removed; the given list is destructively modified to produce the
result.  In either case @var{predicate} is used to compare the given
object to the elements of the given list.

Here are some examples that demonstrate how
@code{delete-member-procedure} could have been used to implement
@code{delv} and @code{delete!}:

@example
@group
(define delv (delete-member-procedure list-deletor eqv?))
(define delete! (delete-member-procedure list-deletor! equal?))
@end group
@end example
@end deffn

@deffn {procedure+} list-deletor predicate
@deffnx {procedure+} list-deletor! predicate
These procedures each return a procedure that deletes elements from
lists.  @var{Predicate} must be a procedure of one argument.  The
returned procedure accepts exactly one argument, which must be a proper
list, and applies @var{predicate} to each of the elements of the
argument, deleting those for which it is true.

The procedure returned by @code{list-deletor} deletes elements
non-destructively, by returning a newly allocated copy of the argument
with the appropriate elements removed.  The procedure returned by
@code{list-deletor!} performs a destructive deletion.
@end deffn

@node Searching Lists, Mapping of Lists, Filtering Lists, Lists
@section Searching Lists
@cindex searching, of list

@deffn {procedure+} list-search-positive list predicate
@deffnx {procedure+} list-search-negative list predicate
Returns the first element in @var{list} for which @var{predicate} is
(respectively) true or false; returns @code{#f} if it doesn't find such
an element.  (This means that if @var{predicate} is true (false) for
@code{#f}, it may be impossible to distinguish a successful result from
an unsuccessful one.)  @var{Predicate} must be a procedure of one
argument.
@end deffn

@deffn procedure memq object list
@deffnx procedure memv object list
@deffnx procedure member object list
@findex eq?
@findex eqv?
@findex equal?
These procedures return the first pair of @var{list} whose car is
@var{object}; the returned pair is always one from which @var{list} is
composed.  If @var{object} does not occur in @var{list}, @code{#f}
(n.b.: not the empty list) is returned.  @code{memq} uses @code{eq?} to
compare @var{object} with the elements of @var{list}, while @code{memv}
uses @code{eqv?} and @code{member} uses @code{equal?}.@footnote{Although
they are often used as predicates, @code{memq}, @code{memv}, and
@code{member} do not have question marks in their names because they
return useful values rather than just @code{#t} or @code{#f}.}

@example
@group
(memq 'a '(a b c))                      @result{}  (a b c)
(memq 'b '(a b c))                      @result{}  (b c)
(memq 'a '(b c d))                      @result{}  #f
(memq (list 'a) '(b (a) c))             @result{}  #f
(member (list 'a) '(b (a) c))           @result{}  ((a) c)
(memq 101 '(100 101 102))               @result{}  @r{unspecified}
(memv 101 '(100 101 102))               @result{}  (101 102)
@end group
@end example
@end deffn

@deffn {procedure+} member-procedure predicate
Returns a procedure similar to @code{memq}, except that @var{predicate},
which must be an equivalence predicate, is used instead of @code{eq?}.
This could be used to define @code{memv} as follows:

@example
(define memv (member-procedure eqv?))
@end example
@end deffn

@need 1000
@node Mapping of Lists, Reduction of Lists, Searching Lists, Lists
@section Mapping of Lists
@cindex mapping, of list

@deffn {procedure} map procedure list list @dots{}
@var{Procedure} must be a procedure taking as many arguments as there
are @var{list}s.  If more than one @var{list} is given, then they must
all be the same length.  @code{map} applies @var{procedure} element-wise
to the elements of the @var{list}s and returns a list of the results, in
order from left to right.  The dynamic order in which @var{procedure} is
applied to the elements of the @var{list}s is unspecified; use
@code{for-each} to sequence side effects.

@example
@group
(map cadr '((a b) (d e) (g h)))           @result{}  (b e h)
(map (lambda (n) (expt n n)) '(1 2 3 4))  @result{}  (1 4 27 256)
(map + '(1 2 3) '(4 5 6))                 @result{}  (5 7 9)
(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b c)))                         @result{}  @r{unspecified}
@end group
@end example
@end deffn

@deffn {procedure+} map* initial-value procedure list1 list2 @dots{}
Similar to @code{map}, except that the resulting list is terminated by
@var{initial-value} rather than the empty list.  The following are
equivalent:

@example
@group
(map @var{procedure} @var{list} @var{list} @dots{})
(map* '() @var{procedure} @var{list} @var{list} @dots{})
@end group
@end example
@end deffn

@deffn {procedure+} append-map procedure list list @dots{}
@deffnx {procedure+} append-map* initial-value procedure list list @dots{}
@findex append
Similar to @code{map} and @code{map*}, respectively, except that the
results of applying @var{procedure} to the elements of @var{list}s are
concatenated together by @code{append} rather than by @code{cons}.  The
following are equivalent, except that the former is more efficient:

@example
@group
(append-map @var{procedure} @var{list} @var{list} @dots{})
(apply append (map @var{procedure} @var{list} @var{list} @dots{}))
@end group
@end example
@end deffn

@deffn {procedure+} append-map! procedure list list @dots{}
@deffnx {procedure+} append-map*! initial-value procedure list list @dots{}
@findex append!
Similar to @code{map} and @code{map*}, respectively, except that the
results of applying @var{procedure} to the elements of @var{list}s are
concatenated together by @code{append!} rather than by @code{cons}.  The
following are equivalent, except that the former is more efficient:

@example
@group
(append-map! @var{procedure} @var{list} @var{list} @dots{})
(apply append! (map @var{procedure} @var{list} @var{list} @dots{}))
@end group
@end example
@end deffn

@deffn {procedure} for-each procedure list list @dots{}
The arguments to @code{for-each} are like the arguments to @code{map},
but @code{for-each} calls @var{procedure} for its side effects rather
than for its values.  Unlike @code{map}, @code{for-each} is guaranteed
to call @var{procedure} on the elements of the @var{list}s in order from
the first element to the last, and the value returned by @code{for-each}
is unspecified.

@example
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                            @result{}  #(0 1 4 9 16)
@end example
@end deffn

@node Reduction of Lists, Miscellaneous List Operations, Mapping of Lists, Lists
@section Reduction of Lists
@cindex reduction, of list

@deffn {procedure+} reduce procedure initial list
Combines all the elements of @var{list} using the binary operation
@var{procedure}.  For example, using @code{+} one can add up all the
elements:

@example
(reduce + 0 list-of-numbers)
@end example

The argument @var{initial} is used only if @var{list} is empty; in this
case @var{initial} is the result of the call to @code{reduce}.  If
@var{list} has a single argument, it is returned.  Otherwise, the arguments
are reduced in a left-associative fashion.  For example:

@example
@group
(reduce + 0 '(1 2 3 4))                 @result{}  10
(reduce + 0 '(1 2))                     @result{}  3
(reduce + 0 '(1))                       @result{}  1
(reduce + 0 '())                        @result{}  0
(reduce + 0 '(foo))                     @result{}  foo
(reduce list '() '(1 2 3 4))            @result{}  (((1 2) 3) 4)
@end group
@end example
@end deffn

@deffn {procedure+} reduce-right procedure initial list
Like @code{reduce} except that it is right-associative.

@example
(reduce-right list '() '(1 2 3 4))      @result{}  (1 (2 (3 4)))
@end example
@end deffn

@deffn {procedure+} fold-right procedure initial list
Combines all of the elements of @var{list} using the binary operation
@var{procedure}.  Unlike @code{reduce} and @code{reduce-right},
@var{initial} is always used:

@example
(fold-right + 0 '(1 2 3 4))             @result{}  10
(fold-right + 0 '(foo))                 @error{} Illegal datum
(fold-right list '() '(1 2 3 4))        @result{}  (1 (2 (3 (4 ()))))
@end example

@code{Fold-right} has interesting properties because it establishes a
homomorphism between (@code{cons}, @code{()}) and (@var{procedure},
@var{initial}).  It can be thought of as replacing the pairs in the
spine of the list with @var{procedure} and replacing the @code{()} at
the end with @var{initial}.  Many of the classical list processing
procedures can be expressed in terms of @code{fold-right}, at least for
the simple versions that take a fixed number of arguments:

@example
@group
(define (copy-list list)
  (fold-right cons '() list))

(define (append list1 list2)
  (fold-right cons list2 list1))

(define (map p list) 
  (fold-right (lambda (x r) (cons (p x) r)) '() list))

(define (reverse items)
  (fold-right (lambda (x r) (append r (list x))) '() items))
@end group
@end example
@end deffn

@deffn {procedure+} fold-left procedure initial list
Combines all the elements of @var{list} using the binary operation
@var{procedure}.  Elements are combined starting with @var{initial} and
then the elements of @var{list} from left to right.  Whereas
@code{fold-right} is recursive in nature, capturing the essence of
@code{cdr}-ing down a list and then computing a result, @var{fold-left}
is iterative in nature, combining the elements as the list is traversed.

@example
@group
(fold-left list '() '(1 2 3 4))         @result{}  ((((() 1) 2) 3) 4)

(define (length list)
  (fold-left 1+ 0 list))

(define (reverse items)
  (fold-left (lambda (x y) (cons y x)) () items))
@end group
@end example
@end deffn

@deffn {procedure+} there-exists? list predicate
@var{Predicate} must be a procedure of one argument.  Applies
@var{predicate} to each element of @var{list}, in order from left to
right.  If @var{predicate} is true for any element of @var{list}, the
value yielded by @var{predicate} is immediately returned as the value of
@code{there-exists?}; @var{predicate} will not be applied to the
remaining elements of @var{list}.  If @var{predicate} returns @code{#f}
for all of the elements of @var{list}, then @code{#f} is returned.
@end deffn

@deffn {procedure+} for-all? list predicate
@var{Predicate} must be a procedure of one argument.  Applies
@var{predicate} to each element of @var{list}, in order from left to
right.  If @var{predicate} returns @code{#f} for any element of
@var{list}, @code{#f} is immediately returned as the value of
@code{for-all?}; @var{predicate} will not be applied to the remaining
elements of @var{list}.  If @var{predicate} is true for all of the
elements of @var{list}, then @code{#t} is returned.
@end deffn

@node Miscellaneous List Operations,  , Reduction of Lists, Lists
@section Miscellaneous List Operations

@deffn {procedure+} circular-list object @dots{}
@deffnx {procedure+} make-circular-list k [element]
@cindex circular list
@cindex construction, of circular list
@findex list
@findex make-list
These procedures are like @code{list} and @code{make-list},
respectively, except that the returned lists are circular.
@code{circular-list} could have been defined like this:

@example
@group
(define (circular-list . objects)
  (append! objects objects))
@end group
@end example
@end deffn

@deffn procedure reverse list
@cindex reversal, of list
Returns a newly allocated list consisting of the top-level elements of
@var{list} in reverse order.

@example
@group
(reverse '(a b c))                      @result{}  (c b a)
(reverse '(a (b c) d (e (f))))          @result{}  ((e (f)) d (b c) a)
@end group
@end example
@end deffn

@deffn {procedure+} reverse! list
Returns a list consisting of the top-level elements of @var{list} in
reverse order.  @code{reverse!} is like @code{reverse}, except that it
destructively modifies @var{list}.  Because the result may not be
@code{eqv?} to @var{list}, it is desirable to do something like
@code{(set! x (reverse! x))}.
@end deffn

@deffn {procedure+} last-pair list
Returns the last pair in @var{list}, which may be an improper list.
@code{last-pair} could have been defined this way:

@example
@group
(define last-pair
  (lambda (x)
    (if (pair? (cdr x))
        (last-pair (cdr x))
        x)))
@end group
@end example
@end deffn

@deffn {procedure+} except-last-pair list
@deffnx {procedure+} except-last-pair! list
These procedures remove the last pair from @var{list}.  @var{List} may
be an improper list, except that it must consist of at least one pair.
@code{except-last-pair} returns a newly allocated copy of @var{list}
that omits the last pair.  @code{except-last-pair!} destructively
removes the last pair from @var{list} and returns @var{list}.  If the
cdr of @var{list} is not a pair, the empty list is returned by either
procedure.
@end deffn

@deffn {procedure+} sort list procedure
@cindex total ordering (defn)
@var{Procedure} must be a procedure of two arguments that defines a
@dfn{total ordering} on the elements of @var{list}.  In other words, if
@var{x} and @var{y} are two distinct elements of @var{list}, then it
must be the case that

@example
@group
(and (@var{procedure} @var{x} @var{y})
     (@var{procedure} @var{y} @var{x}))
     @result{}  #f
@end group
@end example

@code{sort} returns a newly allocated list whose elements are the
elements of @var{list}, except that the elements are rearranged so that
they are sorted in the order defined by @var{procedure}.  So, for
example, if the elements of @var{list} are numbers, and @var{procedure}
is @code{<}, then the resulting list is sorted in monotonically
nondecreasing order.  Likewise, if @var{procedure} is @code{>}, the
resulting list is sorted in monotonically nonincreasing order.  To be
precise, if @var{x} and @var{y} are any two adjacent elements in the
resulting list, where @var{x} precedes @var{y}, it is the case that

@example
@group
(@var{procedure} @var{y} @var{x})
     @result{}  #f
@end group
@end example
@end deffn

@node Vectors, Bit Strings, Lists, Top
@chapter Vectors

@cindex vector (defn)
@dfn{Vectors} are heterogenous structures whose elements are indexed by
exact non-negative integers.  A vector typically occupies less space
than a list of the same length, and the average time required to access
a randomly chosen element is typically less for the vector than for the
list.

@cindex length, of vector (defn)
@cindex index, of vector (defn)
@cindex valid index, of vector (defn)
@cindex vector length (defn)
@cindex vector index (defn)
The @dfn{length} of a vector is the number of elements that it contains.
This number is an exact non-negative integer that is fixed when the
vector is created.  The @dfn{valid indexes} of a vector are the exact
non-negative integers less than the length of the vector.  The first
element in a vector is indexed by zero, and the last element is indexed
by one less than the length of the vector.

@cindex external representation, for vector
@cindex #( as external representation
@cindex parenthesis, as external representation
@findex #(
Vectors are written using the notation @code{#(@var{object} @dots{})}.
For example, a vector of length 3 containing the number zero in element
0, the list @code{(2 2 2 2)} in element 1, and the string @code{"Anna"}
in element 2 can be written as

@example
#(0 (2 2 2 2) "Anna")
@end example

@noindent
Note that this is the external representation of a vector, not an
expression evaluating to a vector.  Like list constants, vector
constants must be quoted:

@example
'#(0 (2 2 2 2) "Anna")          @result{}  #(0 (2 2 2 2) "Anna")
@end example

@cindex subvector (defn)
@cindex start, of subvector (defn)
@cindex end, of subvector (defn)
@cindex index, of subvector (defn)
@cindex valid index, of subvector (defn)
A number of the vector procedures operate on subvectors.  A
@dfn{subvector} is a segment of a vector that is specified by two exact
non-negative integers, @var{start} and @var{end}.  @var{Start} is the
index of the first element that is included in the subvector, and
@var{end} is one greater than the index of the last element that is
included in the subvector.  Thus if @var{start} and @var{end} are the
same, they refer to a null subvector, and if @var{start} is zero and
@var{end} is the length of the vector, they refer to the entire vector.
The @dfn{valid indexes} of a subvector are the exact integers between
@var{start} inclusive and @var{end} exclusive.

@menu
* Construction of Vectors::     
* Selecting Vector Components::  
* Cutting Vectors::             
* Modifying Vectors::           
@end menu

@node Construction of Vectors, Selecting Vector Components,  , Vectors
@section Construction of Vectors
@cindex construction, of vector

@deffn {procedure} make-vector k [object]
Returns a newly allocated vector of @var{k} elements.  If @var{object}
is specified, @code{make-vector} initializes each element of the vector
to @var{object}.  Otherwise the initial elements of the result are
unspecified.
@end deffn

@deffn procedure vector object @dots{}
@findex list
Returns a newly allocated vector whose elements are the given arguments.
@code{vector} is analogous to @code{list}.

@example
(vector 'a 'b 'c)                       @result{}  #(a b c)
@end example
@end deffn

@deffn {procedure+} vector-copy vector
@cindex copying, of vector
Returns a newly allocated vector that is a copy of @var{vector}.
@end deffn

@deffn procedure list->vector list
@cindex list, converting to vector
@findex vector->list
Returns a newly allocated vector initialized to the elements of
@var{list}.  The inverse of @code{list->vector} is @code{vector->list}.

@example
(list->vector '(dididit dah))           @result{}  #(dididit dah)
@end example
@end deffn

@deffn {procedure+} make-initialized-vector k initialization
Similar to @code{make-vector}, except that the elements of the result
are determined by calling the procedure @var{initialization} on the
indices.  For example:

@example
@group
(make-initialized-vector 5 (lambda (x) (* x x)))
     @result{}  #(0 1 4 9 16)
@end group
@end example
@end deffn

@deffn {procedure+} vector-grow vector k
@cindex growing, of vector
@var{K} must be greater than or equal to the length of @var{vector}.
Returns a newly allocated vector of length @var{k}.  The first
@code{(vector-length @var{vector})} elements of the result are
initialized from the corresponding elements of @var{vector}.  The
remaining elements of the result are unspecified.
@end deffn

@node Selecting Vector Components, Cutting Vectors, Construction of Vectors, Vectors
@section Selecting Vector Components
@cindex selection, of vector component
@cindex component selection, of vector

@deffn procedure vector? object
@cindex type predicate, for vector
Returns @code{#t} if @var{object} is a vector; otherwise returns
@code{#f}.
@end deffn

@deffn procedure vector-length vector
Returns the number of elements in @var{vector}.
@end deffn

@deffn procedure vector-ref vector k
Returns the contents of element @var{k} of @var{vector}.  @var{K} must
be a valid index of @var{vector}.

@example
(vector-ref '#(1 1 2 3 5 8 13 21) 5)    @result{}  8
@end example
@end deffn

@deffn procedure vector-set! vector k object
Stores @var{object} in element @var{k} of @var{vector} and returns an
unspecified value.  @var{K} must be a valid index of
@var{vector}.

@example
@group
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)
     @result{}  #(0 ("Sue" "Sue") "Anna")
@end group
@end example
@end deffn

@deffn {procedure+} vector-first vector
@deffnx {procedure+} vector-second vector
@deffnx {procedure+} vector-third vector
@deffnx {procedure+} vector-fourth vector
@deffnx {procedure+} vector-fifth vector
@deffnx {procedure+} vector-sixth vector
@deffnx {procedure+} vector-seventh vector
@deffnx {procedure+} vector-eighth vector
These procedures access the first several elements of @var{vector} in
the obvious way.  It is an error if the implicit index of one of these
procedurs is not a valid index of @var{vector}.
@end deffn

@node Cutting Vectors, Modifying Vectors, Selecting Vector Components, Vectors
@section Cutting Vectors
@cindex cutting, of vector

@deffn {procedure+} subvector vector start end
Returns a newly allocated vector that contains the elements of
@var{vector} between index @var{start} (inclusive) and @var{end}
(exclusive).
@end deffn

@deffn {procedure+} vector-head vector end
Equivalent to

@example
(subvector @var{vector} 0 @var{end})
@end example
@end deffn

@deffn {procedure+} vector-tail vector start
Equivalent to

@example
(subvector @var{vector} @var{start} (vector-length @var{vector}))
@end example
@end deffn

@node Modifying Vectors,  , Cutting Vectors, Vectors
@section Modifying Vectors
@cindex modification, of vector
@cindex filling, of vector
@cindex moving, of vector elements

@deffn {procedure} vector-fill! vector object
@deffnx {procedure+} subvector-fill! vector start end object
Stores @var{object} in every element of the vector (subvector) and
returns an unspecified value.
@end deffn

@deffn {procedure+} subvector-move-left! vector1 start1 end1 vector2 start2
@deffnx {procedure+} subvector-move-right! vector1 start1 end1 vector2 start2
Destructively copies the elements of @var{vector1}, starting with index
@var{start1} (inclusive) and ending with @var{end1} (exclusive), into
@var{vector2} starting at index @var{start2} (inclusive).
@var{Vector1}, @var{start1}, and @var{end1} must specify a valid
subvector, and @var{start2} must be a valid index for @var{vector2}.
The length of the source subvector must not exceed the length of
@var{vector2} minus the index @var{start2}.

The elements are copied as follows (note that this is only important when
@var{vector1} and @var{vector2} are @code{eqv?}):

@table @code
@item subvector-move-left!
The copy starts at the left end and moves toward the right (from smaller
indices to larger).  Thus if @var{vector1} and @var{vector2} are the
same, this procedure moves the elements toward the left inside the
vector.

@item subvector-move-right!
The copy starts at the right end and moves toward the left (from larger
indices to smaller).  Thus if @var{vector1} and @var{vector2} are the
same, this procedure moves the elements toward the right inside the
vector.
@end table
@end deffn

@node Bit Strings, Miscellaneous Datatypes, Vectors, Top
@chapter Bit Strings

@cindex bit string (defn)
@cindex string, of bits (defn)
A @dfn{bit string} is a sequence of bits.  Bit strings can be used to
represent sets or to manipulate binary data.  The elements of a bit
string are numbered from zero up to the number of bits in the string
less one, in @emph{right to left order}, (the rightmost bit is numbered
zero).  When you convert from a bit string to an integer, the zero-th
bit is associated with the zero-th power of two, the first bit is
associated with the first power, and so on.

Bit strings are encoded very densely in memory.  Each bit occupies
exactly one bit of storage, and the overhead for the entire bit string
is bounded by a small constant.  However, accessing a bit in a bit
string is slow compared to accessing an element of a vector or character
string.  If performance is of overriding concern, it is better to use
character strings to store sets of boolean values even though they
occupy more space.

@cindex length, of bit string (defn)
@cindex index, of bit string (defn)
@cindex valid index, of bit string (defn)
@cindex bit string length (defn)
@cindex bit string index (defn)
The @dfn{length} of a bit string is the number of bits that it contains.
This number is an exact non-negative integer that is fixed when the bit
string is created.  The @dfn{valid indexes} of a bit string are the
exact non-negative integers less than the length of the bit string.

@cindex external representation, for bit string
@cindex #* as external representation
@cindex asterisk, as external representation
Bit strings may contain zero or more bits.  They are not limited by the
length of a machine word.  In the printed representation of a bit
string, the contents of the bit string are preceded by @samp{#*}.  The
contents are printed starting with the most significant bit (highest
index).

Note that the external representation of bit strings uses a bit ordering
that is the reverse of the representation for bit strings in Common
Lisp.  It is likely that MIT Scheme's representation will be
changed in the future, to be compatible with Common Lisp.  For the time
being this representation should be considered a convenience for viewing
bit strings rather than a means of entering them as data.

@example
@group
#*11111
#*1010
#*00000000
#*
@end group
@end example

All of the bit-string procedures are MIT Scheme extensions.

@menu
* Construction of Bit Strings::  
* Selecting Bit String Components::  
* Cutting and Pasting Bit Strings::  
* Bitwise Operations on Bit Strings::  
* Modification of Bit Strings::  
* Integer Conversions of Bit Strings::  
@end menu

@node Construction of Bit Strings, Selecting Bit String Components,  , Bit Strings
@section Construction of Bit Strings
@cindex construction, of bit string

@deffn {procedure+} make-bit-string k initialization
Returns a newly allocated bit string of length @var{k}.  If
@var{initialization} is @code{#f}, the bit string is filled with 0 bits;
otherwise, the bit string is filled with 1 bits.

@example
(make-bit-string 7 #f)                  @result{}  #*0000000
@end example
@end deffn

@deffn {procedure+} bit-string-allocate k
Returns a newly allocated bit string of length @var{k}, but does not
initialize it.
@end deffn

@deffn {procedure+} bit-string-copy bit-string
@cindex copying, of bit string
Returns a newly allocated copy of @var{bit-string}.
@end deffn

@node Selecting Bit String Components, Cutting and Pasting Bit Strings, Construction of Bit Strings, Bit Strings
@section Selecting Bit String Components

@deffn {procedure+} bit-string? object
@cindex type predicate, for bit string
Returns @code{#t} if @var{object} is a bit string; otherwise returns
@code{#f}.
@end deffn

@deffn {procedure+} bit-string-length bit-string
@cindex length, of bit string
Returns the length of @var{bit-string}.
@end deffn

@deffn {procedure+} bit-string-ref bit-string k
@cindex selection, of bit string component
@cindex component selection, of bit string
Returns @code{#t} if the @var{k}th bit is 1; otherwise returns
@code{#f}.  @var{K} must be a valid index of @var{bit-string}.
@end deffn

@deffn {procedure+} bit-string-set! bit-string k
Sets the @var{k}th bit in @var{bit-string} to 1 and returns an
unspecified value.  @var{K} must be a valid index of @var{bit-string}.
@end deffn

@deffn {procedure+} bit-string-clear! bit-string k
Sets the @var{k}th bit in @var{bit-string} to 0 and returns an
unspecified value.  @var{K} must be a valid index of @var{bit-string}.
@end deffn

@node Cutting and Pasting Bit Strings, Bitwise Operations on Bit Strings, Selecting Bit String Components, Bit Strings
@section Cutting and Pasting Bit Strings
@cindex cutting, of bit string
@cindex pasting, of bit strings

@deffn {procedure+} bit-string-append bit-string-1 bit-string-2
@cindex appending, of bit strings
Appends the two bit string arguments, returning a newly allocated bit
string as its result.  In the result, the bits copied from
@var{bit-string-1} are less significant (smaller indices) than those
copied from @var{bit-string-2}.
@end deffn

@deffn {procedure+} bit-substring bit-string start end
@cindex substring, of bit string
Returns a newly allocated bit string whose bits are copied from
@var{bit-string}, starting at index @var{start} (inclusive) and ending
at @var{end} (exclusive).
@end deffn

@node Bitwise Operations on Bit Strings, Modification of Bit Strings, Cutting and Pasting Bit Strings, Bit Strings
@section Bitwise Operations on Bit Strings

@deffn {procedure+} bit-string-zero? bit-string
Returns @code{#t} if @var{bit-string} contains only 0 bits; otherwise
returns @code{#f}.
@end deffn

@deffn {procedure+} bit-string=? bit-string-1 bit-string-2
@cindex equivalence predicate, for bit strings
@cindex comparison, of bit strings
Compares the two bit string arguments and returns @code{#t} if they are the
same length and contain the same bits; otherwise returns @code{#f}.
@end deffn

@deffn {procedure+} bit-string-not bit-string
@cindex inverse, of bit string
Returns a newly allocated bit string that is the bitwise-logical
negation of @var{bit-string}.
@end deffn

@deffn {procedure+} bit-string-movec! target-bit-string bit-string
The destructive version of @code{bit-string-not}.  The arguments
@var{target-bit-string} and @var{bit-string} must be bit strings of the
same length.  The bitwise-logical negation of @var{bit-string} is
computed and the result placed in @var{target-bit-string}.  The value of
this procedure is unspecified.
@end deffn

@deffn {procedure+} bit-string-and bit-string-1 bit-string-2
Returns a newly allocated bit string that is the bitwise-logical ``and''
of the arguments.  The arguments must be bit strings of identical
length.
@end deffn

@deffn {procedure+} bit-string-andc bit-string-1 bit-string-2
Returns a newly allocated bit string that is the bitwise-logical ``and''
of @var{bit-string-1} with the bitwise-logical negation of
@var{bit-string-2}.  The arguments must be bit strings of identical
length.
@end deffn

@deffn {procedure+} bit-string-or bit-string-1 bit-string-2
Returns a newly allocated bit string that is the bitwise-logical
``inclusive or'' of the arguments.  The arguments must be bit strings of
identical length.
@end deffn

@deffn {procedure+} bit-string-xor bit-string-1 bit-string-2
Returns a newly allocated bit string that is the bitwise-logical
``exclusive or'' of the arguments.  The arguments must be bit strings of
identical length.
@end deffn

@deffn {procedure+} bit-string-and! target-bit-string bit-string
@deffnx {procedure+} bit-string-or! target-bit-string bit-string
@deffnx {procedure+} bit-string-xor! target-bit-string bit-string
@deffnx {procedure+} bit-string-andc! target-bit-string bit-string
These are destructive versions of the above operations.  The arguments
@var{target-bit-string} and @var{bit-string} must be bit strings of the
same length.  Each of these procedures performs the corresponding
bitwise-logical operation on its arguments, places the result into
@var{target-bit-string}, and returns an unspecified result.
@end deffn

@node Modification of Bit Strings, Integer Conversions of Bit Strings, Bitwise Operations on Bit Strings, Bit Strings
@section Modification of Bit Strings
@cindex modification, of bit string
@cindex filling, of bit string
@cindex moving, of bit string elements

@deffn {procedure+} bit-string-fill! bit-string initialization
Fills @var{bit-string} with zeroes if @var{initialization} is @code{#f};
otherwise fills @var{bit-string} with ones.  Returns an unspecified
value.
@end deffn

@deffn {procedure+} bit-string-move! target-bit-string bit-string
Moves the contents of @var{bit-string} into @var{target-bit-string}.  Both
arguments must be bit strings of the same length.  The results of the
operation are undefined if the arguments are the same bit string.
@end deffn

@deffn {procedure+} bit-substring-move-right! bit-string-1 start1 end1 bit-string-2 start2
Destructively copies the bits of @var{bit-string-1}, starting at index
@var{start1} (inclusive) and ending at @var{end1} (exclusive), into
@var{bit-string-2} starting at index @var{start2} (inclusive).
@var{Start1} and @var{end1} must be valid substring indices for
@var{bit-string-1}, and @var{start2} must be a valid index for
@var{bit-string-2}.  The length of the source substring must not exceed
the length of @var{bit-string-2} minus the index @var{start2}.

The bits are copied starting from the MSB and working towards the LSB; the
direction of copying only matters when @var{bit-string-1} and
@var{bit-string-2} are @code{eqv?}.
@end deffn

@need 1000
@node Integer Conversions of Bit Strings,  , Modification of Bit Strings, Bit Strings
@section Integer Conversions of Bit Strings
@cindex integer, converting to bit string

@deffn {procedure+} unsigned-integer->bit-string length integer
Both @var{length} and @var{integer} must be exact non-negative integers.
Converts @var{integer} into a newly allocated bit string of @var{length}
bits.  Signals an error of type @code{condition-type:bad-range-argument}
if @var{integer} is too large to be represented in @var{length} bits.
@findex condition-type:bad-range-argument
@end deffn

@deffn {procedure+} signed-integer->bit-string length integer
@var{Length} must be an exact non-negative integer, and @var{integer}
may be any exact integer.  Converts @var{integer} into a newly allocated
bit string of @var{length} bits, using two's complement encoding for
negative numbers.  Signals an error of type
@code{condition-type:bad-range-argument} if @var{integer} is too large
to be represented in @var{length} bits.
@findex condition-type:bad-range-argument
@end deffn

@deffn {procedure+} bit-string->unsigned-integer bit-string
@deffnx {procedure+} bit-string->signed-integer bit-string
Converts @var{bit-string} into an exact integer.
@code{bit-string->signed-integer} regards @var{bit-string} as a two's
complement representation of a signed integer, and produces an integer
of like sign and absolute value.  @code{bit-string->unsigned-integer}
regards @var{bit-string} as an unsigned quantity and converts to an
integer accordingly.
@end deffn

@node Miscellaneous Datatypes, Associations, Bit Strings, Top
@chapter Miscellaneous Datatypes

@menu
* Booleans::                    
* Symbols::                     
* Cells::                       
* Records::                     
* Promises::                    
* Streams::                     
* Weak Pairs::                  
@end menu

@node Booleans, Symbols,  , Miscellaneous Datatypes
@section Booleans

@findex #t
@findex #f
@cindex #t as external representation
@cindex #f as external representation
@cindex boolean object (defn)
@cindex true, boolean object (defn)
@cindex false, boolean object (defn)
The @dfn{boolean objects} are @dfn{true} and @dfn{false}.  The boolean
constant true is written as @samp{#t}, and the boolean constant false is
written as @samp{#f}.

@findex if
@findex cond
@findex and
@findex or
The primary use for boolean objects is in the conditional expressions
@code{if}, @code{cond}, @code{and}, and @code{or}; the behavior of these
expressions is determined by whether objects are true or false.  These
expressions count only @code{#f} as false.  They count everything else,
including @code{#t}, pairs, symbols, numbers, strings, vectors, and
procedures as true (but @pxref{True and False}).

@findex t
@findex nil
Programmers accustomed to other dialects of Lisp should note that Scheme
distinguishes @code{#f} and the empty list from the symbol @code{nil}.
Similarly, @code{#t} is distinguished from the symbol @code{t}.  In
fact, the boolean objects (and the empty list) are not symbols at all.

Boolean constants evaluate to themselves, so you don't need to quote
them.

@example
@group
#t                                      @result{}  #t
#f                                      @result{}  #f
'#f                                     @result{}  #f
t                                       @error{} Unbound variable
@end group
@end example

@defvr {variable+} false
@defvrx {variable+} true
These variables are bound to the objects @code{#f} and @code{#t}
respectively.  The compiler, given some standard declarations, replaces
references to these variables with their respective values.

Note that the symbol @code{true} is not equivalent to @code{#t}, and the
symbol @code{false} is not equivalent to @code{#f}.
@end defvr

@deffn procedure boolean? object
@cindex type predicate, for boolean
Returns @code{#t} if @var{object} is either @code{#t} or @code{#f};
otherwise returns @code{#f}.

@example
(boolean? #f)                           @result{}  #t
(boolean? 0)                            @result{}  #f
@end example
@end deffn

@deffn procedure not object
@deffnx {procedure+} false? object
@cindex false, predicate for
@cindex inverse, of boolean object
These procedures return @code{#t} if @var{object} is false; otherwise
they return @code{#f}.  In other words they @emph{invert} boolean
values.  These two procedures have identical semantics; their names are
different to give different connotations to the test.

@example
(not #t)                                @result{}  #f
(not 3)                                 @result{}  #f
(not (list 3))                          @result{}  #f
(not #f)                                @result{}  #t
@end example
@end deffn

@deffn {procedure+} boolean=? obj1 obj2
@cindex boolean object, equivalence predicate
@cindex equivalence predicate, for boolean objects
@cindex comparison, of boolean objects
This predicate is true iff @var{obj1} and @var{obj2} are either both true
or both false.
@end deffn

@deffn {procedure+} boolean/and object @dots{}
This procedure returns @code{#t} if none of its arguments are @code{#f}.
Otherwise it returns @code{#f}.
@end deffn

@deffn {procedure+} boolean/or object @dots{}
This procedure returns @code{#f} if all of its arguments are @code{#f}.
Otherwise it returns @code{#t}.
@end deffn

@node Symbols, Cells, Booleans, Miscellaneous Datatypes
@section Symbols

@cindex symbol (defn)
@cindex interned symbol (defn)
@cindex uninterned symbol (defn)
@cindex property list, of symbol
@cindex disembodied property list
@findex read
MIT Scheme provides two types of symbols: @dfn{interned} and
@dfn{uninterned}.  Interned symbols are far more common than uninterned
symbols, and there are more ways to create them.  Interned symbols have
an external representation that is recognized by the procedure
@code{read}; uninterned symbols do not.@footnote{In older dialects of
Lisp, uninterned symbols were fairly important.  This was true because
symbols were complicated data structures: in addition to having value
cells (and sometimes, function cells), these structures contained
@dfn{property lists}.  Because of this, uninterned symbols were often
used merely for their property lists --- sometimes an uninterned symbol
used this way was referred to as a @dfn{disembodied property list}.  In
MIT Scheme, symbols do not have property lists, or any other components
besides their names.  There is a different data structure similar to
disembodied property lists: one-dimensional tables (@pxref{1D Tables}).
For these reasons, uninterned symbols are not very useful in MIT Scheme.
In fact, their primary purpose is to simplify the generation of unique
variable names in programs that generate Scheme code.}

@findex string=?
@findex eqv?
Interned symbols have an extremely useful property: any two interned
symbols whose names are the same, in the sense of @code{string=?}, are
the same object (i.e.@: they are @code{eqv?} to one another).  The term
@dfn{interned} refers to the process of @dfn{interning} by which this is
accomplished.  Uninterned symbols do not share this property.

@cindex case, of interned symbol
@cindex alphabetic case, of interned symbol
@findex write
The names of interned symbols are not distinguished by their alphabetic
case.  Because of this, MIT Scheme converts all alphabetic
characters in the name of an interned symbol to a specific case (lower
case) when the symbol is created.  When the name of an interned symbol
is referenced (using @code{symbol->string}) or written (using
@code{write}) it appears in this case.  It is a bad idea to depend on
the name being lower case.  In fact, it is preferable to take this one
step further: don't depend on the name of a symbol being in a uniform
case.

@cindex external representation, for symbol
@findex read
@findex write
The rules for writing an interned symbol are the same as the rules for
writing an identifier (@pxref{Identifiers}).  Any interned symbol that
has been returned as part of a literal expression, or read using the
@code{read} procedure and subsequently written out using the
@code{write} procedure, will read back in as the identical symbol (in
the sense of @code{eqv?}).

Usually it is also true that reading in an interned symbol that was
previously written out produces the same symbol.  An exception are
symbols created by the procedures @code{string->symbol} and
@code{intern}; they can create symbols for which this write/read
invariance may not hold because the symbols' names contain special
characters or letters in the non-standard case.@footnote{MIT Scheme
reserves a specific set of interned symbols for its own use.  If you use
these reserved symbols it is possible that you could break specific
pieces of software that depend on them.  The reserved symbols all have
names beginning with the characters @samp{#[} and ending with the
character @samp{]}; thus none of these symbols can be read by the
procedure @code{read} and hence are not likely to be used by accident.
For example, @code{(intern "#[unnamed-procedure]")} produces a reserved
symbol.}

@findex read
The external representation for uninterned symbols is special, to
distinguish them from interned symbols and prevent them from being
recognized by the @code{read} procedure:

@example
@group
(string->uninterned-symbol "foo")
     @result{}  #[uninterned-symbol 30 foo]
@end group
@end example

In this section, the procedures that return symbols as values will
either always return interned symbols, or always return uninterned
symbols.  The procedures that accept symbols as arguments will always
accept either interned or uninterned symbols, and do not distinguish the
two.

@deffn procedure symbol? object
@cindex type predicate, for symbol
Returns @code{#t} if @var{object} is a symbol, otherwise returns
@code{#f}.

@example
@group
(symbol? 'foo)                                  @result{}  #t
(symbol? (car '(a b)))                          @result{}  #t
(symbol? "bar")                                 @result{}  #f
@end group
@end example
@end deffn

@deffn procedure symbol->string symbol
@cindex name, of symbol
@cindex print name, of symbol
@findex string=?
@findex string-set!
Returns the name of @var{symbol} as a string.  If @var{symbol} was
returned by @code{string->symbol}, the value of this procedure will be
identical (in the sense of @code{string=?}) to the string that was
passed to @code{string->symbol}.  It is an error to apply mutation
procedures such as @code{string-set!} to strings returned by this
procedure.

@example
@group
(symbol->string 'flying-fish)           @result{}  "flying-fish"
(symbol->string 'Martin)                @result{}  "martin"
(symbol->string (string->symbol "Malvina"))
                                        @result{}  "Malvina"
@end group
@end example

Note that two distinct uninterned symbols can have the same name.
@end deffn

@deffn {procedure+} intern string
@cindex interning, of symbols
@cindex construction, of symbols
Returns the interned symbol whose name is @var{string}.  Converts
@var{string} to the standard alphabetic case before generating the
symbol.  This is the preferred way to create interned symbols, as it
guarantees the following independent of which case the implementation
uses for symbols' names:

@example
(eq? 'bitBlt (intern "bitBlt")) @result{}     #t
@end example

The user should take care that @var{string} obeys the rules for
identifiers (@pxref{Identifiers}), otherwise the resulting symbol cannot
be read as itself.
@end deffn

@deffn procedure string->symbol string
@cindex string, interning as symbol
Returns the interned symbol whose name is @var{string}.  Although you
can use this procedure to create symbols with names containing special
characters or lowercase letters, it's usually a bad idea to create such
symbols because they cannot be read as themselves.  See
@code{symbol->string}.

@example
@group
(eq? 'mISSISSIppi 'mississippi)         @result{}  #t
(string->symbol "mISSISSIppi")
     @result{}  @r{the symbol with the name} "mISSISSIppi"
(eq? 'bitBlt (string->symbol "bitBlt")) @result{}  #f
(eq? 'JollyWog
      (string->symbol
        (symbol->string 'JollyWog)))    @result{}  #t
(string=? "K. Harper, M.D."
           (symbol->string
             (string->symbol
               "K. Harper, M.D.")))     @result{}  #t
@end group
@end example
@end deffn

@deffn {procedure+} string->uninterned-symbol string
Returns a newly allocated uninterned symbol whose name is @var{string}.
It is unimportant what case or characters are used in
@var{string}.

Note: this is the fastest way to make a symbol.
@end deffn

@deffn {procedure+} generate-uninterned-symbol [object]
@cindex gensym (see uninterned symbol)
@findex eqv?
Returns a newly allocated uninterned symbol that is guaranteed not to be
@code{eqv?} to any other object in the Scheme system.  The symbol's name
consists of a string (initially @code{"G"}) followed by an integer that
is incremented on every call (the integer is initially 0).  The optional
@var{object} can be an integer or a symbol.  If @var{object} is a
symbol, the string prefix of all subsequently generated symbol names
will be that symbol's name.  If @var{object} is an integer, the integer
suffix of all subsequently generated symbol names will start counting
from that value.

@example
@group
(generate-uninterned-symbol)
     @result{}  #[uninterned-symbol 31 g0]
(generate-uninterned-symbol)
     @result{}  #[uninterned-symbol 32 g1]
(generate-uninterned-symbol 'this)
     @result{}  #[uninterned-symbol 33 this2]
(generate-uninterned-symbol)
     @result{}  #[uninterned-symbol 34 this3]
(generate-uninterned-symbol 100)
     @result{}  #[uninterned-symbol 35 this100]
(generate-uninterned-symbol)
     @result{}  #[uninterned-symbol 36 this101]
@end group
@end example
@end deffn

@deffn {procedure+} symbol-append symbol @dots{}
@cindex appending, of symbols
@cindex pasting, of symbols
Returns the interned symbol whose name is formed by concatenating the
names of the given symbols.  This procedure preserves the case of the
names of its arguments, so if one or more of the arguments' names has
non-standard case, the result will also have non-standard case.

@example
(symbol-append 'foo- 'bar)              @result{}  foo-bar
@r{;; the arguments may be uninterned:}
(symbol-append 'foo- (string->uninterned-symbol "baz"))
                                        @result{}  foo-baz
@r{;; the result has the same case as the arguments:}
(symbol-append 'foo- (string->symbol "BAZ"))    @result{}  foo-BAZ
@end example
@end deffn

@deffn {procedure+} symbol-hash symbol
@cindex hashing, of symbol
@findex string-hash
Returns a hash number for @var{symbol}, which is computed by calling
@code{string-hash} on @var{symbol}'s name.
@end deffn

@node Cells, Records, Symbols, Miscellaneous Datatypes
@section Cells

@cindex cell (defn)
@dfn{Cells} are data structures similar to pairs except that they have
only one element.  They are useful for managing state.

@deffn {procedure+} cell? object
@cindex type predicate, for cell
Returns @code{#t} if @var{object} is a cell; otherwise returns
@code{#f}.
@end deffn

@deffn {procedure+} make-cell object
@cindex construction, of cell
Returns a newly allocated cell whose contents is @var{object}.
@end deffn

@deffn {procedure+} cell-contents cell
@cindex selection, of cell component
@cindex component selection, of cell
Returns the current contents of @var{cell}.
@end deffn

@deffn {procedure+} set-cell-contents! cell object
Alters the contents of @var{cell} to be @var{object}.  Returns an
unspecified value.
@end deffn

@deffn {procedure+} bind-cell-contents! cell object thunk
Alters the contents of @var{cell} to be @var{object}, calls @var{thunk}
with no arguments, then restores the original contents of @var{cell} and
returns the value returned by @var{thunk}.  This is completely
equivalent to fluid binding of a variable, including the behavior when
continuations are used (@pxref{Fluid Binding}).
@end deffn

@node Records, Promises, Cells, Miscellaneous Datatypes
@section Records

MIT Scheme provides a @dfn{record} abstraction, which is a simple and
flexible mechanism for building structures with named components.
Records can be defined and accessed using the procedures defined in this
section.  A less flexible but more concise way to manipulate records is
to use the @code{define-structure} special form (@pxref{Structure
Definitions}).
@findex define-structure

@deffn {procedure+} make-record-type type-name field-names
@cindex record-type descriptor (defn)
Returns a @dfn{record-type descriptor}, a value representing a new data
type, disjoint from all others.  The @var{type-name} argument must be a
string, but is only used for debugging purposes (such as the printed
representation of a record of the new type).  The @var{field-names}
argument is a list of symbols naming the @dfn{fields} of a record of the
new type.  It is an error if the list contains any duplicates.  It is
unspecified how record-type descriptors are represented.
@end deffn

@deffn {procedure+} record-constructor record-type [field-names]
Returns a procedure for constructing new members of the type represented
by @var{record-type}.  The returned procedure accepts exactly as many
arguments as there are symbols in the given list, @var{field-names};
these are used, in order, as the initial values of those fields in a new
record, which is returned by the constructor procedure.  The values of
any fields not named in the list of @var{field-names} are unspecified.
The @var{field-names} argument defaults to the list of field-names in
the call to @code{make-record-type} that created the type represented by
@var{record-type}; if the @var{field-names} argument is provided, it is
an error if it contains any duplicates or any symbols not in the default
list.
@end deffn

@deffn {procedure+} record-predicate record-type
Returns a procedure for testing membership in the type represented by
@var{record-type}.  The returned procedure accepts exactly one argument
and returns @code{#t} if the argument is a member of the indicated
record type; it returns @code{#f} otherwise.
@end deffn

@deffn {procedure+} record-accessor record-type field-name
Returns a procedure for reading the value of a particular field of a
member of the type represented by @var{record-type}.  The returned
procedure accepts exactly one argument which must be a record of the
appropriate type; it returns the current value of the field named by the
symbol @var{field-name} in that record.  The symbol @var{field-name}
must be a member of the list of field names in the call to
@code{make-record-type} that created the type represented by
@var{record-type}.
@end deffn

@deffn {procedure+} record-modifier record-type field-name
Returns a procedure for writing the value of a particular field of a
member of the type represented by @var{record-type}.  The returned
procedure accepts exactly two arguments: first, a record of the
appropriate type, and second, an arbitrary Scheme value; it modifies the
field named by the symbol @var{field-name} in that record to contain the
given value.  The returned value of the modifier procedure is
unspecified.  The symbol @var{field-name} must be a member of the list
of field names in the call to @code{make-record-type} that created the
type represented by @var{record-type}.

@findex record-updater
For compatibility with old code, @code{record-updater} is a synonym for
this procedure.
@end deffn

@deffn {procedure+} record? object
@cindex type predicate, for record
Returns @code{#t} if @var{object} is a record of any type and @code{#f}
otherwise.  Note that @code{record?} may be true of any Scheme value; of
course, if it returns @code{#t} for some particular value, then
@code{record-type-descriptor} is applicable to that value and returns an
appropriate descriptor.
@end deffn

@deffn {procedure+} record-type-descriptor record
Returns the record-type descriptor representing the type of
@var{record}.  That is, for example, if the returned descriptor were
passed to @code{record-predicate}, the resulting predicate would return
@code{#t} when passed @var{record}.  Note that it is not necessarily the
case that the returned descriptor is the one that was passed to
@code{record-constructor} in the call that created the constructor
procedure that created @var{record}.
@end deffn

@deffn {procedure+} record-type? object
@cindex type predicate, for record type
Returns @code{#t} if @var{object} is a record-type descriptor; otherwise
returns @code{#f}.
@end deffn

@deffn {procedure+} record-type-name record-type
Returns the type name associated with the type represented by
@var{record-type}.  The returned value is @code{eqv?} to the
@var{type-name} argument given in the call to @code{make-record-type}
that created the type represented by @var{record-type}.
@end deffn

@deffn {procedure+} record-type-field-names record-type
Returns a list of the symbols naming the fields in members of the type
represented by @var{record-type}.  The returned value is @code{equal?}
to the @var{field-names} argument given in the call to
@code{make-record-type} that created the type represented by
@var{record-type}.@footnote{In MIT Scheme, the returned list is always
newly allocated.}
@end deffn

@node Promises, Streams, Records, Miscellaneous Datatypes
@section Promises

@deffn {special form} delay expression
@cindex promise (defn)
@cindex promise, construction
@cindex construction, of promise
@cindex lazy evaluation (defn)
@cindex call by need evaluation (defn)
@cindex evaluation, lazy (defn)
@cindex evaluation, call by need (defn)
The @code{delay} construct is used together with the procedure
@code{force} to implement @dfn{lazy evaluation} or @dfn{call by need}.
@code{(delay @var{expression})} returns an object called a @dfn{promise}
which at some point in the future may be asked (by the @code{force}
procedure) to evaluate @var{expression} and deliver the resulting value.
@end deffn

@deffn procedure force promise
@cindex promise, forcing
@cindex forcing, of promise
@cindex memoization, of promise
Forces the value of @emph{promise}.  If no value has been computed for
the promise, then a value is computed and returned.  The value of the
promise is cached (or ``memoized'') so that if it is forced a second
time, the previously computed value is returned without any
recomputation.

@example
@group
(force (delay (+ 1 2)))                 @result{}  3

(let ((p (delay (+ 1 2))))
  (list (force p) (force p)))           @result{}  (3 3)
@end group

@group
(define head car)

(define tail
  (lambda (stream)
    (force (cdr stream))))
@end group

@group
(define a-stream
  (letrec ((next
            (lambda (n)
              (cons n (delay (next (+ n 1)))))))
    (next 0)))

(head (tail (tail a-stream)))           @result{}  2
@end group
@end example
@end deffn

@deffn {procedure+} promise? object
@cindex type predicate, for promise
Returns @code{#t} if @var{object} is a promise; otherwise returns
@code{#f}.
@end deffn

@deffn {procedure+} promise-forced? promise
Returns @code{#t} if @var{promise} has been forced and its value cached;
otherwise returns @code{#f}.
@end deffn

@deffn {procedure+} promise-value promise
If @var{promise} has been forced and its value cached, this procedure
returns the cached value.  Otherwise, an error is signalled.
@end deffn

@code{force} and @code{delay} are mainly intended for programs written
in functional style.  The following examples should not be considered to
illustrate good programming style, but they illustrate the property that
the value of a promise is computed at most once.

@example
@group
(define count 0)

(define p
  (delay
   (begin
     (set! count (+ count 1))
     (* x 3))))

(define x 5)
@end group

@group
count                                   @result{}  0
p                                       @result{}  #[promise 54]
(force p)                               @result{}  15
p                                       @result{}  #[promise 54]
count                                   @result{}  1
(force p)                               @result{}  15
count                                   @result{}  1
@end group
@end example

Here is a possible implementation of @code{delay} and @code{force}.  We
define the expression

@example
(delay @var{expression})
@end example

@noindent
to have the same meaning as the procedure call

@example
(make-promise (lambda () @var{expression}))
@end example

@noindent
where @code{make-promise} is defined as follows:

@example
@group
(define make-promise
  (lambda (proc)
    (let ((already-run? #f)
          (result #f))
      (lambda ()
        (cond ((not already-run?)
               (set! result (proc))
               (set! already-run? #t)))
        result))))
@end group
@end example

Promises are implemented here as procedures of no arguments, and
@code{force} simply calls its argument.

@example
@group
(define force
  (lambda (promise)
    (promise)))
@end group
@end example

Various extensions to this semantics of @code{delay} and @code{force}
are supported in some implementations (none of these are currently
supported in MIT Scheme):

@itemize @bullet
@item
Calling @code{force} on an object that is not a promise may simply
return the object.

@item
It may be the case that there is no means by which a promise can be
operationally distinguished from its forced value.  That is, expressions
like the following may evaluate to either @code{#t} or @code{#f},
depending on the implementation:

@example
@group
(eqv? (delay 1) 1)              @result{}  @r{unspecified}
(pair? (delay (cons 1 2)))      @result{}  @r{unspecified}
@end group
@end example

@item
Some implementations will implement ``implicit forcing'', where the
value of a promise is forced by primitive procedures like @code{car} and
@code{+}:

@example
(+ (delay (* 3 7)) 13)          @result{}  34
@end example
@end itemize

@node Streams, Weak Pairs, Promises, Miscellaneous Datatypes
@section Streams

@cindex stream (defn)
In addition to promises, MIT Scheme supports a higher-level abstraction
called @dfn{streams}.  Streams are similar to lists, except that the
tail of a stream is not computed until it is referred to.
This allows streams to be used to represent infinitely long lists.

@deffn {procedure+} stream object @dots{}
@cindex construction, of stream
@findex the-empty-stream
Returns a newly allocated stream whose elements are the arguments.  Note
that the expression @code{(stream)} returns the empty stream, or
end-of-stream marker.@footnote{The variable @code{the-empty-stream},
which is bound to the end-of-stream marker, is provided for
compatibility with old code; use @code{(stream)} in new code.}
@end deffn

@deffn {procedure+} list->stream list
@cindex list, converting to stream
Returns a newly allocated stream whose elements are the elements of
@var{list}.  Equivalent to @code{(apply stream @var{list})}.
@end deffn

@deffn {procedure+} stream->list stream
@cindex stream, converting to list
Returns a newly allocated list whose elements are the elements of
@var{stream}.  If @var{stream} has infinite length this procedure will
not terminate.  This could have been defined by

@example
@group
(define (stream->list stream)
  (if (stream-null? stream)
      '()
      (cons (stream-car stream)
            (stream->list (stream-cdr stream)))))
@end group
@end example
@end deffn

@deffn {special form+} cons-stream object expression
Returns a newly allocated stream pair.  Equivalent to @code{(cons
@var{object} (delay @var{expression}))}.
@end deffn

@deffn {procedure+} stream-pair? object
@cindex type predicate, for stream pair
Returns @code{#t} if @var{object} is a pair whose cdr contains a
promise.  Otherwise returns @code{#f}.  This could have been defined by

@example
@group
(define (stream-pair? object)
  (and (pair? object)
       (promise? (cdr object))))
@end group
@end example
@end deffn

@deffn {procedure+} stream-car stream
@deffnx {procedure+} stream-first stream
@findex car
@findex head
Returns the first element in @var{stream}.  @code{stream-car} is
equivalent to @code{car}.@footnote{@code{head}, a synonym for
@code{stream-car}, is provided for compatibility with old code; use
@code{stream-car} in new code.}  @code{stream-first} is a synonym for
@code{stream-car}.
@end deffn

@deffn {procedure+} stream-cdr stream
@deffnx {procedure+} stream-rest stream
@findex force
@findex cdr
@findex tail
Returns the first tail of @var{stream}.  Equivalent to @code{(force
(cdr @var{stream}))}.@footnote{@code{tail}, a synonym for
@code{stream-cdr}, is provided for compatibility with old code; use
@code{stream-cdr} in new code.}  @code{stream-rest} is a synonym for
@code{stream-cdr}.
@end deffn

@deffn {procedure+} stream-null? stream
@cindex empty stream, predicate for
@findex null?
@findex empty-stream?
Returns @code{#t} if @var{stream} is the end-of-stream marker;
otherwise returns @code{#f}.  This is equivalent to @code{null?}, but
should be used whenever testing for the end of a
stream.@footnote{@code{empty-stream?}, a synonym for
@code{stream-null?}, is provided for compatibility with old code; use
@code{stream-null?} in new code.}
@end deffn

@deffn {procedure+} stream-length stream
@cindex length, of stream
Returns the number of elements in @var{stream}.  If @var{stream} has an
infinite number of elements this procedure will not terminate.  Note
that this procedure forces all of the promises that comprise
@var{stream}.
@end deffn

@deffn {procedure+} stream-ref stream k
@cindex selecting, of stream component
@cindex component selection, of stream
Returns the element of @var{stream} that is indexed by @var{k}; that is,
the @var{k}th element.  @var{K} must be an exact non-negative integer
strictly less than the length of @var{stream}.
@end deffn

@deffn {procedure+} stream-tail stream k
Returns the tail of @var{stream} that is indexed by @var{k}; that is,
the @var{k}th tail.  This is equivalent to performing @code{stream-cdr}
@var{k} times.  @var{K} must be an exact non-negative integer strictly
less than the length of @var{stream}.
@end deffn

@deffn {procedure+} stream-map stream procedure
@cindex mapping, of stream
Returns a newly allocated stream, each element being the result of
invoking @var{procedure} with the corresponding element of @var{stream}
as its argument.  @var{Procedure} must be a procedure of one argument.
@end deffn

@node Weak Pairs,  , Streams, Miscellaneous Datatypes
@section Weak Pairs

@cindex weak pair (defn)
@cindex pair, weak (defn)
@dfn{Weak pairs} are a mechanism for building data structures that point
at objects without protecting them from garbage collection.  The car of
a weak pair holds its pointer weakly, while the cdr holds its pointer in
the normal way.  If the object in the car of a weak pair is not held
normally by any other data structure, it will be garbage-collected.

@findex pair?
Note: weak pairs are @emph{not} pairs; that is, they do not satisfy the
predicate @code{pair?}.

@deffn {procedure+} weak-pair? object
@cindex type predicate, for weak pair
Returns @code{#t} if @var{object} is a weak pair; otherwise returns
@code{#f}.
@end deffn

@deffn {procedure+} weak-cons car cdr
@cindex construction, of weak pair
Allocates and returns a new weak pair, with components @var{car} and
@var{cdr}.  The @var{car} component is held weakly.
@end deffn

@deffn {procedure+} weak-pair/car? weak-pair
This predicate returns @code{#f} if the car of @var{weak-pair} has been
garbage-collected; otherwise returns @code{#t}.  In other words, it is
true if @var{weak-pair} has a valid car component.
@end deffn

@deffn {procedure+} weak-car weak-pair
@cindex selection, of weak pair component
@cindex component selection, of weak pair
Returns the car component of @var{weak-pair}.  If the car component has
been garbage-collected, this operation returns @code{#f}, but it can
also return @code{#f} if that is the value that was stored in the car.
@end deffn

Normally, @code{weak-pair/car?} is used to determine if @code{weak-car}
would return a valid value.  An obvious way of doing this would be:

@example
@group
(if (weak-pair/car? x)
    (weak-car x)
    @dots{})
@end group
@end example

@noindent
However, since a garbage collection could occur between the call to
@code{weak-pair/car?} and @code{weak-car}, this would not always work
correctly.  Instead, the following should be used, which always works:

@example
@group
(or (weak-car x)
    (and (not (weak-pair/car? x))
         @dots{}))
@end group
@end example

The reason that the latter expression works is that @code{weak-car}
returns @code{#f} in just two instances: when the car component is
@code{#f}, and when the car component has been garbage-collected.  In
the former case, if a garbage collection happens between the two calls,
it won't matter, because @code{#f} will never be garbage-collected.  And
in the latter case, it also won't matter, because the car component no
longer exists and cannot be affected by the garbage collector.

@deffn {procedure+} weak-set-car! weak-pair object
Sets the car component of @var{weak-pair} to @var{object} and returns an
unspecified result.
@end deffn

@deffn {procedure+} weak-cdr weak-pair
Returns the cdr component of @var{weak-cdr}.
@end deffn

@deffn {procedure+} weak-set-cdr! weak-pair object
Sets the cdr component of @var{weak-pair} to @var{object} and returns an
unspecified result.
@end deffn

@node Associations, Procedures, Miscellaneous Datatypes, Top
@chapter Associations

MIT Scheme provides several mechanisms for associating objects with
one another.  Each of these mechanisms creates a link between one or
more objects, called @dfn{keys}, and some other object, called a
@dfn{datum}.  Beyond this common idea, however, each of the mechanisms
has various different properties that make it appropriate in different
situations:

@itemize @bullet
@item
@dfn{Association lists} are one of Lisp's oldest association mechanisms.
Because they are made from ordinary pairs, they are easy to build and
manipulate, and very flexible in use.  However, the average lookup time
for an association list is linear in the number of associations.

@item
@dfn{1D tables} have a very simple interface, making them easy to use,
and offer the feature that they do not prevent their keys from being
reclaimed by the garbage collector.  Like association lists, their
average lookup time is linear in the number of associations; but 1D
tables aren't as flexible.

@item
@cindex property list
@dfn{The association table} is MIT Scheme's equivalent to the
@dfn{property lists} of Lisp.  It has the advantages that the keys may
be any type of object and that it does not prevent the keys from being
reclaimed by the garbage collector.  However, two linear-time lookups
must be performed, one for each key, whereas for traditional property
lists only one is lookup required for both keys.

@item
@dfn{Hash tables} are a powerful mechanism with constant-time access to
large amounts of data.  Hash tables are not as flexible as association
lists, but because their access times are independent of the number of
associations in the table, for most applications they are the mechanism
of choice.

@item
@dfn{Balanced binary trees} are another association mechanism that is
useful for applications in which the keys are ordered.  Binary trees
have access times that are proportional to the logarithm of the number
of associations in the tree.  While they aren't as fast as hash tables,
they offer the advantage that the contents of the tree can be converted
to a sorted alist in linear time.  Additionally, two trees can be
compared for equality in worst-case linear time.

@item
@dfn{Red-Black trees} are a kind of balanced binary tree.  The
implementation supports destructive insertion and deletion operations
with a good constant factor.

@item
@dfn{Weight-Balanced trees} are a kind of balanced binary trees.  The
implementation provides non-destructive operations.  There is a
comprehensive set of operations including a constant time size
operation, many high-level operations such as the set operations union,
intersection and difference, and indexing of elements by position.

@end itemize

@menu
* Association Lists::           
* 1D Tables::                   
* The Association Table::       
* Hash Tables::                 
* Object Hashing::              
* Red-Black Trees::             
* Weight-Balanced Trees::       
@end menu

@node Association Lists, 1D Tables,  , Associations
@section Association Lists

@comment **** begin CLTL ****
@cindex association list (defn)
@cindex list, association (defn)
@cindex alist (defn)
@cindex key, of association list element (defn)
An @dfn{association list}, or @dfn{alist}, is a data structure used very
frequently in Scheme.  An alist is a list of pairs, each of which is
called an @dfn{association}.  The car of an association is called the
@dfn{key}.

An advantage of the alist representation is that an alist can be
incrementally augmented simply by adding new entries to the front.
Moreover, because the searching procedures @code{assv} et al.@: search the
alist in order, new entries can ``shadow'' old entries.  If an alist is
viewed as a mapping from keys to data, then the mapping can be not only
augmented but also altered in a non-destructive manner by adding new
entries to the front of the alist.@footnote{This introduction is taken
from @cite{Common Lisp, The Language}, second edition, p.@: 431.}
@comment **** end CLTL ****

@deffn {procedure+} alist? object
@cindex type predicate, for alist
@findex list?
Returns @code{#t} if @var{object} is an association list (including the
empty list); otherwise returns @code{#f}.  Any @var{object} satisfying this
predicate also satisfies @code{list?}.
@end deffn

@deffn procedure assq object alist
@deffnx procedure assv object alist
@deffnx procedure assoc object alist
@cindex searching, of alist
@findex eq?
@findex eqv?
@findex equal?
These procedures find the first pair in @var{alist} whose car field is
@var{object}, and return that pair; the returned pair is always an
@emph{element} of @var{alist}, @emph{not} one of the pairs from which
@var{alist} is composed.  If no pair in @var{alist} has @var{object} as
its car, @code{#f} (n.b.: not the empty list) is returned.  @code{assq}
uses @code{eq?} to compare @var{object} with the car fields of the pairs
in @var{alist}, while @code{assv} uses @code{eqv?} and @code{assoc} uses
@code{equal?}.@footnote{Although they are often used as predicates,
@code{assq}, @code{assv}, and @code{assoc} do not have question marks in
their names because they return useful values rather than just @code{#t}
or @code{#f}.}

@example
@group
(define e '((a 1) (b 2) (c 3)))
(assq 'a e)                             @result{}  (a 1)
(assq 'b e)                             @result{}  (b 2)
(assq 'd e)                             @result{}  #f
(assq (list 'a) '(((a)) ((b)) ((c))))   @result{}  #f
(assoc (list 'a) '(((a)) ((b)) ((c))))  @result{}  ((a))
(assq 5 '((2 3) (5 7) (11 13)))         @result{}  @r{unspecified}
(assv 5 '((2 3) (5 7) (11 13)))         @result{}  (5 7)
@end group
@end example
@end deffn

@deffn {procedure+} association-procedure predicate selector
Returns an association procedure that is similar to @code{assv}, except
that @var{selector} (a procedure of one argument) is used to select the
key from the association, and @var{predicate} (an equivalence predicate)
is used to compare the key to the given item.  This can be used to make
association lists whose elements are, say, vectors instead of pairs
(also @pxref{Searching Lists}).

For example, here is how @code{assv} could be implemented:
@example
(define assv (association-procedure eqv? car))
@end example

Another example is a ``reverse association'' procedure:

@example
(define rassv (association-procedure eqv? cdr))
@end example
@end deffn

@deffn {procedure+} del-assq object alist
@deffnx {procedure+} del-assv object alist
@deffnx {procedure+} del-assoc object alist
@cindex deletion, of alist element
@findex eq?
@findex eqv?
@findex equal?
These procedures return a newly allocated copy of @var{alist} in which
all associations with keys equal to @var{object} have been removed.
Note that while the returned copy is a newly allocated list, the
association pairs that are the elements of the list are shared with
@var{alist}, not copied.  @code{del-assq} uses @code{eq?} to compare
@var{object} with the keys, while @code{del-assv} uses @code{eqv?} and
@code{del-assoc} uses @code{equal?}.

@example
@group
(define a
  '((butcher . "231 e22nd St.")
    (baker . "515 w23rd St.")
    (hardware . "988 Lexington Ave.")))

(del-assq 'baker a)
     @result{}
     ((butcher . "231 e22nd St.")
      (hardware . "988 Lexington Ave."))
@end group
@end example
@end deffn

@deffn {procedure+} del-assq! object alist
@deffnx {procedure+} del-assv! object alist
@deffnx {procedure+} del-assoc! object alist
@findex eq?
@findex eqv?
@findex equal?
These procedures remove from @var{alist} all associations with keys
equal to @var{object}.  They return the resulting list.
@code{del-assq!} uses @code{eq?} to compare @var{object} with the keys,
while @code{del-assv!} uses @code{eqv?} and @code{del-assoc!} uses
@code{equal?}.  These procedures are like @code{del-assq},
@code{del-assv}, and @code{del-assoc}, respectively, except that they
destructively modify @var{alist}.
@end deffn

@deffn {procedure+} delete-association-procedure deletor predicate selector
@findex list-deletor
@findex list-deletor!
This returns a deletion procedure similar to @code{del-assv} or
@code{del-assq!}.  The @var{predicate} and @var{selector} arguments are
the same as those for @code{association-procedure}, while the
@var{deletor} argument should be either the procedure
@code{list-deletor} (for non-destructive deletions), or the procedure
@code{list-deletor!} (for destructive deletions).

For example, here is a possible implementation of @code{del-assv}:

@example
@group
(define del-assv 
  (delete-association-procedure list-deletor eqv? car))
@end group
@end example
@end deffn

@deffn {procedure+} alist-copy alist
@cindex copying, of alist
@findex list-copy
Returns a newly allocated copy of @var{alist}.  This is similar to
@code{list-copy} except that the ``association'' pairs, i.e.@: the
elements of the list @var{alist}, are also copied.  @code{alist-copy}
could have been implemented like this:

@example
@group
(define (alist-copy alist)
  (if (null? alist)
      '()
      (cons (cons (car (car alist)) (cdr (car alist)))
            (alist-copy (cdr alist)))))
@end group
@end example
@end deffn

@node 1D Tables, The Association Table, Association Lists, Associations
@section 1D Tables

@cindex 1D table (defn)
@cindex one-dimensional table (defn)
@cindex table, one-dimensional (defn)
@cindex weak pair, and 1D table
@dfn{1D tables} (``one-dimensional'' tables) are similar to association
lists.  In a 1D table, unlike an association list, the keys of the table
are held @dfn{weakly}: if a key is garbage-collected, its associated
value in the table is removed.  1D tables compare their keys for
equality using @code{eq?}.

@cindex property list
1D tables can often be used as a higher-performance alternative to the
two-dimensional association table (@pxref{The Association Table}).  If
one of the keys being associated is a compound object such as a vector,
a 1D table can be stored in one of the vector's slots.  Under these
circumstances, accessing items in a 1D table will be comparable in
performance to using a property list in a conventional Lisp.

@deffn {procedure+} make-1d-table
Returns a newly allocated empty 1D table.
@end deffn

@deffn {procedure+} 1d-table? object
@cindex type predicate, for 1D table
@findex list?
Returns @code{#t} if @var{object} is a 1D table, otherwise returns
@code{#f}.  Any object that satisfies this predicate also satisfies
@code{list?}.
@end deffn

@deffn {procedure+} 1d-table/put! 1d-table key datum
Creates an association between @var{key} and @var{datum} in
@var{1d-table}.  Returns an unspecified value.
@end deffn

@deffn {procedure+} 1d-table/remove! 1d-table key
Removes any association for @var{key} in @var{1d-table} and returns an
unspecified value.
@end deffn

@deffn {procedure+} 1d-table/get 1d-table key default
Returns the @var{datum} associated with @var{key} in @var{1d-table}.  If
there is no association for @var{key}, @var{default} is returned.
@end deffn

@deffn {procedure+} 1d-table/lookup 1d-table key if-found if-not-found
@var{If-found} must be a procedure of one argument, and
@var{if-not-found} must be a procedure of no arguments.  If
@var{1d-table} contains an association for @var{key}, @var{if-found} is
invoked on the @var{datum} of the association.  Otherwise,
@var{if-not-found} is invoked with no arguments.  In either case, the
result of the invoked procedure is returned as the result of
@code{1d-table/lookup}.
@end deffn

@deffn {procedure+} 1d-table/alist 1d-table
Returns a newly allocated association list that contains the same
information as @var{1d-table}.
@end deffn

@node The Association Table, Hash Tables, 1D Tables, Associations
@section The Association Table

@cindex association table (defn)
@cindex table, association (defn)
@cindex property list
@findex eq?
MIT Scheme provides a generalization of the property-list mechanism
found in most other implementations of Lisp: a global two-dimensional
@dfn{association table}.  This table is indexed by two keys, called
@var{x-key} and @var{y-key} in the following procedure descriptions.
These keys and the datum associated with them can be arbitrary objects.
@code{eq?} is used to discriminate keys.

Think of the association table as a matrix: a single datum can be
accessed using both keys, a column using @var{x-key} only, and a row
using @var{y-key} only.

@deffn {procedure+} 2d-put! x-key y-key datum
Makes an entry in the association table that associates @var{datum} with
@var{x-key} and @var{y-key}.  Returns an unspecified result.
@end deffn

@deffn {procedure+} 2d-remove! x-key y-key
If the association table has an entry for @var{x-key} and @var{y-key},
it is removed.  Returns an unspecified result.
@end deffn

@deffn {procedure+} 2d-get x-key y-key
Returns the @var{datum} associated with @var{x-key} and @var{y-key}.
Returns @code{#f} if no such association exists.
@end deffn

@deffn {procedure+} 2d-get-alist-x x-key
Returns an association list of all entries in the association table that
are associated with @var{x-key}.  The result is a list of
@code{(@var{y-key} . @var{datum})} pairs.  Returns the empty list if no
entries for @var{x-key} exist.

@example
@group
(2d-put! 'foo 'bar 5)
(2d-put! 'foo 'baz 6)
(2d-get-alist-x 'foo)                   @result{}  ((baz . 6) (bar . 5))
@end group
@end example
@end deffn

@deffn {procedure+} 2d-get-alist-y y-key
Returns an association list of all entries in the association table that
are associated with @var{y-key}.  The result is a list of
@code{(@var{x-key} . @var{datum})} pairs.  Returns the empty list if no
entries for @var{y-key} exist.

@example
@group
(2d-put! 'bar 'foo 5)
(2d-put! 'baz 'foo 6)
(2d-get-alist-y 'foo)                   @result{}  ((baz . 6) (bar . 5))
@end group
@end example
@end deffn

@node Hash Tables, Object Hashing, The Association Table, Associations
@section Hash Tables

@cindex hash table
Hash tables are a fast, powerful mechanism for storing large numbers of
associations.  MIT Scheme's hash tables feature automatic resizing,
customizable growth parameters, and customizable hash procedures.

The average times for the insertion, deletion, and lookup operations on
a hash table are bounded by a constant.  The space required by the table
is proportional to the number of associations in the table; the
constant of proportionality is described below (@pxref{Resizing of Hash
Tables}).

@cindex run-time-loadable option
@cindex option, run-time-loadable
The hash-table implementation is a run-time-loadable option.  To use
hash tables, execute

@example
(load-option 'hash-table)
@end example
@findex load-option

@noindent
once before calling any of the procedures defined here.

@menu
* Construction of Hash Tables::  
* Basic Hash Table Operations::  
* Resizing of Hash Tables::     
* Address Hashing::             
* Low-Level Hash Table Operations::  
@end menu

@node Construction of Hash Tables, Basic Hash Table Operations,  , Hash Tables
@subsection Construction of Hash Tables

@cindex construction, of hash table
The next few procedures are hash-table constructors.  All hash table
constructors are procedures that accept one optional argument,
@var{initial-size}, and return a newly allocated hash table.  If
@var{initial-size} is given, it must be an exact non-negative integer or
@code{#f}.  The meaning of @var{initial-size} is discussed below
(@pxref{Resizing of Hash Tables}).

@cindex equivalence predicate, of hash table
@cindex strongly held keys, of hash table
@cindex weakly held keys, of hash table
Hash tables are normally characterized by two things: the equivalence
predicate that is used to compare keys, and whether or not the table
allows its keys to be reclaimed by the garbage collector.  If a table
prevents its keys from being reclaimed by the garbage collector, it is
said to hold its keys @dfn{strongly}; otherwise it holds its keys
@dfn{weakly} (@pxref{Weak Pairs}).

@deffn {procedure+} make-eq-hash-table [initial-size]
@findex eq?
Returns a newly allocated hash table that accepts arbitrary objects as
keys, and compares those keys with @code{eq?}.  The keys are held
weakly.  These are the fastest of the standard hash tables.

@findex make-symbol-hash-table
For compatibility with old code, @code{make-symbol-hash-table} is a
synonym for this procedure.
@end deffn

@deffn {procedure+} make-eqv-hash-table [initial-size]
@findex eqv?
Returns a newly allocated hash table that accepts arbitrary objects as
keys, and compares those keys with @code{eqv?}.  The keys are held
weakly, except that booleans, characters, and numbers are held strongly.
These hash tables are a little slower than those made by
@code{make-eq-hash-table}.

@findex make-object-hash-table
For compatibility with old code, @code{make-object-hash-table} is a
synonym for this procedure.
@end deffn

@deffn {procedure+} make-equal-hash-table [initial-size]
@findex equal?
Returns a newly allocated hash table that accepts arbitrary objects as
keys, and compares those keys with @code{equal?}.  The keys are held
strongly.  These hash tables are quite a bit slower than those made by
@code{make-eq-hash-table}.
@end deffn

@deffn {procedure+} make-string-hash-table [initial-size]
@findex string=?
Returns a newly allocated hash table that accepts character strings as
keys, and compares them with @code{string=?}.  The keys are held
strongly.
@end deffn

The next two procedures are used to create new hash-table constructors.
All of the above hash table constructors, with the exception of
@code{make-eqv-hash-table}, could have been created by calls to these
``constructor-constructors''; see the examples below.

@deffn {procedure+} strong-hash-table/constructor key-hash key=? [rehash-after-gc?]
@deffnx {procedure+} weak-hash-table/constructor key-hash key=? [rehash-after-gc?]
@cindex hashing, of key in hash table
@cindex modulus, of hashing procedure
Each of these procedures accepts two arguments and returns a hash-table
constructor.  The @var{key=?} argument is an equivalence predicate for
the keys of the hash table.  The @var{key-hash} argument is a procedure
that computes a hash number.  Specifically, @var{key-hash} accepts two
arguments, a key and an exact positive integer (the @dfn{modulus}), and
returns an exact non-negative integer that is less than the modulus.

The optional argument @var{rehash-after-gc?}, if true, says that the
values returned by @var{key-hash} might change after a garbage
collection.  If so, the hash-table implementation arranges for the table
to be rehashed when necessary.  (@pxref{Address Hashing}, for
information about hash procedures that have this property.)  Otherwise,
it is assumed that @var{key-hash} always returns the same value for the
same arguments.  The default value of this argument is @code{#f}.

The constructors returned by @code{strong-hash-table/constructor} make
hash tables that hold their keys strongly.  The constructors returned by
@code{weak-hash-table/constructor} make hash tables that hold their keys
weakly.
@end deffn

Some examples showing how some standard hash-table constructors could have
been defined:

@findex eq-hash-mod
@findex eq?
@findex equal-hash-mod
@findex equal?
@findex string-hash-mod
@findex string=?
@example
(define make-eq-hash-table
  (weak-hash-table/constructor eq-hash-mod eq? #t))

(define make-equal-hash-table
  (strong-hash-table/constructor equal-hash-mod equal? #t))

(define make-string-hash-table
  (strong-hash-table/constructor string-hash-mod string=? #f))
@end example

The following procedure is sometimes useful in conjunction with weak
hash tables.  Normally it is not needed, because such hash tables clean
themselves automatically as they are used.

@deffn {procedure+} hash-table/clean! hash-table
If @var{hash-table} is a type of hash table that holds its @var{key}s
weakly, this procedure recovers any space that was being used to record
associations for objects that have been reclaimed by the garbage
collector.  Otherwise, this procedure does nothing.  In either case, it
returns an unspecified result.
@end deffn

@node Basic Hash Table Operations, Resizing of Hash Tables, Construction of Hash Tables, Hash Tables
@subsection Basic Hash Table Operations

The procedures described in this section are the basic operations on
hash tables.  They provide the functionality most often needed by
programmers.  Subsequent sections describe other operations that provide
additional functionality needed by some applications.

@deffn {procedure+} hash-table? object
@cindex type predicate, for hash table
Returns @code{#t} if @var{object} is a hash table, otherwise returns
@code{#f}.
@end deffn

@deffn {procedure+} hash-table/put! hash-table key datum
Associates @var{datum} with @var{key} in @var{hash-table} and returns an
unspecified result.  The average time required by this operation is
bounded by a constant.
@end deffn

@deffn {procedure+} hash-table/get hash-table key default
Returns the datum associated with @var{key} in @var{hash-table}.  If
there is no association for @var{key}, @var{default} is returned.  The
average time required by this operation is bounded by a constant.
@end deffn

@deffn {procedure+} hash-table/remove! hash-table key
If @var{hash-table} has an association for @var{key}, removes it.
Returns an unspecified result.  The average time required by this
operation is bounded by a constant.
@end deffn

@deffn {procedure+} hash-table/clear! hash-table
Removes all associations in @var{hash-table} and returns an unspecified
result.  The average and worst-case times required by this operation are
bounded by a constant.
@end deffn

@deffn {procedure+} hash-table/count hash-table
Returns the number of associations in @var{hash-table} as an exact
non-negative integer.  If @var{hash-table} holds its keys weakly, this
is a conservative upper bound that may count some associations whose
keys have recently been reclaimed by the garbage collector.  The average
and worst-case times required by this operation are bounded by a
constant.
@end deffn

@deffn {procedure+} hash-table->alist hash-table
Returns the contents of @var{hash-table} as a newly allocated alist.
Each element of the alist is a pair @code{(@var{key} . @var{datum})}
where @var{key} is one of the keys of @var{hash-table}, and @var{datum}
is its associated datum.  The average and worst-case times required by
this operation are linear in the number of associations
in the table.
@end deffn

@deffn {procedure+} hash-table/key-list hash-table
Returns a newly allocated list of the keys in @var{hash-table}.  The
average and worst-case times required by this operation are
proportional to the number of associations in the table.
@end deffn

@deffn {procedure+} hash-table/datum-list hash-table
Returns a newly allocated list of the datums in @var{hash-table}.  Each
element of the list corresponds to one of the associations in
@var{hash-table}; if the table contains multiple associations with the
same datum, so will this list.  The average and worst-case times
required by this operation are proportional to the number of
associations in the table.
@end deffn

@deffn {procedure+} hash-table/for-each hash-table procedure
@var{Procedure} must be a procedure of two arguments.  Invokes
@var{procedure} once for each association in @var{hash-table}, passing
the association's @var{key} and @var{datum} as arguments, in that order.
Returns an unspecified result.  @var{Procedure} must not modify
@var{hash-table}, with one exception: it is permitted to call
@code{hash-table/remove!} to remove the association being processed.
@end deffn

The following procedure is an alternate form of @code{hash-table/get}
that is useful in some situations.  Usually, @code{hash-table/get} is
preferable because it is faster.

@deffn {procedure+} hash-table/lookup hash-table key if-found if-not-found
@var{If-found} must be a procedure of one argument, and
@var{if-not-found} must be a procedure of no arguments.  If
@var{hash-table} contains an association for @var{key}, @var{if-found}
is invoked on the datum of the association.  Otherwise,
@var{if-not-found} is invoked with no arguments.  In either case, the
result yielded by the invoked procedure is returned as the result of
@code{hash-table/lookup} (@code{hash-table/lookup} @emph{reduces} into
the invoked procedure, i.e.@: calls it tail-recursively).  The average
time required by this operation is bounded by a constant.
@end deffn

@node Resizing of Hash Tables, Address Hashing, Basic Hash Table Operations, Hash Tables
@subsection Resizing of Hash Tables

@cindex resizing, of hash table
@cindex size, of hash table (defn)
Normally, hash tables automatically resize themselves according to need.
Because of this, the programmer need not be concerned with management of
the table's size.  However, some limited control over the table's size
is provided, which will be discussed below.  This discussion involves
two concepts, @dfn{usable size} and @dfn{physical size}, which we will
now define.

@cindex usable size, of hash table (defn)
The @dfn{usable size} of a hash table is the number of associations that
the table can hold at a given time.  If the number of associations in
the table exceeds the usable size, the table will automatically grow,
increasing the usable size to a new value that is sufficient to hold the
associations.

@cindex physical size, of hash table (defn)
The @dfn{physical size} is an abstract measure of a hash table that
specifies how much space is allocated to hold the associations of the
table.  The physical size is always greater than or equal to the usable
size.  The physical size is not interesting in itself; it is interesting
only for its effect on the performance of the hash table.  While the
average performance of a hash-table lookup is bounded by a constant, the
worst-case performance is not.  For a table containing a given number of
associations, increasing the physical size of the table decreases the
probability that worse-than-average performance will occur.

The physical size of a hash table is statistically related to the number
of associations.  However, it is possible to place bounds on the
physical size, and from this to estimate the amount of space used by the
table:

@example
(define (hash-table-space-bounds count rehash-size rehash-threshold)
  (let ((tf (/ 1 rehash-threshold)))
    (values (if (exact-integer? rehash-size)
                (- (* count (+ 4 tf))
                   (* tf (+ rehash-size rehash-size)))
                (* count (+ 4 (/ tf (* rehash-size rehash-size)))))
            (* count (+ 4 tf)))))
@end example

@noindent
What this formula shows is that, for a ``normal'' rehash size (that is,
not an exact integer), the amount of space used by the hash table is
proportional to the number of associations in the table.  The constant
of proportionality varies statistically, with the low bound being

@example
(+ 4 (/ (/ 1 rehash-threshold) (* rehash-size rehash-size)))
@end example

@noindent
and the high bound being

@example
(+ 4 (/ 1 rehash-threshold))
@end example

@noindent
which, for the default values of these parameters, are @code{4.25} and
@code{5}, respectively.  Reducing the rehash size will tighten these
bounds, but increases the amount of time spent resizing, so you can see
that the rehash size gives some control over the time-space tradeoff of
the table.

The programmer can control the size of a hash table by means of three
parameters:

@itemize @bullet
@item
Each table's @var{initial-size} may be specified when the table is
created.

@item
Each table has a @dfn{rehash size} that specifies how the size of the
table is changed when it is necessary to grow or shrink the table.

@item
Each table has a @dfn{rehash threshold} that specifies the relationship
of the table's physical size to its usable size.
@end itemize

@cindex initial size, of hash table
If the programmer knows that the table will initially contain a specific
number of items, @var{initial-size} can be given when the table is
created.  If @var{initial-size} is an exact non-negative integer, it
specifies the initial usable size of the hash table; the table will not
change size until the number of items in the table exceeds
@var{initial-size}, after which automatic resizing is enabled and
@var{initial-size} no longer has any effect.  Otherwise, if
@var{initial-size} is not given or is @code{#f}, the table is
initialized to an unspecified size and automatic resizing is immediately
enabled.

@cindex rehash size, of hash table (defn)
The @dfn{rehash size} specifies how much to increase the usable size of
the hash table when it becomes full.  It is either an exact positive
integer, or a real number greater than one.  If it is an integer, the
new size is the sum of the old size and the rehash size.  Otherwise, it
is a real number, and the new size is the product of the old size and
the rehash size.  Increasing the rehash size decreases the average cost
of an insertion, but increases the average amount of space used by the
table.  The rehash size of a table may be altered dynamically by the
application in order to optimize the resizing of the table; for example,
if the table will grow quickly for a known period and afterwards will
not change size, performance might be improved by using a large rehash
size during the growth phase and a small one during the static phase.
The default rehash size of a newly constructed hash table is @code{2.0}.

@strong{Note well:} The use of an exact positive integer for a rehash
size is almost always undesirable; this option is provided solely for
compatibility with the Common Lisp hash-table mechanism.  The reason for
this has to do with the time penalty for resizing the hash table.  The
time needed to resize a hash table is proportional to the
number of associations in the table.  This resizing cost is
@dfn{amortized} across the insertions required to fill the table to the
point where it needs to grow again.  If the table grows by an amount
proportional to the number of associations, then the cost of
resizing and the increase in size are both proportional to the
number of associations, so the @dfn{amortized cost} of an insertion
operation is still bounded by a constant.  However, if the table grows
by a constant amount, this is not true: the amortized cost of an
insertion is not bounded by a constant.  Thus, using a constant rehash
size means that the average cost of an insertion increases
proportionally to the number of associations in the hash table.

@cindex rehash threshold, of hash table (defn)
The @dfn{rehash threshold} is a real number, between zero exclusive and
one inclusive, that specifies the ratio between a hash table's usable
size and its physical size.  Decreasing the rehash threshold decreases
the probability of worse-than-average insertion, deletion, and lookup
times, but increases the physical size of the table for a given usable
size.  The default rehash threshold of a newly constructed hash table is
@code{1}.

@deffn {procedure+} hash-table/size hash-table
Returns the usable size of @var{hash-table} as an exact positive
integer.  This is the number of associations that @var{hash-table} can
hold before it will grow.
@end deffn

@deffn {procedure+} hash-table/rehash-size hash-table
Returns the rehash size of @var{hash-table}.
@end deffn

@deffn {procedure+} set-hash-table/rehash-size! hash-table x
@var{X} must be either an exact positive integer, or a real number that
is greater than one.  Sets the rehash size of @var{hash-table} to
@var{x} and returns an unspecified result.  This operation adjusts the
``shrink threshold'' of the table; the table might shrink if the number
of associations is less than the new threshold.
@end deffn

@deffn {procedure+} hash-table/rehash-threshold hash-table
Returns the rehash threshold of @var{hash-table}.
@end deffn

@deffn {procedure+} set-hash-table/rehash-threshold! hash-table x
@var{X} must be a real number between zero exclusive and one inclusive.
Sets the rehash threshold of @var{hash-table} to @var{x} and returns an
unspecified result.  This operation does not change the usable size of
the table, but it usually changes the physical size of the table, which
causes the table to be rehashed.
@end deffn

@node Address Hashing, Low-Level Hash Table Operations, Resizing of Hash Tables, Hash Tables
@subsection Address Hashing
@cindex address hashing

The procedures described in this section may be used to make very
efficient key-hashing procedures for arbitrary objects.  All of these
procedures are based on @dfn{address hashing}, which uses the address of
an object as its hash number.  The great advantage of address hashing is
that converting an arbitrary object to a hash number is extremely fast
and takes the same amount of time for any object.

The disadvantage of address hashing is that the garbage collector
changes the addresses of most objects.  The hash-table implementation
compensates for this disadvantage by automatically rehashing tables that
use address hashing when garbage collections occur.  Thus, in order to
use these procedures for key hashing, it is necessary to tell the
hash-table implementation (by means of the @var{rehash-after-gc?}
argument to the ``constructor-constructor'' procedure) that the hash
numbers computed by your key-hashing procedure must be recomputed after
a garbage collection.

@deffn {procedure+} eq-hash object
This procedure returns a hash number for @var{object}.  The result is
always a non-negative fixnum (and therefore an exact non-negative
integer).  Two objects that are @code{eq?} to one another map to the
same hash number, provided that the garbage collector does not run
during or between the two calls to @code{eq-hash}.
@end deffn

The following procedures are the key-hashing procedures used by the
standard address-hash-based hash tables.

@deffn {procedure+} eq-hash-mod object modulus
This procedure is the key-hashing procedure used by
@code{make-eq-hash-table}.
@end deffn

@deffn {procedure+} eqv-hash-mod object modulus
This procedure is the key-hashing procedure used by
@code{make-eqv-hash-table}.
@end deffn

@deffn {procedure+} equal-hash-mod object modulus
This procedure is the key-hashing procedure used by
@code{make-equal-hash-table}.
@end deffn

@node Low-Level Hash Table Operations,  , Address Hashing, Hash Tables
@subsection Low-Level Hash Table Operations

The procedures in this section allow the programmer to control some of
the internal structure of a hash table.  Normally, hash tables maintain
associations between keys and datums using pairs or weak pairs.  These
procedures allow the programmer to specify the use of some other data
structure to maintain the association.  In this section, the data
structure that represents an association in a hash table is called an
@dfn{entry}.

@deffn {procedure+} hash-table/constructor key-hash key=? make-entry entry-valid? entry-key entry-datum set-entry-datum! [rehash-after-gc?]
Creates and returns a hash-table constructor procedure
(@pxref{Construction of Hash Tables}).  The arguments to
@code{hash-table/constructor} define the characteristics of the hash
table as follows:

@table @var
@item key-hash
The hashing procedure.  A procedure that accepts two arguments, a key and
an exact positive integer (the @dfn{modulus}), and returns an exact
non-negative integer that is less than the modulus.

@item key=?
A equivalence predicate that accepts two keys and is true iff they are
the same key.  If this predicate is true of two keys, then
@var{key-hash} must return the same value for each of these keys (given
the same modulus in both cases).

@item make-entry
A procedure that accepts a key and a datum as arguments and returns a
newly allocated entry.

@item entry-valid?
A procedure that accepts an entry and returns @code{#f} iff the entry's
key has been reclaimed by the garbage collector.  Instead of a
procedure, this may be @code{#t}, which is equivalent to @code{(lambda
(entry) #t)}.
@findex weak-pair/car?

@item entry-key
A procedure that accepts an entry as an argument and returns the entry's
key.

@item entry-datum
A procedure that accepts an entry as an argument and returns the entry's
datum.

@item set-entry-datum!
A procedure that accepts an entry and an object as arguments, modifies
the entry's datum to be the object, and returns an unspecified
result.

@item rehash-after-gc?
An optional argument that, if true, says the values returned by
@var{key-hash} might change after a garbage collection.  If so, the
hash-table implementation arranges for the table to be rehashed when
necessary.  (@pxref{Address Hashing}, for information about hash
procedures that have this property.)  Otherwise, it is assumed that
@var{key-hash} always returns the same value for the same arguments.
The default value of this argument is @code{#f}.
@end table

For example, here is how the constructors for ordinary hash tables could
be defined:

@example
@group
(define (strong-hash-table/constructor key-hash key=?
                                       #!optional rehash-after-gc?)
  (hash-table/constructor key-hash key=? cons #t car cdr set-cdr!
                          (if (default-object? rehash-after-gc?)
                              #f
                              rehash-after-gc?)))
@end group

@group
(define (weak-hash-table/constructor key-hash key=?
                                     #!optional rehash-after-gc?)
  (hash-table/constructor key-hash key=? weak-cons weak-pair/car?
                          weak-car weak-cdr weak-set-cdr!
                          (if (default-object? rehash-after-gc?)
                              #f
                              rehash-after-gc?)))
@end group
@end example
@end deffn

@deffn {procedure+} hash-table/key-hash hash-table
@deffnx {procedure+} hash-table/key=? hash-table
@deffnx {procedure+} hash-table/make-entry hash-table
@deffnx {procedure+} hash-table/entry-valid? hash-table
@deffnx {procedure+} hash-table/entry-key hash-table
@deffnx {procedure+} hash-table/entry-datum hash-table
@deffnx {procedure+} hash-table/set-entry-datum! hash-table
Each of these procedures corresponds to an argument of
@code{hash-table/constructor}.  When called, each procedure returns the
value of the corresponding argument that was used to construct
@var{hash-table}.
@end deffn

The following procedures return the contents of a hash table as a
collection of entries.  While the data structure holding the entries is
newly allocated, the entries themselves are not copied.  Since hash
table operations can modify these entries, the entries should be copied
if it is desired to keep them while continuing to modify the table.

@deffn {procedure+} hash-table/entries-list hash-table
Returns a newly allocated list of the entries in @var{hash-table}.
@end deffn

@deffn {procedure+} hash-table/entries-vector hash-table
Returns a newly allocated vector of the entries in @var{hash-table}.
Equivalent to

@example
(list->vector (hash-table/entries-list @var{hash-table}))
@end example
@end deffn

@node Object Hashing, Red-Black Trees, Hash Tables, Associations
@section Object Hashing

@cindex object hashing
@cindex hashing, of object
The MIT Scheme object-hashing facility provides a mechanism for
generating a unique hash number for an arbitrary object.  This hash
number, unlike an object's address, is unchanged by garbage collection.
The object-hashing facility is useful in conjunction with hash tables,
but it may be used for other things as well.  In particular, it is used
in the generation of the written representation for some objects
(@pxref{Custom Output}).

All of these procedures accept an optional argument called @var{table};
this table contains the object-integer associations.  If given, this
argument must be an object-hash table as constructed by
@code{hash-table/make} (see below).  If not given, a default table is
used.

@deffn {procedure+} hash object [table]
@findex eq?
@code{hash} associates an exact non-negative integer with @var{object}
and returns that integer.  If @code{hash} was previously called with
@var{object} as its argument, the integer returned is the same as was
returned by the previous call.  @code{hash} guarantees that distinct
objects (in the sense of @code{eq?}) are associated with distinct
integers.
@end deffn

@deffn {procedure+} unhash k [table]
@code{unhash} takes an exact non-negative integer @var{k} and returns
the object associated with that integer.  If there is no object
associated with @var{k}, or if the object previously associated with
@var{k} has been reclaimed by the garbage collector, an error of type
@code{condition-type:bad-range-argument} is signalled.  In other words,
if @code{hash} previously returned @var{k} for some object, and that
object has not been reclaimed, it is the value of the call to
@code{unhash}.
@findex condition-type:bad-range-argument
@end deffn

An object that is passed to @code{hash} as an argument is not protected
from being reclaimed by the garbage collector.  If all other references
to that object are eliminated, the object will be reclaimed.
Subsequently calling @code{unhash} with the hash number of the (now
reclaimed) object will signal an error.

@example
@group
(define x (cons 0 0))           @result{}  @r{unspecified}
(hash x)                        @result{}  77
(eqv? (hash x) (hash x))        @result{}  #t
(define x 0)                    @result{}  @r{unspecified}
(gc-flip)                       @r{;force a garbage collection}
(unhash 77)                     @error{}
@end group
@end example

@deffn {procedure+} object-hashed? object [table]
This predicate is true if @var{object} has an associated hash number.
Otherwise it is false.
@end deffn

@deffn {procedure+} valid-hash-number? k [table]
This predicate is true if @var{k} is the hash number associated with
some object.  Otherwise it is false.
@end deffn

The following two procedures provide a lower-level interface to the
object-hashing mechanism.

@deffn {procedure+} object-hash object [table [insert?]]
@findex eq?
@code{object-hash} is like @code{hash}, except that it accepts an
additional optional argument, @var{insert?}.  If @var{insert?} is
supplied and is @code{#f}, @code{object-hash} will return an integer for
@var{object} only if there is already an association in the table;
otherwise, it will return @code{#f}.  If @var{insert?} is not supplied,
or is not @code{#f}, @code{object-hash} always returns an integer,
creating an association in the table if necessary.

@code{object-hash} additionally treats @code{#f} differently than does
@code{hash}.  Calling @code{object-hash} with @code{#f} as its argument
will return an integer that, when passed to @code{unhash}, will signal
an error rather than returning @code{#f}.  Likewise,
@code{valid-hash-number?} will return @code{#f} for this integer.
@end deffn

@deffn {procedure+} object-unhash k [table]
@code{object-unhash} is like @code{unhash}, except that when @var{k} is
not associated with any object or was previously associated with an
object that has been reclaimed, @code{object-unhash} returns @code{#f}.
This means that there is an ambiguity in the value returned by
@code{object-unhash}: if @code{#f} is returned, there is no way to
tell if @var{k} is associated with @code{#f} or is not associated with
any object at all.
@end deffn

Finally, this procedure makes new object-hash tables:

@deffn {procedure+} hash-table/make
This procedure creates and returns a new, empty object-hash table that
is suitable for use as the optional @var{table} argument to the above
procedures.  The returned table contains no associations.
@end deffn

@node Red-Black Trees, Weight-Balanced Trees, Object Hashing, Associations
@section Red-Black Trees

@cindex trees, balanced binary
@cindex balanced binary trees
@cindex binary trees
@cindex red-black binary trees
Balanced binary trees are a useful data structure for maintaining large
sets of associations whose keys are ordered.  While most applications
involving large association sets should use hash tables, some
applications can benefit from the use of binary trees.  Binary trees
have two advantages over hash tables:

@itemize @bullet
@item
The contents of a binary tree can be converted to an alist, sorted by
key, in time proportional to the number of associations in the
tree.  A hash table can be converted into an unsorted alist in linear
time; sorting it requires additional time.

@item
Two binary trees can be compared for equality in linear time.  Hash
tables, on the other hand, cannot be compared at all; they must be
converted to alists before comparison can be done, and alist comparison
is quadratic unless the alists are sorted.
@end itemize

MIT Scheme provides an implementation of @dfn{red-black} trees.  The
red-black tree-balancing algorithm provides generally good performance
because it doesn't try to keep the tree very closely balanced.  At any
given node in the tree, one side of the node can be twice as high as the
other in the worst case.  With typical data the tree will remain fairly
well balanced anyway.

A red-black tree takes space that is proportional to the number of
associations in the tree.  For the current implementation, the constant
of proportionality is eight words per association.

Red-black trees hold their keys @dfn{strongly}.  In other words, if a
red-black tree contains an association for a given key, that key cannot
be reclaimed by the garbage collector.

@cindex run-time-loadable option
@cindex option, run-time-loadable
The red-black tree implementation is a run-time-loadable option.  To use
red-black trees, execute

@example
(load-option 'rb-tree)
@end example
@findex load-option

@noindent
once before calling any of the procedures defined here.

@deffn {procedure+} make-rb-tree key=? key<?
This procedure creates and returns a newly allocated red-black tree.
The tree contains no associations.  @var{Key=?} and @var{key<?} are
predicates that compare two keys and determine whether they are equal to
or less than one another, respectively.  For any two keys, at most one
of these predicates is true.
@end deffn

@deffn {procedure+} rb-tree? object
Returns @code{#t} if @var{object} is a red-black tree, otherwise
returns @code{#f}.
@end deffn

@deffn {procedure+} rb-tree/insert! rb-tree key datum
Associates @var{datum} with @var{key} in @var{rb-tree} and returns an
unspecified value.  If @var{rb-tree} already has an association for
@var{key}, that association is replaced.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of assocations in @var{rb-tree}.
@end deffn

@deffn {procedure+} rb-tree/lookup rb-tree key default
Returns the datum associated with @var{key} in @var{rb-tree}.  If
@var{rb-tree} doesn't contain an association for @var{key},
@var{default} is returned.  The average and worst-case times required by
this operation are proportional to the logarithm of the number of
assocations in @var{rb-tree}.
@end deffn

@deffn {procedure+} rb-tree/delete! rb-tree key
If @var{rb-tree} contains an association for @var{key}, removes it.
Returns an unspecified value.  The average and worst-case times required
by this operation are proportional to the logarithm of the number of
assocations in @var{rb-tree}.
@end deffn

@deffn {procedure+} rb-tree->alist rb-tree
Returns the contents of @var{rb-tree} as a newly allocated alist.  Each
element of the alist is a pair @code{(@var{key} . @var{datum})} where
@var{key} is one of the keys of @var{rb-tree}, and @var{datum} is its
associated datum.  The alist is sorted by key according to the
@var{key<?} argument used to construct @var{rb-tree}.  The
time required by this operation is proportional to the
number of associations in the tree.
@end deffn

@deffn {procedure+} rb-tree/key-list rb-tree
Returns a newly allocated list of the keys in @var{rb-tree}.  The list
is sorted by key according to the @var{key<?} argument used to construct
@var{rb-tree}.  The time required by this
operation is proportional to the number of associations in the tree.
@end deffn

@deffn {procedure+} rb-tree/datum-list rb-tree
Returns a newly allocated list of the datums in @var{rb-tree}.  Each
element of the list corresponds to one of the associations in
@var{rb-tree}, so if the tree contains multiple associations with the
same datum, so will this list.  The list is sorted by the keys of the
associations, even though they do not appear in the result.  The time required by this operation is proportional to the
number of associations in the tree.

This procedure is equivalent to:

@example
(lambda (rb-tree) (map cdr (rb-tree->alist rb-tree)))
@end example
@end deffn

@deffn {procedure+} rb-tree/equal? rb-tree-1 rb-tree-2 datum=?
Compares @var{rb-tree-1} and @var{rb-tree-2} for equality, returning
@code{#t} iff they are equal and @code{#f} otherwise.  The trees must
have been constructed with the same equality and order predicates (same
in the sense of @code{eq?}).  The keys of the trees are compared using
the @var{key=?} predicate used to build the trees, while the datums of
the trees are compared using the equivalence predicate @var{datum=?}.
The worst-case time required by this operation is proportional to the
number of associations in the tree.
@end deffn

@deffn {procedure+} rb-tree/empty? rb-tree
Returns @code{#t} iff @var{rb-tree} contains no associations.  Otherwise
returns @code{#f}.
@end deffn

@deffn {procedure+} rb-tree/size rb-tree
Returns the number of associations in @var{rb-tree}, an exact
non-negative integer.  The average and worst-case times required by this
operation are proportional to the number of associations in the tree.
@end deffn

@deffn {procedure+} rb-tree/height rb-tree
Returns the height of @var{rb-tree}, an exact non-negative integer.
This is the length of the longest path from a leaf of the tree to the
root.  The average and worst-case times required by this operation are
proportional to the number of associations in the tree.

The returned value satisfies the following:

@example
(lambda (rb-tree)
  (let ((size (rb-tree/size rb-tree))
        (lg (lambda (x) (/ (log x) (log 2)))))
    (<= (lg size)
        (rb-tree/height rb-tree)
        (* 2 (lg (+ size 1))))))
@end example
@end deffn

@deffn {procedure+} rb-tree/copy rb-tree
Returns a newly allocated copy of @var{rb-tree}.  The copy is identical
to @var{rb-tree} in all respects, except that changes to @var{rb-tree}
do not affect the copy, and vice versa.  The time required by this
operation is proportional to the number of associations in the tree.
@end deffn

@deffn {procedure+} alist->rb-tree alist key=? key<?
Returns a newly allocated red-black tree that contains the same
associations as @var{alist}.  This procedure is equivalent to:

@example
(lambda (alist key=? key<?)
  (let ((tree (make-rb-tree key=? key<?)))
    (for-each (lambda (association)
                (rb-tree/insert! tree
                                 (car association)
                                 (cdr association)))
              alist)
    tree))
@end example
@end deffn

@node Weight-Balanced Trees,  , Red-Black Trees, Associations
@section Weight-Balanced Trees

@cindex trees, balanced binary
@cindex balanced binary trees
@cindex binary trees
@cindex weight-balanced binary trees
Balanced binary trees are a useful data structure for maintaining large
sets of ordered objects or sets of associations whose keys are ordered.
MIT Scheme has an comprehensive implementation of weight-balanced binary
trees which has several advantages over the other data structures for
large aggregates:

@itemize @bullet
@item
In addition to the usual element-level operations like insertion,
deletion and lookup, there is a full complement of collection-level
operations, like set intersection, set union and subset test, all of
which are implemented with good orders of growth in time and space.
This makes weight balanced trees ideal for rapid prototyping of
functionally derived specifications.

@item
An element in a tree may be indexed by its position under the ordering
of the keys, and the ordinal position of an element may be determined,
both with reasonable efficiency.

@item
Operations to find and remove minimum element make weight balanced trees
simple to use for priority queues.

@item
The implementation is @emph{functional} rather than @emph{imperative}.
This means that operations like `inserting' an association in a tree do
not destroy the old tree, in much the same way that @code{(+ 1 x)}
modifies neither the constant 1 nor the value bound to @code{x}.  The
trees are referentially transparent thus the programmer need not worry
about copying the trees.  Referential transparency allows space
efficiency to be achieved by sharing subtrees.

@end itemize

These features make weight-balanced trees suitable for a wide range of
applications, especially those that
require large numbers of sets or discrete maps.  Applications that have
a few global databases and/or concentrate on element-level operations like
insertion and lookup are probably better off using hash-tables or
red-black trees.

The @emph{size} of a tree is the number of associations that it
contains.  Weight balanced binary trees are balanced to keep the sizes
of the subtrees of each node within a constant factor of each other.
This ensures logarithmic times for single-path operations (like lookup
and insertion).  A weight balanced tree takes space that is proportional
to the number of associations in the tree.  For the current
implementation, the constant of proportionality is six words per
association.

@cindex binary trees, as sets
@cindex binary trees, as discrete maps
@cindex sets, using binary trees
@cindex discrete maps, using binary trees
Weight balanced trees can be used as an implementation for either
discrete sets or discrete maps (associations).  Sets are implemented by
ignoring the datum that is associated with the key.  Under this scheme
if an associations exists in the tree this indicates that the key of the
association is a member of the set.  Typically a value such as
@code{()}, @code{#t} or @code{#f} is associated with the key.

Many operations can be viewed as computing a result that, depending on
whether the tree arguments are thought of as sets or maps, is known by
two different names.
An example is @code{wt-tree/member?}, which, when
regarding the tree argument as a set, computes the set membership operation, but,
when regarding the tree as a discrete map, @code{wt-tree/member?} is the
predicate testing if the map is defined at an element in its domain.
Most names in this package have been chosen based on interpreting the
trees as sets, hence the name @code{wt-tree/member?} rather than
@code{wt-tree/defined-at?}.


@cindex run-time-loadable option
@cindex option, run-time-loadable
The weight balanced tree implementation is a run-time-loadable option.
To use weight balanced trees, execute

@example
(load-option 'wt-tree)
@end example
@findex load-option

@noindent
once before calling any of the procedures defined here.


@menu
* Construction of Weight-Balanced Trees::  
* Basic Operations on Weight-Balanced Trees::  
* Advanced Operations on Weight-Balanced Trees::  
* Indexing Operations on Weight-Balanced Trees::  
@end menu

@node Construction of Weight-Balanced Trees, Basic Operations on Weight-Balanced Trees,  , Weight-Balanced Trees
@subsection Construction of Weight-Balanced Trees

Binary trees require there to be a total order on the keys used to
arrange the elements in the tree.  Weight balanced trees are organized
by @emph{types}, where the type is an object encapsulating the ordering
relation.  Creating a tree is a two-stage process.  First a tree type
must be created from the predicate which gives the ordering.  The tree type
is then used for making trees, either empty or singleton trees or trees
from other aggregate structures like association lists.  Once created, a
tree `knows' its type and the type is used to test compatibility between
trees in operations taking two trees.  Usually a small number of tree
types are created at the beginning of a program and used many times
throughout the program's execution.

@deffn {procedure+} make-wt-tree-type key<?
This procedure creates and returns a new tree type based on the ordering
predicate @var{key<?}.
@var{Key<?} must be a total ordering, having the property that for all
key values @code{a}, @code{b} and @code{c}:

@example
(key<? a a)                         @result{} #f
(and (key<? a b) (key<? b a))       @result{} #f
(if (and (key<? a b) (key<? b c))
    (key<? a c)
    #t)                             @result{} #t
@end example

@noindent
Two key values are assumed to be equal if neither is less than the other
by @var{key<?}.

Each call to @code{make-wt-tree-type} returns a distinct value, and
trees are only compatible if their tree types are @code{eq?}.
A consequence is 
that trees that are intended to be used in binary tree operations must all be
created with a tree type originating from the same call to
@code{make-wt-tree-type}.
@end deffn

@defvr {variable+} number-wt-type
A standard tree type for trees with numeric keys.  @code{Number-wt-type}
could have been defined by

@example
(define number-wt-type (make-wt-tree-type  <))
@end example
@end defvr

@defvr {variable+} string-wt-type
A standard tree type for trees with string keys.  @code{String-wt-type}
could have been defined by

@example
(define string-wt-type (make-wt-tree-type  string<?))
@end example
@end defvr



@deffn {procedure+} make-wt-tree wt-tree-type
This procedure creates and returns a newly allocated weight balanced
tree.  The tree is empty, i.e. it contains no associations.
@var{Wt-tree-type} is a weight balanced tree type obtained by calling
@code{make-wt-tree-type}; the returned tree has this type.
@end deffn

@deffn {procedure+} singleton-wt-tree wt-tree-type key datum
This procedure creates and returns a newly allocated weight balanced
tree.  The tree contains a single association, that of @var{datum} with
@var{key}.  @var{Wt-tree-type} is a weight balanced tree type obtained
by calling @code{make-wt-tree-type}; the returned tree has this type.
@end deffn

@deffn {procedure+} alist->wt-tree tree-type alist
Returns a newly allocated weight-balanced tree that contains the same
associations as @var{alist}.  This procedure is equivalent to:

@example
(lambda (type alist)
  (let ((tree (make-wt-tree type)))
    (for-each (lambda (association)
                (wt-tree/add! tree
                              (car association)
                              (cdr association)))
              alist)
    tree))
@end example
@end deffn



@node Basic Operations on Weight-Balanced Trees, Advanced Operations on Weight-Balanced Trees, Construction of Weight-Balanced Trees, Weight-Balanced Trees
@subsection Basic Operations on Weight-Balanced Trees

This section describes the basic tree operations on weight balanced
trees.  These operations are the usual tree operations for insertion,
deletion and lookup, some predicates and a procedure for determining the
number of associations in a tree.

@deffn {procedure+} wt-tree? object
Returns @code{#t} if @var{object} is a weight-balanced tree, otherwise
returns @code{#f}.
@end deffn

@deffn {procedure+} wt-tree/empty? wt-tree
Returns @code{#t} if @var{wt-tree} contains no associations, otherwise
returns @code{#f}.
@end deffn

@deffn {procedure+} wt-tree/size wt-tree
Returns the number of associations in @var{wt-tree}, an exact
non-negative integer.  This operation takes constant time.
@end deffn


@deffn {procedure+} wt-tree/add wt-tree key datum
Returns a new tree containing all the associations in @var{wt-tree} and
the association of @var{datum} with @var{key}.  If @var{wt-tree} already
had an association for @var{key}, the new association overrides the old.
The average and worst-case times required by this operation are
proportional to the logarithm of the number of associations in
@var{wt-tree}.
@end deffn

@deffn {procedure+} wt-tree/add! wt-tree key datum
Associates @var{datum} with @var{key} in @var{wt-tree} and returns an
unspecified value.  If @var{wt-tree} already has an association for
@var{key}, that association is replaced.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of associations in @var{wt-tree}.
@end deffn

@deffn {procedure+} wt-tree/member? key wt-tree
Returns @code{#t} if @var{wt-tree} contains an association for
@var{key}, otherwise returns @code{#f}.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of associations in @var{wt-tree}.
@end deffn

@deffn {procedure+} wt-tree/lookup wt-tree key default
Returns the datum associated with @var{key} in @var{wt-tree}.  If
@var{wt-tree} doesn't contain an association for @var{key},
@var{default} is returned.  The average and worst-case times required by
this operation are proportional to the logarithm of the number of
associations in @var{wt-tree}.
@end deffn

@deffn {procedure+} wt-tree/delete wt-tree key
Returns a new tree containing all the associations in @var{wt-tree},
except that if @var{wt-tree} contains an association for @var{key}, it
is removed from the result.  The average and worst-case times required
by this operation are proportional to the logarithm of the number of
associations in @var{wt-tree}.
@end deffn

@deffn {procedure+} wt-tree/delete! wt-tree key
If @var{wt-tree} contains an association for @var{key} the association
is removed.  Returns an unspecified value.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of associations in @var{wt-tree}.
@end deffn


@node Advanced Operations on Weight-Balanced Trees, Indexing Operations on Weight-Balanced Trees, Basic Operations on Weight-Balanced Trees, Weight-Balanced Trees
@subsection Advanced Operations on Weight-Balanced Trees

In the following the @emph{size} of a tree is the number of associations
that the tree contains, and a @emph{smaller} tree contains fewer
associations.

@deffn {procedure+} wt-tree/split< wt-tree bound
Returns a new tree containing all and only the associations in
@var{wt-tree} which have a key that is less than @var{bound} in the
ordering relation of the tree type of @var{wt-tree}.  The average and
worst-case times required by this operation are proportional to the
logarithm of the size of @var{wt-tree}.
@end deffn

@deffn {procedure+} wt-tree/split> wt-tree bound
Returns a new tree containing all and only the associations in
@var{wt-tree} which have a key that is greater than @var{bound} in the
ordering relation of the tree type of @var{wt-tree}.  The average and
worst-case times required by this operation are proportional to the
logarithm of size of @var{wt-tree}.
@end deffn

@deffn {procedure+} wt-tree/union wt-tree-1 wt-tree-2
Returns a new tree containing all the associations from both trees.
This operation is asymmetric: when both trees have an association for
the same key, the returned tree associates the datum from @var{wt-tree-2}
with the key.  Thus if the trees are viewed as discrete maps then
@code{wt-tree/union} computes the map override of @var{wt-tree-1} by
@var{wt-tree-2}.  If the trees are viewed as sets the result is the set
union of the arguments.
The worst-case time required by this operation
is proportional to the sum of the sizes of both trees.
If the minimum key of one tree is greater than the maximum key of
the other tree then the time required is at worst proportional to
the logarithm of the size of the larger tree.
@end deffn

@deffn {procedure+} wt-tree/intersection wt-tree-1 wt-tree-2
Returns a new tree containing all and only those associations from
@var{wt-tree-1} which have keys appearing as the key of an association
in @var{wt-tree-2}.  Thus the associated data in the result are those
from @var{wt-tree-1}.  If the trees are being used as sets the result is
the set intersection of the arguments.  As a discrete map operation,
@code{wt-tree/intersection} computes the domain restriction of
@var{wt-tree-1} to (the domain of) @var{wt-tree-2}.
The time required by this operation is never worse that proportional to
the sum of the sizes of the trees.
@end deffn

@deffn {procedure+} wt-tree/difference wt-tree-1 wt-tree-2
Returns a new tree containing all and only those associations from
@var{wt-tree-1} which have keys that @emph{do not} appear as the key of
an association in @var{wt-tree-2}.  If the trees are viewed as sets the
result is the asymmetric set difference of the arguments.  As a discrete
map operation, it computes the domain restriction of @var{wt-tree-1} to
the complement of (the domain of) @var{wt-tree-2}.
The time required by this operation is never worse that proportional to
the sum of the sizes of the trees.
@end deffn


@deffn {procedure+} wt-tree/subset? wt-tree-1 wt-tree-2
Returns @code{#t} iff the key of each association in @var{wt-tree-1} is
the key of some association in @var{wt-tree-2}, otherwise returns @code{#f}.
Viewed as a set operation, @code{wt-tree/subset?} is the improper subset
predicate.
A proper subset predicate can be constructed:

@example
(define (proper-subset? s1 s2)
  (and (wt-tree/subset? s1 s2)
       (< (wt-tree/size s1) (wt-tree/size s2))))
@end example

As a discrete map operation, @code{wt-tree/subset?} is the subset
test on the domain(s) of the map(s).  In the worst-case the time
required by this operation is proportional to the size of
@var{wt-tree-1}.
@end deffn


@deffn {procedure+} wt-tree/set-equal? wt-tree-1 wt-tree-2
Returns @code{#t} iff for every association in @var{wt-tree-1} there is
an association in @var{wt-tree-2} that has the same key, and @emph{vice
versa}.

Viewing the arguments as sets @code{wt-tree/set-equal?} is the set
equality predicate.  As a map operation it determines if two maps are
defined on the same domain.

This procedure is equivalent to

@example
(lambda (wt-tree-1 wt-tree-2)
  (and (wt-tree/subset? wt-tree-1 wt-tree-2
       (wt-tree/subset? wt-tree-2 wt-tree-1)))
@end example

In the worst-case the time required by this operation is proportional to
the size of the smaller tree.
@end deffn


@deffn {procedure+} wt-tree/fold combiner initial wt-tree
This procedure reduces @var{wt-tree} by combining all the associations,
using an reverse in-order traversal, so the associations are visited in
reverse order.  @var{Combiner} is a procedure of three arguments: a key,
a datum and the accumulated result so far.  Provided @var{combiner}
takes time bounded by a constant, @code{wt-tree/fold} takes time
proportional to the size of @var{wt-tree}.

A sorted association list can be derived simply:

@example
(wt-tree/fold  (lambda (key datum list)
                 (cons (cons key datum) list))
               '()
               @var{wt-tree}))
@end example

The data in the associations can be summed like this:

@example
(wt-tree/fold  (lambda (key datum sum) (+ sum datum))
               0
               @var{wt-tree})
@end example
@end deffn

@deffn {procedure+} wt-tree/for-each action wt-tree
This procedure traverses the tree in-order, applying @var{action} to
each association.
The associations are processed in increasing order of their keys.
@var{Action} is a procedure of two arguments which take the key and
datum respectively of the association.
Provided @var{action} takes time bounded by a constant,
@code{wt-tree/for-each} takes time proportional to in the size of
@var{wt-tree}.
The example prints the tree:

@example
(wt-tree/for-each (lambda (key value)
                    (display (list key value)))
                  @var{wt-tree}))
@end example
@end deffn


@node Indexing Operations on Weight-Balanced Trees,  , Advanced Operations on Weight-Balanced Trees, Weight-Balanced Trees
@subsection Indexing Operations on Weight-Balanced Trees

Weight balanced trees support operations that view the tree as sorted
sequence of associations.  Elements of the sequence can be accessed by
position, and the position of an element in the sequence can be
determined, both in logarthmic time.

@deffn {procedure+} wt-tree/index wt-tree index
@deffnx {procedure+} wt-tree/index-datum wt-tree index
@deffnx {procedure+} wt-tree/index-pair wt-tree index
Returns the 0-based @var{index}th association of @var{wt-tree} in the
sorted sequence under the tree's ordering relation on the keys.
@code{wt-tree/index} returns the @var{index}th key,
@code{wt-tree/index-datum} returns the datum associated with the
@var{index}th key and @code{wt-tree/index-pair} returns a new pair
@code{(@var{key} . @var{datum})} which is the @code{cons} of the @var{index}th
key and its datum.  The average and worst-case times required by this
operation are proportional to the logarithm of the number of
associations in the tree.

These operations signal an error if the tree is empty, if
@var{index}@code{<0}, or if @var{index} is greater than or equal to the
number of associations in the tree.

Indexing can be used to find the median and maximum keys in the tree as
follows:

@example
median:   (wt-tree/index @var{wt-tree} (quotient (wt-tree/size @var{wt-tree}) 2))

maximum:  (wt-tree/index @var{wt-tree} (-1+ (wt-tree/size @var{wt-tree})))
@end example
@end deffn

@deffn {procedure+} wt-tree/rank wt-tree key
Determines the 0-based position of @var{key} in the sorted sequence of
the keys under the tree's ordering relation, or @code{#f} if the tree
has no association with for @var{key}.  This procedure returns either an
exact non-negative integer or @code{#f}.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of associations in the tree.
@end deffn

@deffn {procedure+} wt-tree/min wt-tree index
@deffnx {procedure+} wt-tree/min-datum wt-tree index
@deffnx {procedure+} wt-tree/min-pair wt-tree index
Returns the association of @var{wt-tree} that has the least key under the tree's ordering relation.
@code{wt-tree/min} returns the least key,
@code{wt-tree/min-datum} returns the datum associated with the
least key and @code{wt-tree/min-pair} returns a new pair
@code{(key . datum)} which is the @code{cons} of the minimum key and its datum.
The average and worst-case times required by this operation are
proportional to the logarithm of the number of associations in the tree.

These operations signal an error if the tree is empty.
They could be written
@example
(define (wt-tree/min tree)        (wt-tree/index tree 0))
(define (wt-tree/min-datum tree)  (wt-tree/index-datum tree 0))
(define (wt-tree/min-pair tree)   (wt-tree/index-pair tree 0))
@end example
@end deffn

@deffn {procedure+} wt-tree/delete-min wt-tree
Returns a new tree containing all of the associations in @var{wt-tree}
except the association with the least key under the @var{wt-tree}'s
ordering relation.  An error is signalled if the tree is empty.  The
average and worst-case times required by this operation are proportional
to the logarithm of the number of associations in the tree.  This
operation is equivalent to

@example
(wt-tree/delete @var{wt-tree} (wt-tree/min @var{wt-tree}))
@end example
@end deffn


@deffn {procedure+} wt-tree/delete-min! wt-tree
Removes the association with the least key under the @var{wt-tree}'s
ordering relation.  An error is signalled if the tree is empty.  The
average and worst-case times required by this operation are proportional
to the logarithm of the number of associations in the tree.  This
operation is equivalent to

@example
(wt-tree/delete! @var{wt-tree} (wt-tree/min @var{wt-tree}))
@end example
@end deffn


@node Procedures, Environments, Associations, Top
@chapter Procedures

@cindex procedure
@cindex primitive procedure (defn)
@cindex built-in procedure
@findex lambda
@cindex application hook (defn)
@cindex hook, application (defn)
Procedures are created by evaluating @code{lambda} expressions
(@pxref{Lambda Expressions}); the @code{lambda} may either be explicit
or may be implicit as in a ``procedure @code{define}''
(@pxref{Definitions}).  Also there are special built-in procedures,
called @dfn{primitive procedures}, such as @code{car}; these procedures
are not written in Scheme but in the language used to implement the
Scheme system.  MIT Scheme also provides @dfn{application hooks}, which
support the construction of data structures that act like procedures.

@cindex procedure, type
@cindex procedure, primitive
@cindex procedure, interpreted
@cindex procedure, compiled
@cindex type, of procedure
@cindex primitive, procedure type
@cindex interpreted, procedure type
@cindex compiled, procedure type
@cindex external representation, for procedure
In MIT Scheme, the written representation of a procedure tells you
the type of the procedure (compiled, interpreted, or primitive):

@example
@group
pp
     @result{}  #[compiled-procedure 56 ("pp" #x2) #x10 #x307578]
(lambda (x) x)
     @result{}  #[compound-procedure 57]
(define (foo x) x)
foo
     @result{}  #[compound-procedure 58 foo]
car
     @result{}  #[primitive-procedure car]
(call-with-current-continuation (lambda (x) x))
     @result{}  #[continuation 59]
@end group
@end example

@noindent
@cindex compound procedure
@cindex procedure, compound
Note that interpreted procedures are called ``compound'' procedures
(strictly speaking, compiled procedures are also compound procedures).
The written representation makes this distinction for historical
reasons, and may eventually change.

@menu
* Procedure Operations::        
* Primitive Procedures::        
* Continuations::               
* Application Hooks::           
@end menu

@node Procedure Operations, Primitive Procedures,  , Procedures
@section Procedure Operations

@deffn procedure apply procedure object object @dots{}
@cindex application, of procedure
Calls @var{procedure} with the elements of the following list as
arguments:

@example
(cons* @var{object} @var{object} @dots{})
@end example

@noindent
The initial @var{object}s may be any objects, but the last @var{object}
(there must be at least one @var{object}) must be a list.

@example
@group
(apply + (list 3 4 5 6))                @result{}  18
(apply + 3 4 '(5 6))                    @result{}  18

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))
((compose sqrt *) 12 75)                @result{}  30
@end group
@end example
@end deffn

@deffn {procedure+} procedure? object
@cindex type predicate, for procedure
Returns @code{#t} if @var{object} is a procedure; otherwise returns
@code{#f}.  If @code{#t} is returned, exactly one of the following
predicates is satisfied by @var{object}: @code{compiled-procedure?},
@code{compound-procedure?}, or @code{primitive-procedure?}.
@end deffn

@deffn {procedure+} compiled-procedure? object
@cindex type predicate, for compiled procedure
Returns @code{#t} if @var{object} is a compiled procedure; otherwise
returns @code{#f}.
@end deffn

@deffn {procedure+} compound-procedure? object
@cindex type predicate, for compound procedure
Returns @code{#t} if @var{object} is a compound (i.e.@: interpreted)
procedure; otherwise returns @code{#f}.
@end deffn

@deffn {procedure+} primitive-procedure? object
@cindex type predicate, for primitive procedure
Returns @code{#t} if @var{object} is a primitive procedure; otherwise
returns @code{#f}.
@end deffn

The following two procedures test the @dfn{arity} of a procedure, that
is, the number of arguments that the procedure accepts.  The results of
the test may be less restrictive than the effect of calling the
procedure.  In other words, these procedures may indicate that the
procedure will accept a given number of arguments, but if you call the
procedure it may signal a
@code{condition-type:wrong-number-of-arguments} error.  This is because
these procedures examine the apparent arity of a procedure.  For
example, here is a procedure that appears to accept any number of
arguments, but when called will signal an error if the number of
arguments is not one:
@findex condition-type:wrong-number-of-arguments

@example
(lambda arguments (apply car arguments))
@end example

@deffn {procedure+} procedure-arity-valid? procedure k
Returns @code{#t} if @var{procedure} accepts @var{k} arguments;
otherwise returns @code{#f}.
@end deffn

@deffn {procedure+} procedure-arity procedure
Returns a description of the number of arguments that @var{procedure}
accepts.  The result is a newly allocated pair whose car field is the
minimum number of arguments, and whose cdr field is the maximum
number of arguments.  The minimum is an exact non-negative integer.  The
maximum is either an exact non-negative integer, or @code{#f} meaning
that the procedure has no maximum number of arguments.

@example
@group
(procedure-arity (lambda () 3))         @result{}  (0 . 0)
(procedure-arity (lambda (x) x))        @result{}  (1 . 1)
(procedure-arity car)                   @result{}  (1 . 1)
(procedure-arity (lambda x x))          @result{}  (0 . #f)
(procedure-arity (lambda (x . y) x))    @result{}  (1 . #f)
(procedure-arity (lambda (x #!optional y) x))
                                        @result{}  (1 . 2)
@end group
@end example
@end deffn

@deffn {procedure+} procedure-environment procedure
Returns the closing environment of @var{procedure}.  Signals an error if
@var{procedure} is a primitive procedure, or if @var{procedure} is a
compiled procedure for which the debugging information is unavailable.
@end deffn

@node Primitive Procedures, Continuations, Procedure Operations, Procedures
@section Primitive Procedures

@deffn {procedure+} make-primitive-procedure name [arity]
@var{Name} must be a symbol.  @var{Arity} must be an exact non-negative
integer, @code{-1}, @code{#f}, or @code{#t}; if not supplied it defaults
to @code{#f}.  Returns the primitive procedure called @var{name}.  May
perform further actions depending on @var{arity}:

@table @asis
@item @code{#f}
If the primitive procedure is not implemented, signals an error.

@item @code{#t}
If the primitive procedure is not implemented, returns @code{#f}.

@item integer
If the primitive procedure is implemented, signals an error if its arity
is not equal to @var{arity}.  If the primitive procedure is not
implemented, returns an unimplemented primitive procedure object that
accepts @var{arity} arguments.  An @var{arity} of @code{-1} means it
accepts any number of arguments.
@end table
@end deffn

@deffn {procedure+} primitive-procedure-name primitive-procedure
Returns the name of @var{primitive-procedure}, a symbol.

@example
(primitive-procedure-name car)          @result{}  car
@end example
@end deffn

@deffn {procedure+} implemented-primitive-procedure? primitive-procedure
Returns @code{#t} if @var{primitive-procedure} is implemented; otherwise
returns @code{#f}.  Useful because the code that implements a particular
primitive procedure is not necessarily linked into the executable Scheme
program.
@end deffn

@node Continuations, Application Hooks, Primitive Procedures, Procedures
@section Continuations

@deffn procedure call-with-current-continuation procedure
@cindex continuation
@cindex construction, of continuation
@cindex procedure, escape (defn)
@cindex escape procedure (defn)
@var{Procedure} must be a procedure of one argument.  Packages up the
current continuation (see below) as an @dfn{escape procedure} and passes
it as an argument to @var{procedure}.  The escape procedure is a Scheme
procedure of one argument that, if it is later passed a value, will
ignore whatever continuation is in effect at that later time and will
give the value instead to the continuation that was in effect when the
escape procedure was created.  The escape procedure created by
@code{call-with-current-continuation} has unlimited extent just like any
other procedure in Scheme.  It may be stored in variables or data
structures and may be called as many times as desired.

The following examples show only the most common uses of this procedure.
If all real programs were as simple as these examples, there would be no
need for a procedure with the power of
@code{call-with-current-continuation}.

@example
@group
(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    #t))                                @result{}  -3
@end group

@group
(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj) (+ (r (cdr obj)) 1))
                          (else (return #f))))))
          (r obj))))))
(list-length '(1 2 3 4))                @result{}  4
(list-length '(a b . c))                @result{}  #f
@end group
@end example

@cindex non-local exit
@cindex exit, non-local
A common use of @code{call-with-current-continuation} is for structured,
non-local exits from loops or procedure bodies, but in fact
@code{call-with-current-continuation} is quite useful for implementing a
wide variety of advanced control structures.

Whenever a Scheme expression is evaluated a continuation exists that
wants the result of the expression.  The continuation represents an
entire (default) future for the computation.  If the expression is
evaluated at top level, for example, the continuation will take the
result, print it on the screen, prompt for the next input, evaluate it,
and so on forever.  Most of the time the continuation includes actions
specified by user code, as in a continuation that will take the result,
multiply it by the value stored in a local variable, add seven, and give
the answer to the top-level continuation to be printed.  Normally these
ubiquitous continuations are hidden behind the scenes and programmers
don't think much about them.  On the rare occasions that you may need to
deal explicitly with continuations,
@code{call-with-current-continuation} lets you do so by creating a
procedure that acts just like the current continuation.
@end deffn

@deffn {procedure+} continuation? object
@cindex type predicate, for continuation
Returns @code{#t} if @var{object} is a continuation; otherwise returns
@code{#f}.
@end deffn

@deffn {procedure+} within-continuation continuation thunk
@cindex continuation, alternate invocation
@cindex escape procedure, alternate invocation
@var{Continuation} must be a continuation produced by
@code{call-with-current-continuation}.
@var{Thunk} must be a procedure of no arguments.
Conceptually, @code{within-continuation} invokes @code{continuation} on
the result of invoking @code{thunk}, but @code{thunk} is executed in the
dynamic context of @code{continuation}.  In other words, the ``current''
continuation is abandoned before @code{thunk} is invoked.
@end deffn

@deffn {procedure+} dynamic-wind before-thunk action-thunk after-thunk
@cindex unwind protect
@findex unwind-protect
This facility is a generalization of Common Lisp @code{unwind-protect},
designed to take into account the fact that continuations produced by
@code{call-with-current-continuation} may be reentered.  The arguments
@var{before-thunk}, @var{action-thunk}, and @var{after-thunk} must all
be procedures of no arguments (thunks).

@code{dynamic-wind} behaves as follows.  First @var{before-thunk} is
called.  Then @var{action-thunk} is called.  Finally, @var{after-thunk}
is called.  The value returned by @var{action-thunk} is returned as the
result of @code{dynamic-wind}.  @var{After-thunk} is also called if
@var{action-thunk} escapes from its continuation.  If @var{action-thunk}
captures its continuation as an escape procedure, escapes from it, then
escapes back to it, @var{after-thunk} is invoked when escaping away, and
@var{before-thunk} is invoked when escaping back.

@cindex locks, and dynamic-wind
@code{dynamic-wind} is useful, for example, for ensuring the proper
maintenance of locks: locking would occur in the @var{before-thunk},
protected code would appear in the @var{action-thunk}, and unlocking
would occur in the @var{after-thunk}.
@end deffn

The following two procedures support multiple values.  A future revision
of the Scheme standard will support a facility similar to, but almost
certainly different from, this one.

@deffn {procedure+} call-with-values thunk procedure
@cindex multiple values, from procedure
@cindex values, multiple
@var{Thunk} must be a procedure of no arguments, and @var{procedure}
must be a procedure.  @var{Thunk} is invoked with a continuation that
expects to receive multiple values; specifically, the continuation
expects to receive the same number of values that @var{procedure}
accepts as arguments.  @var{Thunk} must return multiple values using the
@code{values} procedure.  Then @var{procedure} is called with the
multiple values as its arguments.  The result yielded by @var{procedure}
is returned as the result of @code{call-with-values}.
@end deffn

@deffn {procedure+} values object @dots{}
Returns multiple values.  The continuation in effect when this procedure
is called must be a multiple-value continuation that was created by
@code{call-with-values}.  Furthermore it must accept as many values as
there are @var{object}s.
@end deffn

@node Application Hooks,  , Continuations, Procedures
@section Application Hooks

@cindex application hook (defn)
@cindex procedure, of application hook
@cindex extra object, of application hook
@dfn{Application hooks} are objects that can be applied like procedures.
Each application hook has two parts: a @dfn{procedure} that specifies
what to do when the application hook is applied, and an arbitrary
object, called @dfn{extra}.  Often the procedure uses the extra object
to determine what to do.

@cindex apply hook (defn)
@cindex entity (defn)
There are two kinds of application hooks, which differ in what arguments
are passed to the procedure.  When an @dfn{apply hook} is applied, the
procedure is passed exactly the same arguments that were passed to the
apply hook.  When an @dfn{entity} is applied, the entity itself is
passed as the first argument, followed by the other arguments that were
passed to the entity.

Both apply hooks and entities satisfy the predicate @code{procedure?}.
Each satisfies either @code{compiled-procedure?},
@code{compound-procedure?}, or @code{primitive-procedure?}, depending on
its procedure component.  An apply hook is considered to accept the same
number of arguments as its procedure, while an entity is considered to
accept one less argument than its procedure.

@deffn {procedure+} make-apply-hook procedure object
Returns a newly allocated apply hook with a procedure component of
@var{procedure} and an extra component of @var{object}.
@end deffn

@deffn {procedure+} apply-hook? object
@cindex type predicate, for apply hook
Returns @code{#t} if @var{object} is an apply hook; otherwise returns
@code{#f}.
@end deffn

@deffn {procedure+} apply-hook-procedure apply-hook
Returns the procedure component of @var{apply-hook}.
@end deffn

@deffn {procedure+} set-apply-hook-procedure! apply-hook procedure
Changes the procedure component of @var{apply-hook} to be
@var{procedure}.  Returns an unspecified value.
@end deffn

@deffn {procedure+} apply-hook-extra apply-hook
Returns the extra component of @var{apply-hook}.
@end deffn

@deffn {procedure+} set-apply-hook-extra! apply-hook object
Changes the extra component of @var{apply-hook} to be @var{object}.
Returns an unspecified value.
@end deffn

@deffn {procedure+} make-entity procedure object
Returns a newly allocated entity with a procedure component of
@var{procedure} and an extra component of @var{object}.
@end deffn

@deffn {procedure+} entity? object
@cindex type predicate, for entity
Returns @code{#t} if @var{object} is an entity; otherwise returns
@code{#f}.
@end deffn

@deffn {procedure+} entity-procedure entity
Returns the procedure component of @var{entity}.
@end deffn

@deffn {procedure+} set-entity-procedure! entity procedure
Changes the procedure component of @var{entity} to be @var{procedure}.
Returns an unspecified value.
@end deffn

@deffn {procedure+} entity-extra entity
Returns the extra component of @var{entity}.
@end deffn

@deffn {procedure+} set-entity-extra! entity object
Changes the extra component of @var{entity} to be @var{object}.  Returns
an unspecified value.
@end deffn

@node Environments, Input/Output, Procedures, Top
@chapter Environments

@menu
* Environment Operations::      
* Environment Variables::       
* REPL Environment::            
* Interpreter Environments::    
@end menu

@node Environment Operations, Environment Variables,  , Environments
@section Environment Operations

Environments are first-class objects in MIT Scheme.  An environment
consists of some bindings and possibly a parent environment, from which
other bindings are inherited.  The operations in this section reveal the
frame-like structure of environments by permitting you to examine the
bindings of a particular environment separately from those of its
parent.

@deffn {procedure+} environment? object
@cindex type predicate, for environment
Returns @code{#t} if @var{object} is an environment; otherwise returns
@code{#f}.
@end deffn

@deffn {procedure+} environment-has-parent? environment
Returns @code{#t} if @var{environment} has a parent environment;
otherwise returns @code{#f}.
@end deffn

@deffn {procedure+} environment-parent environment
Returns the parent environment of @var{environment}.  It is an error if
@var{environment} has no parent.
@end deffn

@deffn {procedure+} environment-bound-names environment
Returns a newly allocated list of the names (symbols) that are bound by
@var{environment}.  This does not include the names that are bound by
the parent environment of @var{environment}.
@end deffn

@deffn {procedure+} environment-bindings environment
Returns a newly allocated list of the bindings of @var{environment};
does not include the bindings of the parent environment.
Each element of this list takes one of two forms: @code{(@var{name})}
indicates that @var{name} is bound but unassigned, while
@code{(@var{name} @var{object})} indicates that @var{name} is bound, and
its value is @var{object}.
@end deffn

@deffn {procedure+} environment-bound? environment symbol
Returns @code{#t} if @var{symbol} is bound in @var{environment} or one
of its ancestor environments; otherwise returns @code{#f}.
@end deffn

@deffn {procedure+} environment-lookup environment symbol
@var{Symbol} must be bound in @var{environment} or one of its ancestor
environments.  Returns the value to which it is bound.
@end deffn

@deffn {procedure+} environment-assignable? environment symbol
@var{Symbol} must be bound in @var{environment} or one of its ancestor
environments.  Returns @code{#t} if the binding may be modified by side
effect.
@end deffn

@deffn {procedure+} environment-assign! environment symbol object
@var{Symbol} must be bound in @var{environment} or one of its ancestor
environments, and must be assignable.  Modifies the binding to have
@var{object} as its value, and returns an unspecified result.
@end deffn

@deffn {procedure+} eval expression environment
@cindex s-expression
@cindex evaluation, of s-expression
Evaluates @var{expression}, a list-structure representation (sometimes
called s-expression representation) of a Scheme expression, in
@var{environment}.  You rarely need @code{eval} in ordinary programs; it
is useful mostly for evaluating expressions that have been created ``on
the fly'' by a program.  @code{eval} is relatively expensive because it
must convert @var{expression} to an internal form before it is executed.

@example
@group
(define foo (list '+ 1 2))
(eval foo (the-environment))            @result{}  3
@end group
@end example
@end deffn

@node Environment Variables, REPL Environment, Environment Operations, Environments
@section Environment Variables

@findex define
The @code{user-initial-environment} is where the top-level
read-eval-print (@sc{rep}) loop evaluates expressions and stores
definitions.  It is a child of the @code{system-global-environment},
which is where all of the Scheme system definitions are stored.  All of
the bindings in @code{system-global-environment} are available when the
current environment is @code{user-initial-environment}.  However, any
new bindings that you create in the @sc{rep} loop (with @code{define}
forms or by loading files containing @code{define} forms) occur in
@code{user-initial-environment}.

@defvr {variable+} system-global-environment
The variable @code{system-global-environment} is bound to the
environment that's the parent of the @code{user-initial-environment}.
Primitives and system procedures are bound (and sometimes closed) in
this environment.
@end defvr

@defvr {variable+} user-initial-environment
The variable @code{user-initial-environment} is bound to the default
environment in which typed expressions are evaluated by the top-level
@sc{rep} loop.

Although all bindings in @code{system-global-environment} are visible to
the @sc{rep} loop, definitions that are typed at, or loaded by, the
@sc{rep} loop occur in the @code{user-initial-environment}.  This is
partly a safety measure: if you enter a definition that happens to have
the same name as a critical system procedure, your definition will be
visible only to the procedures you define in the
@code{user-initial-environment}; the MIT Scheme system procedures, which
are defined in the @code{system-global-environment}, will continue to
see the original definition.
@end defvr

@node REPL Environment, Interpreter Environments, Environment Variables, Environments
@section REPL Environment

@deffn {procedure+} nearest-repl/environment
@findex user-initial-environment
Returns the current @sc{rep} loop environment (i.e.@: the current
environment of the closest enclosing @sc{rep} loop).  When Scheme first
starts up, this is the same as @code{user-initial-environment}.
@end deffn

@deffn {procedure+} ge environment
Changes the current @sc{rep} loop environment to @var{environment}.
@var{Environment} can be either an environment or a procedure object.
If it's a procedure, the environment in which that procedure was closed
is the new environment.
@end deffn

@node Interpreter Environments,  , REPL Environment, Environments
@section Interpreter Environments

The operations in this section return environments that are constructed
by the interpreter.  These operations should only be used at the top
level of a file; they are not supported in any other place.  In
particular, they force the current environment to be represented in a
form suitable for use by the interpreter.  This prevents the compiler
from performing many useful optimizations on such environments, and
forces the use of the interpreter for variable references in them.
However, because all top-level environments (such as
@code{user-initial-environment}) are already interpreter environments,
it does no harm to use such operations on them.

@deffn {special form+} make-environment expression @dots{}
@cindex construction, of environment
Produces a new environment that is a child of the environment in which
it is executed, evaluates the @var{expression}s sequentially in the new
environment, and returns the new environment.  Note that

@example
(make-environment @var{expression} @dots{})
@end example

@noindent
is equivalent to:

@example
(let ()
  @var{expression} @dots{}
  (the-environment))
@end example
@end deffn

@deffn {special form+} the-environment
Returns the current environment.
@end deffn

@deffn {procedure+} interpreter-environment? object
@cindex type predicate, for interpreter environment
Returns @code{#t} if @var{object} is an interpreter environment;
otherwise returns @code{#f}.
@end deffn

@node Input/Output, File-System Interface, Environments, Top
@chapter Input/Output

@cindex input
@cindex output
@cindex port
This chapter describes the procedures that are used for input and output
(@sc{i/o}).  The chapter first describes @dfn{ports} and how they are
manipulated, then describes the @sc{i/o} operations.  Finally, some
low-level procedures are described that permit the implementation of
custom ports and high-performance @sc{i/o}.

@menu
* Ports::                       
* File Ports::                  
* String Ports::                
* Input Procedures::            
* Output Procedures::           
* Format::                      
* Custom Output::               
* Prompting::                   
* Port Primitives::             
@end menu

@node Ports, File Ports,  , Input/Output
@section Ports

@cindex port (defn)
@findex console-i/o-port
Scheme uses ports for @sc{i/o}.  A @dfn{port}, which can be treated like
any other Scheme object, serves as a source or sink for data.  A port
must be open before it can be read from or written to.  The standard
@sc{i/o} port, @code{console-i/o-port}, is opened automatically when you
start Scheme.  When you use a file for input or output, you need to
explicitly open and close a port to the file (with procedures described
in this chapter).  Additional procedures let you open ports to strings.

@cindex current input port (defn)
@cindex input port, current (defn)
@cindex port, current
@findex read-char
@findex read
Many input procedures, such as @code{read-char} and @code{read}, read
data from the current input port by default, or from a port that you
specify.  The current input port is initially @code{console-i/o-port},
but Scheme provides procedures that let you change the current input
port to be a file or string.

@cindex current output port (defn)
@cindex output port, current (defn)
@findex write-char
@findex display
Similarly, many output procedures, such as @code{write-char} and
@code{display}, write data to the current output port by default, or to
a port that you specify.  The current output port is initially
@code{console-i/o-port}, but Scheme provides procedures that let you
change the current output port to be a file or string.

All ports read or write only @sc{ascii} characters.

Every port is either an input port, an output port, or both.  The
following predicates distinguish all of the possible cases.

@deffn {procedure+} port? object
@cindex type predicate, for port
Returns @code{#t} if @var{object} is a port, otherwise returns
@code{#f}.
@end deffn

@deffn procedure input-port? object
Returns @code{#t} if @var{object} is an input port, otherwise returns
@code{#f}.  Any object satisfying this predicate also satisfies
@code{port?}.
@end deffn

@deffn procedure output-port? object
Returns @code{#t} if @var{object} is an output port, otherwise returns
@code{#f}.  Any object satisfying this predicate also satisfies
@code{port?}.
@end deffn

@deffn {procedure+} i/o-port? object
Returns @code{#t} if @var{object} is both an input port and an output
port, otherwise returns @code{#f}.  Any object satisfying this predicate
also satisfies @code{port?}, @code{input-port?}, and
@code{output-port?}.
@end deffn

@deffn {procedure+} guarantee-input-port object
@deffnx {procedure+} guarantee-output-port object
@deffnx {procedure+} guarantee-i/o-port object
These procedures check the type of @var{object}, signalling an error of
type @code{condition-type:wrong-type-argument} if it is not an input
port, output port, or @sc{i/o} port, respectively.  Otherwise they
return @var{object}.
@findex condition-type:wrong-type-argument
@end deffn

@cindex standard ports
The next five procedures return the runtime system's @dfn{standard
ports}.  All of the standard ports are dynamically bound by the @sc{rep}
loop; this means that when a new @sc{rep} loop is started, for example
by an error, each of these ports is dynamically bound to the @sc{i/o}
port of the @sc{rep} loop.  When the @sc{rep} loop exits, the ports
revert to their original values.

@deffn procedure current-input-port
@findex console-input-port
Returns the current input port.  This is the default port used by many
input procedures.  Initially, @code{current-input-port} returns the
value of @code{console-i/o-port}.
@end deffn

@deffn procedure current-output-port
@findex console-output-port
Returns the current output port.  This is the default port used by many
output procedures.  Initially, @code{current-output-port} returns the
value of @code{console-i/o-port}.
@end deffn

@deffn {procedure+} notification-output-port
Returns an output port suitable for generating ``notifications'', that
is, messages to the user that supply interesting information about the
execution of a program.  For example, the @code{load} procedure writes
messages to this port informing the user that a file is being loaded.
Initially, @code{notification-output-port} returns the value of
@code{console-i/o-port}.
@end deffn

@deffn {procedure+} trace-output-port
Returns an output port suitable for generating ``tracing'' information
about a program's execution.  The output generated by the @code{trace}
procedure is sent to this port.  Initially, @code{trace-output-port}
returns the value of @code{console-i/o-port}.
@end deffn

@deffn {procedure+} interaction-i/o-port
Returns an @sc{i/o} port suitable for querying or prompting the user.
The standard prompting procedures use this port by default
(@pxref{Prompting}).  Initially, @code{interaction-i/o-port} returns the
value of @code{console-i/o-port}.
@end deffn

@deffn {procedure+} with-input-from-port input-port thunk
@deffnx {procedure+} with-output-to-port output-port thunk
@deffnx {procedure+} with-notification-output-port output-port thunk
@deffnx {procedure+} with-trace-output-port output-port thunk
@deffnx {procedure+} with-interaction-i/o-port i/o-port thunk
@var{Thunk} must be a procedure of no arguments.  Each of these
procedures binds one of the standard ports to its first argument, calls
@var{thunk} with no arguments, restores the port to its original value,
and returns the result that was yielded by @var{thunk}.  This temporary
binding is performed the same way as fluid binding of a variable,
including the behavior in the presence of continuations (@pxref{Fluid
Binding}).

@code{with-input-from-port} binds the current input port,
@code{with-output-to-port} binds the current output port,
@code{with-notification-output-port} binds the ``notification'' output
port, @code{with-trace-output-port} binds the ``trace'' output port, and
@code{with-interaction-i/o-port} binds the ``interaction'' @sc{i/o} port.
@end deffn

@deffn {procedure+} set-current-input-port! input-port
@deffnx {procedure+} set-current-output-port! output-port
@deffnx {procedure+} set-notification-output-port! output-port
@deffnx {procedure+} set-trace-output-port! output-port
@deffnx {procedure+} set-interaction-i/o-port! i/o-port
Each of these procedures alters the binding of one of the standard ports
and returns an unspecified value.  The binding that is modified
corresponds to the name of the procedure.
@end deffn

@defvr {variable+} console-i/o-port
@cindex port, console
@cindex console, port
@cindex input port, console
@cindex output port, console
@code{console-i/o-port} is an @sc{i/o} port that communicates with the
``console''.  Under unix, the console is the controlling terminal of the
Scheme process.  Under @sc{ms-dos}, the console is a combination of the
keyboard and the display.  Under Windows, the console is the window that
is created when Scheme starts up.

This variable is rarely used; instead programs should use one of the
standard ports defined above.  This variable should not be modified.

@findex console-input-port
@findex console-output-port
For compatibility with old code, @code{console-input-port} and
@code{console-output-port} are synonyms for this variable.
@end defvr

@deffn {procedure+} close-port port
@deffnx procedure close-input-port port
@deffnx procedure close-output-port port
@cindex closing, of port
Closes @var{port} and returns an unspecified value.  If @var{port} is a
file port, the file is closed.  @code{close-input-port} and
@code{close-output-port} are synonyms for @code{close-port} that are
defined for compatibility with standard Scheme.
@end deffn

@node File Ports, String Ports, Ports, Input/Output
@section File Ports

@cindex file, input and output ports
@cindex port, file
@cindex input port, file
@cindex output port, file
@cindex I/O, to files
Before Scheme can access a file for reading or writing, it is necessary
to open a port to the file.  This section describes procedures used to
open ports to files.  Such ports are closed (like any other port) by
@code{close-port}.  File ports are automatically closed if and when they
are reclaimed by the garbage collector.

@findex merge-pathnames
Before opening a file for input or output, by whatever method, the
@var{filename} argument is converted to canonical form by calling the
procedure @code{merge-pathnames} with @var{filename} as its sole
argument.  Thus, @var{filename} can be either a string or a pathname,
and it is merged with the current pathname defaults to produce the
pathname that is then opened.

@cindex binary file ports
@cindex newline translation
Any file can be opened in one of two modes, @dfn{normal} or
@dfn{binary}.  Normal mode is for accessing text files, and binary mode
is for accessing other files.  Some operating systems, e.g.@: unix, do
not distinguish these modes.  @sc{ms-dos} is an example of an operating
system that does distinguish these modes: in normal mode, @sc{ms-dos}
file ports perform @dfn{newline translation}, mapping between the
carriage-return/linefeed sequence that terminates text lines in files,
and the @code{#\newline} that terminates lines in Scheme.  In binary
mode, @sc{ms-dos} ports do not perform newline translation.  Unless
otherwise mentioned, the procedures in this section open files in normal
mode.

@deffn procedure open-input-file filename
@cindex construction, of file input port
Takes a filename referring to an existing file and returns an input port
capable of delivering characters from the file.  If the file cannot be
opened, an error of type @code{condition-type:file-operation-error} is
signalled.
@findex condition-type:file-operation-error
@end deffn

@deffn procedure open-output-file filename [append?]
@cindex construction, of file output port
Takes a filename referring to an output file to be created and returns
an output port capable of writing characters to a new file by that name.
If the file cannot be opened, an error of type
@code{condition-type:file-operation-error} is signalled.
@findex condition-type:file-operation-error

@cindex appending, to output file
The optional argument @var{append?} is an MIT Scheme extension.  If
@var{append?} is given and not @code{#f}, the file is opened in
@dfn{append} mode.  In this mode, the contents of the file are not
overwritten; instead any characters written to the file are appended to
the end of the existing contents.  If the file does not exist, append
mode creates the file and writes to it in the normal way.
@end deffn

@deffn {procedure+} open-i/o-file filename
@cindex construction, of file input port
Takes a filename referring to an existing file and returns an @sc{i/o}
port capable of both reading and writing the file.  If the file cannot
be opened, an error of type @code{condition-type:file-operation-error}
is signalled.
@findex condition-type:file-operation-error

This procedure is often used to open special files.  For example, under
unix this procedure can be used to open terminal device files, @sc{pty}
device files, and named pipes.
@end deffn

@deffn {procedure+} open-binary-input-file filename
@deffnx {procedure+} open-binary-output-file filename [append?]
@deffnx {procedure+} open-binary-i/o-file filename
These procedures open files in binary mode.  In all other respects they
are identical to @code{open-input-file}, @code{open-output-file}, and
@code{open-i/o-file}, respectively.
@end deffn

@deffn {procedure+} close-all-open-files
@cindex closing, of file port
This procedure closes all file ports that are open at the time that it
is called, and returns an unspecified value.
@end deffn

@deffn procedure call-with-input-file filename procedure
@deffnx procedure call-with-output-file filename procedure
These procedures call @var{procedure} with one argument: the port
obtained by opening the named file for input or output, respectively.
If the file cannot be opened, an error of type
@code{condition-type:file-operation-error} is signalled.  If
@var{procedure} returns, then the port is closed automatically and the
value yielded by @var{procedure} is returned.  If @var{procedure} does
not return, then the port will not be closed automatically unless it is
reclaimed by the garbage collector.@footnote{Because Scheme's escape
procedures have unlimited extent, it is possible to escape from the
current continuation but later to escape back in.  If implementations
were permitted to close the port on any escape from the current
continuation, then it would be impossible to write portable code using
both @code{call-with-current-continuation} and
@code{call-with-input-file} or @code{call-with-output-file}.}
@end deffn

@deffn {procedure+} call-with-binary-input-file filename procedure
@deffnx {procedure+} call-with-binary-output-file filename procedure
These procedures open files in binary mode.  In all other respects they
are identical to @code{call-with-input-file} and
@code{call-with-output-file}, respectively.
@end deffn

@deffn procedure with-input-from-file filename thunk
@deffnx procedure with-output-to-file filename thunk
@cindex current input port, rebinding
@cindex current output port, rebinding
@findex current-input-port
@findex current-output-port
@var{Thunk} must be a procedure of no arguments.
The file is opened for input or output, an input or output port
connected to it is made the default value returned by
@code{current-input-port} or @code{current-output-port}, and the
@var{thunk} is called with no arguments.  When the @var{thunk} returns,
the port is closed and the previous default is restored.
@code{with-input-from-file} and @code{with-output-to-file} return the
value yielded by @var{thunk}.  If an escape procedure is used to escape
from the continuation of these procedures, their behavior is
implementation-dependent; in that situation MIT Scheme leaves the files
open.
@end deffn

@deffn {procedure+} with-input-from-binary-file filename thunk
@deffnx {procedure+} with-output-to-binary-file filename thunk
These procedures open files in binary mode.  In all other respects they
are identical to @code{with-input-from-file} and
@code{with-output-to-file}, respectively.
@end deffn

@node String Ports, Input Procedures, File Ports, Input/Output
@section String Ports

@cindex string, input and output ports
@cindex port, string
@cindex input port, string
@cindex output port, string
@cindex I/O, to strings
This section describes the simplest kinds of ports: input ports that
read their input from given strings, and output ports that accumulate
their output and return it as a string.  It also describes
``truncating'' output ports, which can limit the length of the resulting
string to a given value.

@deffn {procedure+} string->input-port string [start [end]]
@cindex string, converting to input port
@cindex construction, of string input port
Returns a new string port that delivers characters from @var{string}.
The optional arguments @var{start} and @var{end} may be used to specify
that the string port delivers characters from a substring of
@var{string}; if not given, @var{start} defaults to @code{0} and
@var{end} defaults to @code{(string-length @var{string})}.
@end deffn

@deffn {procedure+} with-input-from-string string thunk
@cindex current input port, rebinding
@var{Thunk} must be a procedure of no arguments.
@code{with-input-from-string} creates a new input port that reads from
@var{string}, makes that port the current input port, and calls
@var{thunk}.  When @var{thunk} returns, @code{with-input-from-string}
restores the previous current input port and returns the result yielded
by @var{thunk}.

@example
(with-input-from-string "(a b c) (d e f)" read)  @result{}  (a b c)
@end example

Note: this procedure is equivalent to:

@example
(with-input-from-port (string->input-port @var{string}) @var{thunk})
@end example
@end deffn

@deffn {procedure+} with-string-output-port procedure
@var{Procedure} is called with one argument, an output port.  The value
yielded by @var{procedure} is ignored.  When @var{procedure} returns,
@code{with-string-output-port} returns the accumulated output to the
port as a newly allocated string.
@end deffn

@deffn {procedure+} with-output-to-string thunk
@cindex current output port, rebinding
@cindex construction, of string output port
@findex current-output-port
@var{Thunk} must be a procedure of no arguments.
@code{with-output-to-string} creates a new output port that accumulates
output, makes that port the default value returned by
@code{current-output-port}, and calls @var{thunk} with no arguments.
When @var{thunk} returns, @code{with-output-to-string} restores the
previous default and returns the accumulated output as a newly allocated
string.

@example
(with-output-to-string
  (lambda ()
    (write 'abc)))                    @result{}  "abc"
@end example

Note: this procedure is equivalent to:

@example
(with-string-output-port
 (lambda (port)
   (with-output-to-port port @var{thunk})))
@end example
@end deffn

@deffn {procedure+} with-output-to-truncated-string k thunk
Similar to @code{with-output-to-string}, except that the output is
limited to @var{k} characters.  If @var{thunk} attempts to write more
than @var{k} characters, it will be aborted by invoking an escape
procedure that returns from @code{with-output-to-truncated-string}.

The value of this procedure is a pair; the car of the pair is @code{#t}
if @var{thunk} attempted to write more than @var{k} characters, and
@code{#f} otherwise.  The cdr of the pair is a newly allocated string
containing the accumulated output.

This procedure is helpful for displaying circular lists, as shown in this
example:

@example
@group
(define inf (list 'inf))
(with-output-to-truncated-string 40
  (lambda ()
    (write inf)))                       @result{}  (#f . "(inf)")
(set-cdr! inf inf)
(with-output-to-truncated-string 40
  (lambda ()
    (write inf)))
        @result{}  (#t . "(inf inf inf inf inf inf inf inf inf inf")
@end group
@end example
@end deffn

@deffn {procedure+} write-to-string object [k]
Writes @var{object} to a string output port, and returns the resulting
newly allocated string.  If @var{k} is supplied and not @code{#f}, this
procedure is equivalent to

@example
@group
(with-output-to-truncated-string @var{k}
  (lambda ()
    (write @var{object})))
@end group
@end example

otherwise it is equivalent to

@example
@group
(with-output-to-string
 (lambda ()
   (write @var{object})))
@end group
@end example
@end deffn

@node Input Procedures, Output Procedures, String Ports, Input/Output
@section Input Procedures
@cindex input operations

This section describes the procedures that read input.  Input procedures
can read either from the current input port or from a given port.
Remember that to read from a file, you must first open a port to the
file.

@cindex interactive input ports (defn)
Input ports can be divided into two types, called @dfn{interactive} and
@dfn{non-interactive}.  Interactive input ports are ports that read
input from a source that is time-dependent; for example, a port that
reads input from a terminal or from another program.  Non-interactive
input ports read input from a time-independent source, such as an
ordinary file or a character string.

All optional arguments called @var{input-port}, if not supplied, default
to the current input port.

@deffn procedure read-char [input-port]
@cindex character, input from port
Returns the next character available from @var{input-port}, updating
@var{input-port} to point to the following character.  If no more
characters are available, an end-of-file object is returned.

In MIT Scheme, if @var{input-port} is an interactive input port and no
characters are immediately available, @code{read-char} will hang waiting
for input.
@end deffn

@deffn procedure peek-char [input-port]
Returns the next character available from @var{input-port},
@emph{without} updating @var{input-port} to point to the following
character.  If no more characters are available, an end-of-file object
is returned.@footnote{The value returned by a call to @code{peek-char}
is the same as the value that would have been returned by a call to
@code{read-char} on the same port.  The only difference is that the very
next call to @code{read-char} or @code{peek-char} on that
@var{input-port} will return the value returned by the preceding call to
@code{peek-char}.  In particular, a call to @code{peek-char} on an
interactive port will hang waiting for input whenever a call to
@code{read-char} would have hung.}

In MIT Scheme, if @var{input-port} is an interactive input port and no
characters are immediately available, @code{peek-char} will hang waiting
for input.
@end deffn

@deffn procedure char-ready? [input-port]
@findex read-char
Returns @code{#t} if a character is ready on @var{input-port} and
returns @code{#f} otherwise.  If @code{char-ready?} returns @code{#t}
then the next @code{read-char} operation on @var{input-port} is
guaranteed not to hang.  If @var{input-port} is a file port at end of
file then @code{char-ready?} returns
@code{#t}.@footnote{@code{char-ready?} exists to make it possible for a
program to accept characters from interactive ports without getting
stuck waiting for input.  Any input editors associated with such ports
must make sure that characters whose existence has been asserted by
@code{char-ready?} cannot be rubbed out.  If @code{char-ready?} were to
return @code{#f} at end of file, a port at end of file would be
indistinguishable from an interactive port that has no ready
characters.}
@end deffn

@deffn procedure read [input-port]
@cindex expression, input from port
@cindex external representation, parsing
@cindex parsing, of external representation
Converts external representations of Scheme objects into the objects
themselves.  @code{read} returns the next object parsable from
@var{input-port}, updating @var{input-port} to point to the first
character past the end of the written representation of the object.  If
an end of file is encountered in the input before any characters are
found that can begin an object, @code{read} returns an end-of-file
object.  The @var{input-port} remains open, and further attempts to read
will also return an end-of-file object.  If an end of file is
encountered after the beginning of an object's written representation,
but the written representation is incomplete and therefore not parsable,
an error is signalled.
@end deffn

@deffn procedure eof-object? object
@cindex type predicate, for EOF object
@cindex EOF object, predicate for
@cindex end of file object (see EOF object)
@cindex file, end-of-file marker (see EOF object)
Returns @code{#t} if @var{object} is an end-of-file object; otherwise
returns @code{#f}.
@end deffn

@deffn {procedure+} read-char-no-hang [input-port]
If @var{input-port} can deliver a character without blocking, this
procedure acts exactly like @code{read-char}, immediately returning that
character.  Otherwise, @code{#f} is returned, unless @var{input-port} is
a file port at end of file, in which case an end-of-file object is
returned.  In no case will this procedure block waiting for input.
@end deffn

@deffn {procedure+} read-string char-set [input-port]
@cindex string, input from port
Reads characters from @var{input-port} until it finds a terminating
character that is a member of @var{char-set} (@pxref{Character Sets}) or
encounters end of file.  The port is updated to point to the terminating
character, or to end of file if no terminating character was found.
@code{read-string} returns the characters, up to but excluding the
terminating character, as a newly allocated string.  However, if end of
file was encountered before any characters were read, @code{read-string}
returns an end-of-file object.

@findex read-char
On many input ports, this operation is significantly faster than the
following equivalent code using @code{peek-char} and @code{read-char}:

@example
@group
(define (read-string char-set input-port)
  (let ((char (peek-char input-port)))
    (if (eof-object? char)
        char
        (list->string
         (let loop ((char char))
           (if (or (eof-object? char)
                   (char-set-member? char-set char))
               '()
               (begin
                 (read-char input-port)
                 (cons char (loop (peek-char input-port))))))))))
@end group
@end example
@end deffn

@node Output Procedures, Format, Input Procedures, Input/Output
@section Output Procedures
@cindex output procedures

@cindex buffering, of output
@cindex flushing, of buffered output
Output ports may or may not support @dfn{buffering} of output, in which
output characters are collected together in a buffer and then sent to
the output device all at once.  (Most of the output ports implemented by
the runtime system support buffering.)  Sending all of the characters in
the buffer to the output device is called @dfn{flushing} the buffer.  In
general, output procedures do not flush the buffer of an output port
unless the buffer is full.

@cindex discretionary flushing, of buffered output
@findex discretionary-output-flush
However, the standard output procedures described in this section
perform what is called @dfn{discretionary} flushing of the buffer.
Discretionary output flushing works as follows.  After a procedure
performs its output (writing characters to the output buffer), it checks
to see if the port implements an operation called
@code{discretionary-output-flush}.  If so, then that operation is
invoked to flush the buffer.  At present, only the console port defines
@code{discretionary-output-flush}; this is used to guarantee that output
to the console appears immediately after it is written, without
requiring calls to @code{flush-output}.

All optional arguments called @var{output-port}, if not supplied,
default to the current output port.

@deffn {procedure+} flush-output [output-port]
If @var{output-port} is buffered, this causes the contents of its buffer
to be written to the output device.  Otherwise it has no effect.
Returns an unspecified value.
@end deffn

@deffn procedure write-char char [output-port]
@cindex character, output to port
Writes @var{char} (the character itself, not a written representation of
the character) to @var{output-port}, performs discretionary output
flushing, and returns an unspecified value.
@end deffn

@deffn {procedure+} write-string string [output-port]
@cindex string, output to port
Writes @var{string} to @var{output-port}, performs discretionary output
flushing, and returns an unspecified value.  This is equivalent to
writing the contents of string, one character at a time using
@code{write-char}, except that it is usually much faster.
@end deffn

@deffn procedure write object [output-port]
@cindex expression, output to port
Writes a written representation of @var{object} to @var{output-port},
and returns an unspecified value.  If @var{object} has a standard
external representation, then the written representation generated by
@code{write} shall be parsable by @code{read} into an equivalent object.
Thus strings that appear in the written representation are enclosed in
doublequotes, and within those strings backslash and doublequote are
escaped by backslashes.  @code{write} performs discretionary output
flushing and returns an unspecified value.
@end deffn

@deffn procedure display object [output-port]
@cindex external representation, generating
@cindex generating, external representation
Writes a representation of @var{object} to @var{output-port}.  Strings
appear in the written representation as if written by
@code{write-string} instead of by @code{write}.  Character objects
appear in the representation as if written by @code{write-char} instead
of by @code{write}.  @code{display} performs discretionary output
flushing and returns an unspecified value.@footnote{@code{write} is
intended for producing machine-readable output and @code{display} is for
producing human-readable output.}
@end deffn

@deffn procedure newline [output-port]
@cindex newline character, output to port
Writes an end-of-line to @var{output-port}, performs discretionary
output flushing, and returns an unspecified value.  Equivalent to
@code{(write-char #\newline @var{output-port})}.
@end deffn

@deffn {procedure+} fresh-line [output-port]
Some output ports are able to tell whether or not they are at the
beginning of a line of output.  If @var{output-port} is such a port,
this procedure writes an end-of-line to the port only if the port is not
already at the beginning of a line.  If @var{output-port} is not such a
port, this procedure is identical to @code{newline}.  In either case,
@code{fresh-line} performs discretionary output flushing and returns an
unspecified value.
@end deffn

@deffn {procedure+} write-line object [output-port]
Like @code{write}, except that it writes an end-of-line to
@var{output-port} before writing @var{object}'s representation.  This
procedure performs discretionary output flushing and returns an
unspecified value.
@end deffn

@deffn {procedure+} beep [output-port]
@cindex console, ringing the bell
@cindex ringing the console bell
@cindex bell, ringing on console
Performs a ``beep'' operation on @var{output-port}, performs
discretionary output flushing, and returns an unspecified value.  On the
console port, this usually causes the console bell to beep, but more
sophisticated interactive ports may take other actions, such as flashing
the screen.  On most output ports, e.g.@: file and string output ports,
this does nothing.
@end deffn

@deffn {procedure+} clear [output-port]
@cindex console, clearing
@cindex display, clearing
@cindex screen, clearing
@cindex terminal screen, clearing
@cindex clearing the console screen
``Clears the screen'' of @var{output-port}, performs discretionary
output flushing, and returns an unspecified value.  On a terminal or
window, this has a well-defined effect.  On other output ports, e.g.@:
file and string output ports, this does nothing.
@end deffn

@deffn {procedure+} pp object [output-port [as-code?]]
@cindex pretty printer
@code{pp} prints @var{object} in a visually appealing and structurally
revealing manner on @var{output-port}.  If object is a procedure,
@code{pp} attempts to print the source text.  If the optional argument
@var{as-code?} is true, @code{pp} prints lists as Scheme code, providing
appropriate indentation; by default this argument is false.  @code{pp}
performs discretionary output flushing and returns an unspecified value.
@end deffn

The following variables may be dynamically bound to change the behavior
of the @code{write} and @code{display} procedures.

@defvr {variable+} *unparser-radix*
This variable specifies the default radix used to print numbers.  Its
value must be one of the exact integers @code{2}, @code{8}, @code{10},
or @code{16}; the default is @code{10}.  If @code{*unparser-radix*} is
not @code{10}, numbers are prefixed to indicate their radix.
@end defvr

@defvr {variable+} *unparser-list-breadth-limit*
This variable specifies a limit on the length of the printed
representation of a list or vector; for example, if the limit is
@code{4}, only the first four elements of any list are printed, followed
by ellipses to indicate any additional elements.  The value of this
variable must be an exact non-negative integer, or @code{#f} meaning no
limit; the default is @code{#f}.

@example
(fluid-let ((*unparser-list-breadth-limit* 4))
  (write-to-string '(a b c d)))
                                @result{} "(a b c d)"
(fluid-let ((*unparser-list-breadth-limit* 4))
  (write-to-string '(a b c d e)))
                                @result{} "(a b c d ...)"
@end example
@end defvr

@defvr {variable+} *unparser-list-depth-limit*
This variable specifies a limit on the nesting of lists and vectors in
the printed representation.  If lists (or vectors) are more deeply
nested than the limit, the part of the representation that exceeds the
limit is replaced by ellipses.  The value of this variable must be an
exact non-negative integer, or @code{#f} meaning no limit; the default
is @code{#f}.

@example
(fluid-let ((*unparser-list-depth-limit* 4))
  (write-to-string '((((a))) b c d)))
                                @result{} "((((a))) b c d)"
(fluid-let ((*unparser-list-depth-limit* 4))
  (write-to-string '(((((a)))) b c d)))
                                @result{} "((((...))) b c d)"
@end example
@end defvr

@defvr {variable+} *unparser-string-length-limit*
This variable specifies a limit on the length of the printed
representation of strings.  If a string's length exceeds this limit, the
part of the printed representation for the characters exceeding the
limit is replaced by ellipses.  The value of this variable must be an
exact non-negative integer, or @code{#f} meaning no limit; the default
is @code{#f}.

@example
(fluid-let ((*unparser-string-length-limit* 4))
  (write-to-string "abcd"))
                                @result{} "\"abcd\""
(fluid-let ((*unparser-string-length-limit* 4))
  (write-to-string "abcde"))
                                @result{} "\"abcd...\""
@end example
@end defvr

@defvr {variable+} *unparse-with-maximum-readability?*
This variable, which takes a boolean value, tells the printer to use a
special printed representation for objects that normally print in a form
that cannot be recognized by @code{read}.  These objects are printed
using the representation @code{#@@@var{n}}, where @var{n} is the result
of calling @code{hash} on the object to be printed.  The reader
recognizes this syntax, calling @code{unhash} on @var{n} to get back the
original object.  Note that this printed representation can only be
recognized by the Scheme program in which it was generated, because
these hash numbers are different for each invocation of Scheme.
@end defvr

@node Format, Custom Output, Output Procedures, Input/Output
@section Format

@comment **** begin CLTL ****

The procedure @code{format} is very useful for producing nicely
formatted text, producing good-looking messages, and so on.  MIT
Scheme's implementation of @code{format} is similar to that of Common
Lisp, except that Common Lisp defines many more
directives.@footnote{This description of @code{format} is adapted from
@cite{Common Lisp, The Language}, second edition, section 22.3.3.}

@cindex run-time-loadable option
@cindex option, run-time-loadable
@code{format} is a run-time-loadable option.  To use it, execute

@example
(load-option 'format)
@end example
@findex load-option

@noindent
once before calling it.

@deffn {procedure+} format destination control-string argument @dots{}
@findex write-string
@cindex format directive (defn)
@cindex directive, format (defn)
Writes the characters of @var{control-string} to @var{destination},
except that a tilde (@code{~}) introduces a @dfn{format directive}.  The
character after the tilde, possibly preceded by prefix parameters and
modifiers, specifies what kind of formatting is desired.  Most
directives use one or more @var{argument}s to create their output; the
typical directive puts the next @var{argument} into the output,
formatted in some special way.  It is an error if no argument remains
for a directive requiring an argument, but it is not an error if one or
more arguments remain unprocessed by a directive.

The output is sent to @var{destination}.  If @var{destination} is
@code{#f}, a string is created that contains the output; this string is
returned as the value of the call to @code{format}.  In all other cases
@code{format} returns an unspecified value.  If @var{destination} is
@code{#t}, the output is sent to the current output port.  Otherwise,
@var{destination} must be an output port, and the output is sent there.

This procedure performs discretionary output flushing (@pxref{Output
Procedures}).

A @code{format} directive consists of a tilde (@code{~}), optional
prefix parameters separated by commas, optional colon (@code{:}) and
at-sign (@code{@@}) modifiers, and a single character indicating what
kind of directive this is.  The alphabetic case of the directive
character is ignored.  The prefix parameters are generally integers,
notated as optionally signed decimal numbers.  If both the colon and
at-sign modifiers are given, they may appear in either order.

@cindex V as format parameter
@cindex # as format parameter
In place of a prefix parameter to a directive, you can put the letter
@samp{V} (or @samp{v}), which takes an @var{argument} for use as a
parameter to the directive.  Normally this should be an exact integer.
This feature allows variable-width fields and the like.  You can also
use the character @samp{#} in place of a parameter; it represents the
number of arguments remaining to be processed.

It is an error to give a format directive more parameters than it is
described here as accepting.  It is also an error to give colon or
at-sign modifiers to a directive in a combination not specifically
described here as being meaningful.

@table @code
@item ~A
The next @var{argument}, which may be any object, is printed as if by
@code{display}.  @code{~@var{mincol}A} inserts spaces on the right, if
necessary, to make the width at least @var{mincol} columns.  The
@code{@@} modifier causes the spaces to be inserted on the left rather
than the right.

@item ~S
The next @var{argument}, which may be any object, is printed as if by
@code{write}.  @code{~@var{mincol}S} inserts spaces on the right, if
necessary, to make the width at least @var{mincol} columns.  The
@code{@@} modifier causes the spaces to be inserted on the left rather
than the right.

@item ~%
This outputs a @code{#\newline} character.  @code{~@var{n}%} outputs
@var{n} newlines.  No @var{argument} is used.  Simply putting a newline
in @var{control-string} would work, but @code{~%} is often used because
it make the control string look nicer in the middle of a program.

@item ~~
This outputs a tilde.  @code{~@var{n}~} outputs @var{n} tildes.

@item ~@var{newline}
Tilde immediately followed by a newline ignores the newline and any
following non-newline whitespace characters.  With an @code{@@}, the
newline is left in place, but any following whitespace is ignored.  This
directive is typically used when @var{control-string} is too long to fit
nicely into one line of the program:

@example
@group
(define (type-clash-error procedure arg spec actual)
  (format #t
          "~%Procedure ~S~%requires its %A argument ~
           to be of type ~S,~%but it was called with ~
           an argument of type ~S.~%"
          procedure arg spec actual))
@end group
@end example

@code{(type-clash-error 'vector-ref "first" 'integer 'vector)} prints:

@example
@group
Procedure vector-ref
requires its first argument to be of type integer,
but it was called with an argument of type vector.
@end group
@end example

@noindent
Note that in this example newlines appear in the output only as
specified by the @code{~%} directives; the actual newline characters in
the control string are suppressed because each is preceded by a tilde.
@end table
@end deffn

@comment **** end CLTL ****

@node Custom Output, Prompting, Format, Input/Output
@section Custom Output

MIT Scheme provides hooks for specifying that certain kinds of objects
have special written representations.  There are no restrictions on the
written representations, but only a few kinds of objects may have custom
representation specified for them, specifically: records
(@pxref{Records}), vectors that have special tags in their zero-th
elements (@pxref{Vectors}), and pairs that have special tags in their
car fields (@pxref{Lists}).  There is a different procedure for
specifying the written representation of each of these types.

@deffn {procedure+} set-record-type-unparser-method! record-type unparser-method
Changes the unparser method of the type represented by @var{record-type}
to be @var{unparser-method}, and returns an unspecified value.
Subsequently, when the unparser encounters a record of this type, it
will invoke @var{unparser-method} to generate the written
representation.
@end deffn

@deffn {procedure+} unparser/set-tagged-vector-method! tag unparser-method
Changes the unparser method of the vector type represented by @var{tag}
to be @var{unparser-method}, and returns an unspecified value.
Subsequently, when the unparser encounters a vector with @var{tag} as
its zero-th element, it will invoke @var{unparser-method} to generate
the written representation.
@end deffn

@deffn {procedure+} unparser/set-tagged-pair-method! tag unparser-method
Changes the unparser method of the pair type represented by @var{tag} to
be @var{unparser-method}, and returns an unspecified value.
Subsequently, when the unparser encounters a pair with @var{tag} in its
car field, it will invoke @var{unparser-method} to generate the written
representation.
@end deffn

@cindex unparser method (defn)
@cindex method, unparser (defn)
An @dfn{unparser method} is a procedure that is invoked with two
arguments: an unparser state and an object.  An unparser method
generates a written representation for the object, writing it to the
output port specified by the unparser state.  The value yielded by an
unparser method is ignored.  Note that an unparser state is not an
output port, rather it is an object that contains an output port as one
of its components.  Application programs generally do not construct or
examine unparser state objects, but just pass them along.

There are two ways to create an unparser method (which is then
registered by one of the above procedures).  The first, and easiest, is
to use @code{standard-unparser-method}.  The second is to define your
own method using the procedure @code{with-current-unparser-state}.  We
encourage the use of the first method, as it results in a more uniform
appearance for objects.  Many predefined datatypes, for example
procedures and environments, already have this appearance.

@deffn {procedure+} standard-unparser-method name procedure
Returns a standard unparser method.  @var{Name} may be any object, and
is used as the name of the type with which the unparser method is
associated; @var{name} is usually a symbol.  @var{Procedure} must be
@code{#f} or a procedure of two arguments.

@cindex #[ as external representation
If @var{procedure} is @code{#f}, the returned method generates an
external representation of this form:

@example
#[@var{name} @var{hash}]
@end example

@noindent
@findex write
@findex write-string
@findex hash
Here @var{name} is the external representation of the argument
@var{name}, as generated by @code{write},@footnote{Except that if the
argument @var{name} is a string, its external representation is
generated by @code{write-string}.} and @var{hash} is the external
representation of an exact non-negative integer unique to the object
being printed (specifically, it is the result of calling @code{hash} on
the object).  Subsequently, the expression

@example
#@@@var{hash}
@end example

@noindent
is notation for the object.

If @var{procedure} is supplied, the returned method generates a slightly
different external representation:

@example
#[@var{name} @var{hash} @var{output}]
@end example

@noindent
Here @var{name} and @var{hash} are as above, and @var{output} is the
output generated by @var{procedure}.  The representation is constructed
in three stages:

@enumerate
@item
The first part of the format (up to @var{output}) is written to the
output port specified by the unparser state.  This is @code{"#["},
@var{name}, @code{" "}, and @var{hash}.

@item
@var{Procedure} is invoked on two arguments: the object and an output
port.

@item
The closing bracket is written to the output port.
@end enumerate
@end deffn

The following procedure is useful for writing more general kinds of
unparser methods.

@deffn {procedure+} with-current-unparser-state unparser-state procedure
This procedure calls @var{procedure} with one argument, the output port
from @var{unparser-state}.  Additionally, it arranges for the remaining
components of @var{unparser-state} to be given to the printer when they
are needed.  The @var{procedure} generates some output by writing to the
output port using the usual output operations, and the value yielded by
@var{procedure} is returned from @code{with-current-unparser-state}.

The port passed to @var{procedure} should only be used within the
dynamic extent of @var{procedure}.
@end deffn

@node Prompting, Port Primitives, Custom Output, Input/Output
@section Prompting
@cindex prompting

This section describes procedures that prompt the user for input.  Why
should the programmer use these procedures when it is possible to do
prompting using ordinary input and output procedures?  One reason is
that the prompting procedures are more succinct.  However, a second and
better reason is that the prompting procedures can be separately
customized for each user interface, providing more natural interaction.
The interfaces for Edwin and for GNU Emacs have already been customized
in this fashion; because Edwin and Emacs are very similar editors, their
customizations provide very similar behavior.

@findex interaction-i/o-port
Each of these procedure accepts an optional argument called @var{port},
which must be an @sc{i/o} port if given.  If not given, this port
defaults to the value of @code{(interaction-i/o-port)}; this is
initially the console @sc{i/o} port.

The required argument @var{prompt} must be a string.

@deffn {procedure+} prompt-for-command-expression prompt [port]
Prompts the user for an expression that is to be executed as a command.
This is the procedure called by the @sc{rep} loop to read the user's
expressions.

The prompt string is formed by appending a space to @var{prompt}, unless
@var{prompt} already ends in a space or is an empty string.

The default behavior of this procedure is to print two newlines, the
current @sc{rep} loop ``level number'', a space, and the prompt string;
flush the output buffer; then read an object and return it.

Under Edwin and Emacs, before the object is read, the interaction buffer
is put into a mode that allows expressions to be edited and submitted
for input using specific editor commands.  The first expression that is
submitted is returned as the value of this procedure.
@end deffn

@deffn {procedure+} prompt-for-command-char prompt [port]
@findex char-graphic?
Prompts the user for a single character that is to be executed as a
command; the returned character is guaranteed to satisfy
@code{char-graphic?}.  If at all possible, the character is read from
the user interface using a mode that reads the character as a single
keystroke; in other words, it should not be necessary for the user to
follow the character with a carriage return or similar rubbish.

@findex debug
@findex where
This is the procedure called by @code{debug} and @code{where} to read
the user's commands.

The prompt string is formed by appending a space to @var{prompt}, unless
@var{prompt} already ends in a space or is an empty string.

The default behavior of this procedure is to print two newlines, the
current @sc{rep} loop ``level number'', a space, and the prompt string;
flush the output buffer; read a character in raw mode, echo that
character, and return it.

Under Edwin and Emacs, instead of reading a character, the interaction
buffer is put into a mode in which graphic characters submit themselves
as input.  After this mode change, the first such character submitted is
returned as the value of this procedure.
@end deffn

@deffn {procedure+} prompt-for-expression prompt [port]
Prompts the user for an expression.

The prompt string is formed by appending a colon and a space to
@var{prompt}, unless @var{prompt} already ends in a space.

The default behavior of this procedure is to print two newlines and the
prompt string; flush the output buffer; then read an object and return
it.

Under Edwin and Emacs, the expression is read in the minibuffer.
@end deffn

@deffn {procedure+} prompt-for-evaluated-expression prompt [environment [port]]
Prompts the user for an evaluated expression.  Calls
@code{prompt-for-expression} to read an expression, then evaluates the
expression using @var{environment}; if @var{environment} is not given,
the @sc{rep} loop environment is used.
@end deffn

@deffn {procedure+} prompt-for-confirmation prompt [port]
Prompts the user for confirmation.  The result yielded by this procedure
is a boolean.

The prompt string is formed by appending the string @code{" (y or n)? "}
to @var{prompt}, unless @var{prompt} already ends in a space.

The default behavior of this procedure is to print two newlines and the
prompt string; flush the output buffer; then read a character in raw
mode.  If the character is @code{#\y}, @code{#\Y}, or @code{#\space},
the procedure returns @code{#t}; If the character is @code{#\n},
@code{#\N}, or @code{#\rubout}, the procedure returns @code{#f}.
Otherwise the prompt is repeated.

Under Edwin or Emacs, the confirmation is read in the minibuffer.
@end deffn

@node Port Primitives,  , Prompting, Input/Output
@section Port Primitives
@cindex port primitives

This section describes the low-level operations that can be used to
build and manipulate @sc{i/o} ports.

The purpose of these operations is twofold: to allow programmers to
construct new kinds of @sc{i/o} ports, and to provide faster @sc{i/o}
operations than those supplied by the standard high level procedures.
The latter is useful because the standard @sc{i/o} operations provide
defaulting and error checking, and sometimes other features, which are
often unnecessary.  This interface provides the means to bypass such
features, thus improving performance.

@findex eq?
The abstract model of an @sc{i/o} port, as implemented here, is a
combination of a set of named operations and a state.  The state is an
arbitrary object, the meaning of which is determined by the operations.
The operations are defined by a mapping from names to procedures.
Typically the names are symbols, but any object that can be
discriminated by @code{eq?} may be used.

The operations are divided into two classes:

@table @asis
@item Standard operations
There is a specific set of standard operations for input ports, and a
different set for output ports.  Applications can assume that the
standard input operations are implemented for all input ports, and
likewise the standard output operations are implemented for all output
ports.
@cindex standard operations, on port

@item Custom operations
Some ports support additional operations.  For example, ports that
implement output to terminals (or windows) may define an operation named
@code{y-size} that returns the height of the terminal in characters.
Because only some ports will implement these operations, programs that
use custom operations must test each port for their existence, and be
prepared to deal with ports that do not implement them.
@cindex custom operations, on port
@findex y-size
@end table

@menu
* Constructors and Accessors for Ports::  
* Blocking Mode::               
* Terminal Mode::               
* Input Port Operations::       
* Output Port Operations::      
@end menu

@node Constructors and Accessors for Ports, Blocking Mode,  , Port Primitives
@subsection Constructors and Accessors for Ports

The procedures in this section provide means for constructing ports with
custom operations, accessing their operations, and manipulating their
internal state.

@deffn {procedure+} make-input-port operations object
@deffnx {procedure+} make-output-port operations object
@deffnx {procedure+} make-i/o-port operations object
@cindex construction, of port
Operations must be a list; each element is a list of two elements, the
name of the operation and the procedure that implements it.  A new port
is returned with the given operations and a state component of
@var{object}.

@var{Operations} need not contain definitions for all of the standard
operations; the procedure will provide defaults for any standard
operations that are not defined.  At a minimum, the following operations
must be defined: for input ports, @code{read-char}, @code{peek-char},
and @code{char-ready?}; for output ports, either @code{write-char} or
@code{write-substring}; @sc{i/o} ports must supply the minimum
operations for both input and output.
@end deffn

@deffn {procedure+} port/copy port object
@cindex copying, of port
Returns a new copy of @var{port}, identical to the original except that
its state component is @var{object}.  @var{Port} is not modified.

@code{port/copy} is normally used to speed up creation of ports.  This
is done by creating a template using one of the port constructors
@code{make-input-port}, @code{make-output-port}, or
@code{make-i/o-port}, as appropriate; a dummy state component is
supplied for the template.  Then @code{port/copy} is used to make a copy
of the template, supplying the copy with the correct state.  This is
useful because the port constructors are somewhat slow, as they must
parse the @var{operations} list, provide defaulting for missing
operations, etc.

@findex input-port/copy
@findex output-port/copy
For compatibility with old code, @code{input-port/copy} and
@code{output-port/copy} are synonyms for this procedure.
@end deffn

@deffn {procedure+} port/state port
Returns the state component of @var{port}.

@findex input-port/state
@findex output-port/state
For compatibility with old code, @code{input-port/state} and
@code{output-port/state} are synonyms for this procedure.
@end deffn

@deffn {procedure+} set-port/state! port object
Changes the state component of @var{port} to be @var{object}.
Returns an unspecified value.

@findex set-input-port/state!
@findex set-output-port/state!
For compatibility with old code, @code{set-input-port/state!} and
@code{set-output-port/state!} are synonyms for this procedure.
@end deffn

@deffn {procedure+} port/operation port object
Returns the operation named @var{object} in @var{port}.  If @var{port}
has no such operation, returns @code{#f}.

@findex input-port/operation
@findex output-port/operation
@findex input-port/custom-operation
@findex output-port/custom-operation
For compatibility with old code, @code{input-port/operation} and
@code{output-port/operation} are similar to @code{port/operation}.  They
differ in that they translate certain old operation names to new
equivalents before calling @code{port/operation}.
@code{input-port/custom-operation} and
@code{output-port/custom-operation} are synonyms for
@code{input-port/operation} and @code{output-port/operation},
respectively.
@end deffn

@deffn {procedure+} port/operation-names port
Returns a list whose elements are the names of the operations supported
by @code{port}.  The list is not newly allocated and must not be
modified.

@findex input-port/operation-names
@findex output-port/operation-names
For compatibility with old code, @code{input-port/operation-names} and
@code{output-port/operation-names} are synonyms for this procedure.
@end deffn

@deffn {procedure+} make-eof-object input-port
@cindex EOF object, construction
@cindex construction, of EOF object
@findex eof-object?
Returns an object that satisfies the predicate @code{eof-object?}.  This
is sometimes useful when building input ports.
@end deffn

@node Blocking Mode, Terminal Mode, Constructors and Accessors for Ports, Port Primitives
@subsection Blocking Mode

@cindex blocking mode, of port
An interactive port is always in one of two modes: @dfn{blocking} or
@dfn{non-blocking}.  This mode is independent of the terminal mode: each
can be changed independent of the other.  Furthermore, if it is an
interactive @sc{i/o} port, there are separate blocking modes for input
and for output.

If an input port is in blocking mode, attempting to read from it when no
input is available will cause Scheme to ``block'', i.e.@: suspend
itself, until input is available.  If an input port is in non-blocking
mode, attempting to read from it when no input is available will cause
the reading procedure to return immediately, indicating the lack of
input in some way (exactly how this situation is indicated is separately
specified for each procedure or operation).

An output port in blocking mode will block if the output device is not
ready to accept output.  In non-blocking mode it will return immediately
after performing as much output as the device will allow (again, each
procedure or operation reports this situation in its own way).

Interactive ports are initially in blocking mode; this can be changed at
any time with the procedures defined in this section.

These procedures represent blocking mode by the symbol @code{blocking},
and non-blocking mode by the symbol @code{nonblocking}.  An argument
called @var{mode} must be one of these symbols.  A @var{port} argument
to any of these procedures may be any port, even if that port does not
support blocking mode; in that case, the port is not modified in any
way.

@deffn {procedure+} port/input-blocking-mode port
Returns the input blocking mode of @var{port}.
@end deffn

@deffn {procedure+} port/set-input-blocking-mode port mode
Changes the input blocking mode of @var{port} to be @var{mode}.  Returns
an unspecified value.
@end deffn

@deffn {procedure+} port/with-input-blocking-mode port mode thunk
@var{Thunk} must be a procedure of no arguments.
@code{port/with-input-blocking-mode}
binds the input blocking mode of @var{port} to be @var{mode}, executes
@var{thunk}, restores the input blocking mode of @var{port} to what it
was when @code{port/with-input-blocking-mode} was called, and returns
the value that was yielded by @var{thunk}.  This binding is performed
by @code{dynamic-wind}, which guarantees that the input blocking mode is
restored if @var{thunk} escapes from its continuation.
@end deffn

@deffn {procedure+} port/output-blocking-mode port
Returns the output blocking mode of @var{port}.
@end deffn

@deffn {procedure+} port/set-output-blocking-mode port mode
Changes the output blocking mode of @var{port} to be @var{mode}.
Returns an unspecified value.
@end deffn

@deffn {procedure+} port/with-output-blocking-mode port mode thunk
@var{Thunk} must be a procedure of no arguments.
@code{port/with-output-blocking-mode}
binds the output blocking mode of @var{port} to be @var{mode}, executes
@var{thunk}, restores the output blocking mode of @var{port} to what it
was when @code{port/with-output-blocking-mode} was called, and returns
the value that was yielded by @var{thunk}.  This binding is performed
by @code{dynamic-wind}, which guarantees that the output blocking mode
is restored if @var{thunk} escapes from its continuation.
@end deffn

@node Terminal Mode, Input Port Operations, Blocking Mode, Port Primitives
@subsection Terminal Mode

@cindex terminal mode, of port
A port that reads from or writes to a terminal has a @dfn{terminal
mode}; this is either @dfn{cooked} or @dfn{raw}.  This mode is
independent of the blocking mode: each can be changed independent of the
other.  Furthermore, a terminal @sc{i/o} port has independent terminal
modes both for input and for output.

@cindex cooked mode, of terminal port
A terminal port in cooked mode provides some standard processing to make
the terminal easy to communicate with.  For example, under unix, cooked
mode on input reads from the terminal a line at a time and provides
rubout processing within the line, while cooked mode on output might
translate linefeeds to carriage-return/linefeed pairs.  In general, the
precise meaning of cooked mode is operating-system dependent, and
furthermore might be customizable by means of operating system
utilities.  The basic idea is that cooked mode does whatever is
necessary to make the terminal handle all of the usual user-interface
conventions for the operating system, while keeping the program's
interaction with the port as normal as possible.

@cindex raw mode, of terminal port
A terminal port in raw mode disables all of that processing.  In raw
mode, characters are directly read from and written to the device
without any translation or interpretation by the operating system.  On
input, characters are available as soon as they are typed, and are not
echoed on the terminal by the operating system.  In general, programs
that put ports in raw mode have to know the details of interacting with
the terminal.  In particular, raw mode is used for writing programs such
as text editors.

Terminal ports are initially in cooked mode; this can be changed at any
time with the procedures defined in this section.

These procedures represent cooked mode by the symbol @code{cooked}, and
raw mode by the symbol @code{raw}.  Additionally, the value @code{#f}
represents ``no mode''; it is the terminal mode of a port that is not a
terminal.  An argument called @var{mode} must be one of these three
values.  A @var{port} argument to any of these procedures may be any
port, even if that port does not support terminal mode; in that case,
the port is not modified in any way.

@deffn {procedure+} port/input-terminal-mode port
Returns the input terminal mode of @var{port}.
@end deffn

@deffn {procedure+} port/set-input-terminal-mode port mode
Changes the input terminal mode of @var{port} to be @var{mode}.
Returns an unspecified value.
@end deffn

@deffn {procedure+} port/with-input-terminal-mode port mode thunk
@var{Thunk} must be a procedure of no arguments.
@code{port/with-input-terminal-mode}
binds the input terminal mode of @var{port} to be @var{mode}, executes
@var{thunk}, restores the input terminal mode of @var{port} to what it
was when @code{port/with-input-terminal-mode} was called, and returns
the value that was yielded by @var{thunk}.  This binding is performed
by @code{dynamic-wind}, which guarantees that the input terminal mode is
restored if @var{thunk} escapes from its continuation.
@end deffn

@deffn {procedure+} port/output-terminal-mode port
Returns the output terminal mode of @var{port}.
@end deffn

@deffn {procedure+} port/set-output-terminal-mode port mode
Changes the output terminal mode of @var{port} to be @var{mode}.
Returns an unspecified value.
@end deffn

@deffn {procedure+} port/with-output-terminal-mode port mode thunk
@var{Thunk} must be a procedure of no arguments.
@code{port/with-output-terminal-mode}
binds the output terminal mode of @var{port} to be @var{mode}, executes
@var{thunk}, restores the output terminal mode of @var{port} to what it
was when @code{port/with-output-terminal-mode} was called, and returns
the value that was yielded by @var{thunk}.  This binding is performed
by @code{dynamic-wind}, which guarantees that the output terminal mode is
restored if @var{thunk} escapes from its continuation.
@end deffn

@node Input Port Operations, Output Port Operations, Terminal Mode, Port Primitives
@subsection Input Port Operations
@cindex input port operations

This section describes the standard operations on input ports.

@defop {operation+} {input port} read-char input-port
@cindex character, input from port
Removes the next character available from @var{input-port} and returns
it.  If @var{input-port} has no more characters and will never have any
(e.g.@: at the end of an input file), this operation returns an
end-of-file object.  If @var{input-port} has no more characters but will
eventually have some more (e.g.@: a terminal where nothing has been
typed recently), and it is in non-blocking mode, @code{#f} is returned;
otherwise the operation hangs until input is available.
@end defop

@defop {operation+} {input port} peek-char input-port
Reads the next character available from @var{input-port} and returns it.
The character is @emph{not} removed from @var{input-port}, and a
subsequent attempt to read from the port will get that character again.
In other respects this operation behaves like @code{read-char}.
@end defop

@defop {operation+} {input port} discard-char input-port
Discards the next character available from @var{input-port} and returns
an unspecified value.  In other respects this operation behaves like
@code{read-char}.
@end defop

@defop {operation+} {input port} char-ready? input-port k
@code{char-ready?} returns @code{#t} if at least one character is
available to be read from @var{input-port}.  If no characters are
available, the operation waits up to @var{k} milliseconds before
returning @code{#f}, returning immediately if any characters become
available while it is waiting.
@end defop

@defop {operation+} {input port} read-string input-port char-set
@defopx {operation+} {input port} discard-chars input-port char-set
@cindex string, input from port
These operations are like @code{read-char} and @code{discard-char},
except that they read or discard multiple characters at once.  This can
have a marked performance improvement on buffered input ports.  All
characters up to, but excluding, the first character in @var{char-set}
(or end of file) are read from @var{input-port}.  @code{read-string}
returns these characters as a newly allocated string, while
@code{discard-chars} discards them and returns an unspecified value.
These operations hang until sufficient input is available, even if
@var{input-port} is in non-blocking mode.  If end of file is encountered
before any input characters, @code{read-string} returns an end-of-file
object.
@end defop

@deffn {procedure+} input-port/operation/read-char input-port
@deffnx {procedure+} input-port/operation/peek-char input-port
@deffnx {procedure+} input-port/operation/discard-char input-port
@deffnx {procedure+} input-port/operation/char-ready? input-port
@deffnx {procedure+} input-port/operation/read-string input-port
@deffnx {procedure+} input-port/operation/discard-chars input-port
Each of these procedures returns the procedure that implements the
respective operation for @var{input-port}.  Each is equivalent to, but
faster than, @code{input-port/operation} on the respective operation
name:

@example
@group
(input-port/operation/read-char @var{input-port})
(input-port/operation @var{input-port} 'read-char)
@end group
@end example
@end deffn

@deffn {procedure+} input-port/read-char input-port
@deffnx {procedure+} input-port/peek-char input-port
@deffnx {procedure+} input-port/discard-char input-port
@deffnx {procedure+} input-port/char-ready? input-port k
@deffnx {procedure+} input-port/read-string input-port char-set
@deffnx {procedure+} input-port/discard-chars input-port char-set
Each of these procedures invokes the respective operation on
@var{input-port}.  For example, the following are equivalent:

@example
@group
(input-port/read-string @var{input-port} @var{char-set})
((input-port/operation/read-string @var{input-port}) @var{input-port} @var{char-set})
@end group
@end example
@end deffn

@node Output Port Operations,  , Input Port Operations, Port Primitives
@subsection Output Port Operations
@cindex output port operations

This section describes the standard operations on output ports.
Following that, some useful custom operations are described.

@defop {operation+} {output port} write-char output-port char
@cindex character, output to port
Writes @var{char} to @var{output-port} and returns an unspecified value.
@end defop

@defop {operation+} {output port} write-substring output-port string start end
@cindex substring, output to port
Writes the substring specified by @var{string}, @var{start}, and
@var{end} to @var{output-port} and returns an unspecified value.
Equivalent to writing the characters of the substring, one by one, to
@var{output-port}, but is often implemented more efficiently.
@end defop

@defop {operation+} {output port} write-string output-port string
@cindex string, output to port
Writes @var{string} to @var{output-port} and returns an unspecified
value.
@end defop

@defop {operation+} {output port} flush-output output-port
If @var{output-port} is buffered, this causes its buffer to be written
out.  Otherwise it has no effect.  Returns an unspecified value.
@end defop

@defop {operation+} {output port} discretionary-flush-output output-port
If @var{output-port} is buffered, this causes its buffer to be written
out.  Otherwise it has no effect.  Returns an unspecified value.

This operation, if defined, is normally identical to
@code{flush-output}.  However, it is not normally defined, and even when
it is, it is invoked at different times (@pxref{Output Procedures}).
@end defop

@deffn {procedure+} output-port/operation/write-char output-port
@deffnx {procedure+} output-port/operation/write-substring output-port
@deffnx {procedure+} output-port/operation/write-string output-port
@deffnx {procedure+} output-port/operation/flush-output output-port
@deffnx {procedure+} output-port/operation/discretionary-flush-output output-port
Each of these procedures returns the procedure that implements the
respective operation for @var{output-port}.  Each is equivalent to, but
faster than, @code{output-port/operation} on the respective operation
name:

@example
@group
(output-port/operation/write-char @var{output-port})
(output-port/operation @var{output-port} 'write-char)
@end group
@end example
@end deffn

@deffn {procedure+} output-port/write-char output-port char
@deffnx {procedure+} output-port/write-substring output-port string start end
@deffnx {procedure+} output-port/write-string output-port string
@deffnx {procedure+} output-port/flush-output output-port
@deffnx {procedure+} output-port/discretionary-flush-output output-port
Each of these procedures invokes the respective operation on
@var{output-port}.  For example, the following are equivalent:

@example
@group
(output-port/write-char @var{output-port} @var{char})
((output-port/operation/write-char @var{output-port}) @var{output-port} @var{char})
@end group
@end example
@end deffn

The following custom operations are generally useful.

@defop {operation+} {output port} x-size output-port
Returns an exact positive integer that is the width of @var{output-port}
in characters.  If @var{output-port} has no natural width, e.g.@: if it is
a file port, @code{#f} is returned.
@end defop

@defop {operation+} {output port} y-size output-port
Returns an exact positive integer that is the height of
@var{output-port} in characters.  If @var{output-port} has no natural
height, e.g.@: if it is a file port, @code{#f} is returned.
@end defop

@deffn {procedure+} output-port/x-size output-port
This procedure invokes the custom operation whose name is the symbol
@code{x-size}, if it exists.  If the @code{x-size} operation is both
defined and returns a value other than @code{#f}, that value is returned
as the result of this procedure.  Otherwise, @code{output-port/x-size}
returns a default value (currently @code{79}).

@code{output-port/x-size} is useful for programs that tailor their
output to the width of the display (a fairly common practice).  If the
output device is not a display, such programs normally want some
reasonable default width to work with, and this procedure provides
exactly that.
@end deffn

@deffn {procedure+} output-port/y-size output-port
This procedure invokes the custom operation whose name is the symbol
@code{y-size}, if it exists.  If the @code{y-size} operation is defined,
the value it returns is returned as the result of this procedure;
otherwise, @code{#f} is returned.
@end deffn

@node File-System Interface, Error System, Input/Output, Top
@chapter File-System Interface
@cindex file-system interface

The Scheme standard provides a simple mechanism for reading and writing
files: file ports.  MIT Scheme provides additional tools for
dealing with other aspects of the file system:

@itemize @bullet
@item
@dfn{Pathnames} are a reasonably operating system independent tool for
manipulating the component parts of file names.  This can be useful for
implementing defaulting of file name components.
@cindex pathname

@item
Control over the @dfn{current working directory}: the place in the file
system from which relative file names are interpreted.
@cindex current working directory

@item
Procedures that rename, copy, delete, and test for the existence of
files.  Also, procedures that return detailed information about a
particular file, such as its type (directory, link, etc.) or length.

@item
A facility for reading the contents of a directory.
@end itemize

@menu
* Pathnames::                   
* Working Directory::           
* File Manipulation::           
* Directory Reader::            
@end menu

@node Pathnames, Working Directory,  , File-System Interface
@section Pathnames

@comment **** begin CLTL ****
@cindex file name
MIT Scheme programs need to use names to designate files.  The main
difficulty in dealing with names of files is that different file systems
have different naming formats for files.  For example, here is a table
of several file systems (actually, operating systems that provide file
systems) and what equivalent file names might look like for each one:

@example
@group
System          File Name
------          ---------
TOPS-20         <LISPIO>FORMAT.FASL.13
TOPS-10         FORMAT.FAS[1,4]
ITS             LISPIO;FORMAT FASL
MULTICS         >udd>LispIO>format.fasl
TENEX           <LISPIO>FORMAT.FASL;13
VAX/VMS         [LISPIO]FORMAT.FAS;13
UNIX            /usr/lispio/format.fasl
MS-DOS          C:\USR\LISPIO\FORMAT.FAS
@end group
@end example

@cindex filename (defn)
@cindex pathname (defn)
It would be impossible for each program that deals with file names to
know about each different file name format that exists; a new operating
system to which Scheme was ported might use a format different from any
of its predecessors.  Therefore, MIT Scheme provides @emph{two} ways to
represent file names: @dfn{filenames} (also called @dfn{namestrings}),
which are strings in the implementation-dependent form customary for the
file system, and @dfn{pathnames}, which are special abstract data
objects that represent file names in an implementation-independent way.
Procedures are provided to convert between these two representations,
and all manipulations of files can be expressed in machine-independent
terms by using pathnames.

@cindex host, in filename
In order to allow MIT Scheme programs to operate in a network
environment that may have more than one kind of file system, the
pathname facility allows a file name to specify which file system is to
be used.  In this context, each file system is called a @dfn{host}, in
keeping with the usual networking terminology.@footnote{This
introduction is adapted from @cite{Common Lisp, The Language}, second
edition, section 23.1.}
@comment **** end CLTL ****

Note that the examples given in this section are specific to unix
pathnames.  Pathnames for other operating systems have different
external representations.

@menu
* Filenames and Pathnames::     
* Components of Pathnames::     
* Operations on Pathnames::     
* Miscellaneous Pathnames::     
@end menu

@node Filenames and Pathnames, Components of Pathnames,  , Pathnames
@subsection Filenames and Pathnames

Pathname objects are usually created by parsing filenames (character
strings) into component parts.  MIT Scheme provides operations that
convert filenames into pathnames and vice versa.

@deffn {procedure+} ->pathname object
@cindex construction, of pathname
Returns a pathname that is the equivalent of @var{object}.  @var{Object}
must be a pathname or a string.  If @var{object} is a pathname, it is
returned.  If @var{object} is a string, this procedure returns the
pathname that corresponds to the string; in this case it is equivalent
to @code{(parse-namestring @var{object} #f #f)}.

@example
@group
(->pathname "foo")              @result{}  #[pathname 65 "foo"]
(->pathname "/usr/morris")      @result{}  #[pathname 66 "/usr/morris"]
@end group
@end example
@end deffn


@deffn {procedure+} parse-namestring thing [host [defaults]]
@cindex construction, of pathname
This turns @var{thing} into a pathname.
@var{Thing} must be a pathname or a string.
If @var{thing} is a pathname, it is returned.  If @var{thing} is a
string, this procedure returns the pathname that corresponds to the
string, parsed according to the syntax of the file system specified by
@var{host}.

This procedure @emph{does not} do defaulting of pathname components.

The optional arguments are used to determine what syntax should be used
for parsing the string.  In general this is only really useful if your
implementation of MIT Scheme supports more than one file system,
otherwise you would use @code{->pathname}.  If given, @var{host} must be
a host object or @code{#f}, and @var{defaults} must be a pathname.
@var{Host} specifies the syntax used to parse the string.  If @var{host}
is not given or @code{#f}, the host component from @var{defaults} is
used instead; if @var{defaults} is not given, the host component from
@code{*default-pathname-defaults*} is used.
@end deffn

@deffn {procedure+} ->namestring pathname
@cindex conversion, pathname to string
@code{->namestring} returns a newly allocated string that is the
filename corresponding to @var{pathname}.
@example
@group
(->namestring (->pathname "/usr/morris/minor.van"))
     @result{}  "/usr/morris/minor.van"
@end group
@end example
@end deffn


@deffn {procedure+} pathname-simplify pathname
@cindex simplification, of pathname
Returns a pathname that locates the same file or directory as
@var{pathname}, but is in some sense simpler.  Note that
@code{pathname-simplify} might not always be able to simplify the
pathname, e.g.@: on unix with symbolic links the directory
@file{/usr/morris/../} need not be the same as @file{/usr/}.  In cases
of uncertainty the behavior is conservative, returning the original or a
partly simplified pathname.
@example
@group
(pathname-simplify "/usr/morris/../morris/dance")
     @result{}  #[pathname "/usr/morris/dance"]
@end group
@end example
@end deffn

@node Components of Pathnames, Operations on Pathnames, Filenames and Pathnames, Pathnames
@subsection Components of Pathnames
@cindex components, of pathname
@cindex pathname components

@comment **** begin CLTL ****
A pathname object always has six components, described below.  These
components are the common interface that allows programs to work the
same way with different file systems; the mapping of the pathname
components into the concepts peculiar to each file system is taken care
of by the Scheme implementation.

@table @var
@item host
The name of the file system on which the file resides.
@cindex host, pathname component

@item device
Corresponds to the ``device'' or ``file structure'' concept in many host
file systems: the name of a (logical or physical) device containing
files.
@cindex device, pathname component

@item directory
Corresponds to the ``directory'' concept in many host file systems: the
name of a group of related files (typically those belonging to a single
user or project).
@cindex directory, pathname component

@item name
The name of a group of files that can be thought of as conceptually the
``same'' file.
@cindex name, pathname component

@item type
Corresponds to the ``filetype'' or ``extension'' concept in many host
file systems.  This says what kind of file this is.  Files with the same
name but different type are usually related in some specific way, such
as one being a source file, another the compiled form of that source,
and a third the listing of error messages from the compiler.
@cindex type, pathname component

@item version
Corresponds to the ``version number'' concept in many host file systems.
Typically this is a number that is incremented every time the file is
modified.
@cindex version, pathname component
@end table

Note that a pathname is not necessarily the name of a specific file.
Rather, it is a specification (possibly only a partial specification) of
how to access a file.  A pathname need not correspond to any file that
actually exists, and more than one pathname can refer to the same file.
For example, the pathname with a version of @code{newest} may refer to
the same file as a pathname with the same components except a certain
number as the version.  Indeed, a pathname with version @code{newest}
may refer to different files as time passes, because the meaning of such
a pathname depends on the state of the file system.  In file systems
with such facilities as ``links'', multiple file names, logical devices,
and so on, two pathnames that look quite different may turn out to
address the same file.  To access a file given a pathname, one must do a
file-system operation such as @code{open-input-file}.

Two important operations involving pathnames are @dfn{parsing} and
@dfn{merging}.  Parsing is the conversion of a filename (which might be
something supplied interactively  by the users when asked to supply the
name of a file) into a pathname object.  This operation is
implementation-dependent, because the format of filenames is
implementation-dependent.  Merging takes a pathname with missing
components and supplies values for those components from a source of
default values.

Not all of the components of a pathname need to be specified.  If a
component of a pathname is missing, its value is @code{#f}.
Before the file system interface can do anything interesting with a
file, such as opening the file, all the missing components of a pathname
must be filled in.  Pathnames with missing components are used
internally for various purposes; in particular, parsing a namestring
that does not specify certain components will result in a pathname with
missing components.

Any component of a pathname may be the symbol @code{unspecific}, meaning
that the component simply does not exist, for file systems in which such
a value makes no sense.  For example, unix and @sc{ms-dos} file systems
usually do not support version numbers, so the version component for a
unix or @sc{ms-dos} host might be @code{unspecific}.@footnote{This
description is adapted from @cite{Common Lisp, The Language}, second
edition, section 23.1.1.}
@comment **** end CLTL ****

Each component in a pathname is typically one of the following (with
some exceptions that will be described below):

@table @asis
@item a string
This is a @dfn{literal component}.  It is considered to be fully
specified.
@cindex literal component, of pathname
@cindex pathname component, literal
@cindex component, of pathname, literal

@item @code{#f}
This is a @dfn{missing component}.  It is considered to be unspecified.
@cindex #f, as pathname component
@cindex missing component, of pathname
@cindex pathname component, missing
@cindex component, of pathname, missing

@item @code{wild}
This is a @dfn{wildcard component}.  It is useful only when the pathname
is being used with the directory reader, where it means that the
pathname component matches anything.
@cindex wild, as pathname component
@cindex wildcard component, of pathname
@cindex pathname component, wildcard
@cindex component, of pathname, wildcard

@item @code{unspecific}
This is an @dfn{unspecifiable component}.  It is treated the same as a
missing component except that it is not considered to be missing for
purposes of merging or defaulting components.
@cindex unspecifiable component, of pathname
@cindex unspecific, as pathname component
@cindex component, of pathname, unspecific
@end table

The host, directory, and version pathname components are exceptions to
these rules in that they may never be strings, although the values
@code{#f}, @code{wild}, and @code{unspecific} are allowed with their
usual meanings.  Here are the other values allowed for these components:

@itemize @bullet
@item
The host component is of an implementation defined type which may be
tested for using the @code{host?} predicate.

@item
A directory, if it is not one of the above values, must be a non-empty
list, which represents a @dfn{directory path}: a sequence of
directories, each of which has a name in the previous directory, the
last of which is the directory specified by the entire path.  Each
element in such a path specifies the name of the directory relative to
the directory specified by the elements to its left.
The first element of the list is either the symbol @code{absolute} or the symbol @code{relative}.  If the first
element in the list is the symbol @code{absolute}, then the directory
component (and subsequently the pathname) is @dfn{absolute}; the first
component in the sequence is to be found at the ``root'' of the file
system.  If the directory is @dfn{relative} then the
first component is to be found in some as yet unspecified directory;
typically this is later specified to be the @dfn{current working
directory}.
@cindex root, as pathname component
@cindex directory path (defn)
@cindex path, directory (defn)

@cindex up, as pathname component
@cindex parent, of directory
Aside from @code{absolute} and @code{relative}, which may only appear as
the first element of the list, each subsequent element in the list is
either a string or the symbol @code{wild} (each with the same meaning as
described above), or @code{up}, which means the next directory is the
``parent'' of the previous one.  @code{up} corresponds to the file
@file{..} in unix file systems.

In file systems that do not have ``hierarchical'' structure, a specified
directory component will always be a list whose first element is
@code{absolute}.  If the system does not support directories other than a
single global directory, the list will have no other elements.  If the
system supports ``flat'' directories, i.e.@: a global set of directories
with no subdirectories, then the list will contain a second element,
which is either a string or @code{wild}.  In other words, a
non-hierarchical file system is treated as if it were hierarchical, but
the hierarchical features are unused.  This representation is somewhat
inconvenient for such file systems, but it discourages programmers from
making code depend on the lack of a file hierarchy.  Fortunately few
such file systems are in common use today.

@item
A version component may take the following values: an exact positive
integer, which is a literal component; the symbol @code{newest}, which
means to choose the largest available version number for that file; or
the symbol @code{oldest}, which means to choose the smallest version
number.  In the future some other possible values may be added, e.g.@:
@code{installed}.  Note that in the current implementation there are no
file systems that support version numbers; thus this component is not
used and should be specified as @code{#f}.
@cindex newest, as pathname component
@cindex oldest, as pathname component
@cindex installed, as pathname component
@end itemize

@deffn {procedure+} make-pathname host device directory name type version
@cindex construction, of pathname
Returns a pathname object whose components are the respective arguments.
Each argument must satisfy the restrictions for the corresponding
component, which were outlined above.

@example
@group
(make-pathname #f #f '(absolute "usr" "morris") "foo" "scm" #f)
     @result{}  #[pathname 67 "/usr/morris/foo.scm"]
@end group
@end example
@end deffn

@deffn {procedure+} pathname-host pathname
@deffnx {procedure+} pathname-device pathname
@deffnx {procedure+} pathname-directory pathname
@deffnx {procedure+} pathname-name pathname
@deffnx {procedure+} pathname-type pathname
@deffnx {procedure+} pathname-version pathname
Returns a particular component of @var{pathname}.

@example
@group
(define x (->pathname "/usr/morris/foo.scm"))
(pathname-host x)       @result{}  #[host 1]
(pathname-device x)     @result{}  unspecific
(pathname-directory x)  @result{}  (absolute "usr" "morris")
(pathname-name x)       @result{}  "foo"
(pathname-type x)       @result{}  "scm"
(pathname-version x)    @result{}  unspecific
@end group
@end example
@end deffn

@deffn {procedure+} pathname-new-device pathname device
@deffnx {procedure+} pathname-new-directory pathname directory
@deffnx {procedure+} pathname-new-name pathname name
@deffnx {procedure+} pathname-new-type pathname type
@deffnx {procedure+} pathname-new-version pathname version
Returns a new copy of @var{pathname} with the respective component
replaced by the second argument.  @var{Pathname} is unchanged.
Portable programs should not explicitly replace a component with
@code{unspecific} because this might not be permitted in some
situations.

@example
@group
(define p (->pathname "/usr/blisp/rel15"))
p
     @result{}  #[pathname 71 "/usr/blisp/rel15"]
(pathname-new-name p "rel100")
     @result{}  #[pathname 72 "/usr/blisp/rel100"]
(pathname-new-directory p '(relative "test" "morris"))
     @result{}  #[pathname 73 "test/morris/rel15"]
p
     @result{}  #[pathname 71 "/usr/blisp/rel15"]
@end group
@end example
@end deffn

@deffn {procedure+} pathname-default-device pathname device
@deffnx {procedure+} pathname-default-directory pathname directory
@deffnx {procedure+} pathname-default-name pathname name
@deffnx {procedure+} pathname-default-type pathname type
@deffnx {procedure+} pathname-default-version pathname version
These operations are similar to the @code{pathname-new-@var{component}}
operations, except that they only change the specified @var{component}
if it has the value @code{#f} in @var{pathname}.
@end deffn

@node Operations on Pathnames, Miscellaneous Pathnames, Components of Pathnames, Pathnames
@subsection Operations on Pathnames

@deffn {procedure+} pathname? object
@cindex type predicate, for pathname
Returns @code{#t} if @var{object} is a pathname; otherwise returns
@code{#f}.
@end deffn

@deffn {procedure+} pathname=? pathname1 pathname2
@cindex equivalence predicate, for pathnames
Returns @code{#t} if @var{pathname1} is equivalent to @var{pathname2};
otherwise returns @code{#f}.
Pathnames are equivalent if all of their components are equivalent,
hence two pathnames that are equivalent must identify the same file or
equivalent partial pathnames.
However, the converse is not true: non-equivalent pathnames may specify
the same file (e.g.@: via absolute and relative directory components),
and pathnames that specify no file at all (e.g.@: name and directory
components unspecified) may be equivalent.
@end deffn

@deffn {procedure+} pathname-absolute? pathname
Returns @code{#t} if @var{pathname} is an absolute rather than relative
pathname object; otherwise returns @code{#f}.  All pathnames are either
absolute or relative, so if this procedure returns @code{#f}, the
argument is a relative pathname.
@end deffn

@deffn {procedure+} pathname-wild? pathname
Returns @code{#t} if @var{pathname} contains any wildcard components;
otherwise returns @code{#f}.
@end deffn

@deffn {procedure+} merge-pathnames pathname [defaults [default-version]]
@cindex merging, of pathnames
@cindex defaulting, of pathname
Returns a pathname whose components are obtained by combining those of
@var{pathname} and @var{defaults}.  @var{Defaults} defaults to the value
of @code{*default-pathname-defaults*} and @var{default-version} defaults
to @code{newest}.

The pathnames are combined by components: if @var{pathname} has a
non-missing component, that is the resulting component, otherwise the
component from @var{defaults} is used.
The default version can be @code{#f} to preserve the information that
the component was missing from @var{pathname}.
The directory component is handled specially: if both pathnames have
directory components that are lists, and the directory component from
@var{pathname} is relative (i.e.@: starts with @code{relative}), then the
resulting directory component is formed by appending @var{pathname}'s
component to @var{defaults}'s component.
For example:

@example
@group
(define path1 (->pathname "scheme/foo.scm"))
(define path2 (->pathname "/usr/morris"))
path1
     @result{}  #[pathname 74 "scheme/foo.scm"]
path2
     @result{}  #[pathname 75 "/usr/morris"]
(merge-pathnames path1 path2)
     @result{}  #[pathname 76 "/usr/scheme/foo.scm"]
(merge-pathnames path2 path1)
     @result{}  #[pathname 77 "/usr/morris.scm"]
@end group
@end example

The merging rules for the version are more complex and depend on whether
@var{pathname} specifies a name.  If @var{pathname} does not specify a
name, then the version, if not provided, will come from @var{defaults}.
However, if @var{pathname} does specify a name then the version is not
affected by @var{defaults}.  The reason is that the version ``belongs
to'' some other file name and is unlikely to have anything to do with
the new one.  Finally, if this process leaves the version missing, then
@var{default-version} is used.

The net effect is that if the user supplies just a name, then the host,
device, directory and type will come from @var{defaults}, but the
version will come from @var{default-version}.  If the user supplies
nothing, or just a directory, the name, type and version will come over
from @var{defaults} together.
@end deffn

@defvr {variable+} *default-pathname-defaults*
@cindex defaulting, of pathname
This is the default pathname-defaults pathname; if any pathname
primitive that needs a set of defaults is not given one, it uses this
one.  @code{set-working-directory-pathname!} sets this variable to a new
value, computed by merging the new working directory with the variable's
old value.
@end defvr

@deffn {procedure+} pathname-default pathname device directory name type version
This procedure defaults all of the components of @var{pathname}
simultaneously.  It could have been defined by:

@example
@group
(define (pathname-default pathname
                          device directory name type version)
  (make-pathname (pathname-host pathname)
                 (or (pathname-device pathname) device)
                 (or (pathname-directory pathname) directory)
                 (or (pathname-name pathname) name)
                 (or (pathname-type pathname) type)
                 (or (pathname-version pathname) version)))
@end group
@end example
@end deffn

@deffn {procedure+} file-namestring pathname
@deffnx {procedure+} directory-namestring pathname
@deffnx {procedure+} host-namestring pathname
@deffnx {procedure+} enough-namestring pathname [defaults]
@cindex conversion, pathname to string
These procedures return a string corresponding to a subset of the
@var{pathname} information.  @code{file-namestring} returns a string
representing just the @var{name}, @var{type} and @var{version}
components of @var{pathname}; the result of @code{directory-namestring}
represents just the @var{host}, @var{device}, and @var{directory}
components; and @code{host-namestring} returns a string for just the
@var{host} portion.

@code{enough-namestring} takes another argument, @var{defaults}.
It returns an abbreviated namestring that is just sufficient to identify
the file named by @var{pathname} when considered relative to the
@var{defaults} (which defaults to @code{*default-pathname-defaults*}).

@example
@group
(file-namestring "/usr/morris/minor.van")
     @result{}  "minor.van"
(directory-namestring "/usr/morris/minor.van")
     @result{}  "/usr/morris/"
(enough-namestring "/usr/morris/men")
     @result{}  "men"      @r{;perhaps}
@end group
@end example
@end deffn

@deffn {procedure+} file-pathname pathname
@deffnx {procedure+} directory-pathname pathname
@deffnx {procedure+} enough-pathname pathname [defaults]
@cindex selection, components of pathname
These procedures return a pathname corresponding to a subset of the
@var{pathname} information.
@code{file-pathname} returns a pathname with just the
@var{name}, @var{type} and @var{version} components of @var{pathname}.
The result of @code{directory-pathname} is a pathname containing the
@var{host}, @var{device} and @var{directory} components of @var{pathname}.

@code{enough-pathname} takes another argument, @var{defaults}.
It returns an abbreviated pathname that is just sufficient to identify
the file named by @var{pathname} when considered relative to the
@var{defaults} (which defaults to @code{*default-pathname-defaults*}).

These procedures are similar to @code{file-namestring},
@code{directory-namestring} and @code{enough-namestring}, but they
return pathnames instead of strings.
@end deffn

@deffn {procedure+} directory-pathname-as-file pathname
@cindex file, converting pathname directory to
Returns a pathname that is equivalent to @var{pathname}, but in which
the directory component is represented as a file.
The last directory is removed from the directory component and converted
into name and type components.
This is the inverse operation to @code{pathname-as-directory}.
@example
@group
(directory-pathname-as-file (->pathname "/usr/blisp/"))
     @result{}  #[pathname "/usr/blisp"]
@end group
@end example
@end deffn

@deffn {procedure+} pathname-as-directory pathname
@cindex directory, converting pathname to
Returns a pathname that is equivalent to @var{pathname}, but in which
any file components have been converted to a directory component.  If
@var{pathname} does not have name, type, or version components, it is
returned without modification.  Otherwise, these file components are
converted into a string, and the string is added to the end of the list
of directory components.  This is the inverse operation to
@code{directory-pathname-as-file}.

@example
@group
(pathname-as-directory (->pathname "/usr/blisp/rel5"))
     @result{}  #[pathname "/usr/blisp/rel5/"]
@end group
@end example
@end deffn


@node Miscellaneous Pathnames,  , Operations on Pathnames, Pathnames
@subsection Miscellaneous Pathname Procedures
@cindex directory, reading

This section gives some standard operations on host objects, and some
procedures that return some useful pathnames.

@defvr {variable+} local-host
This variable has as its value the host object that describes the local
host's file system.
@end defvr

@deffn {procedure+} host? object
@cindex type predicate, for pathname host
Returns @code{#t} if @var{object} is a pathname host; otherwise returns
@code{#f}.
@end deffn

@deffn {procedure+} host=? host1 host2
@cindex equivalence predicate, for pathname host
Returns @code{#t} if @var{host1} and @var{host2} denote the same
pathname host; otherwise returns @code{#f}.
@end deffn

@deffn {procedure+} init-file-pathname [host]
@cindex home directory, as pathname
Returns a pathname for the user's initialization file on @var{host}.
The @var{host} argument defaults to the value of @code{local-host}.  If
the initialization file does not exist this procedure returns @code{#f}.
@end deffn

@deffn {procedure+} user-homedir-pathname [host]
@cindex home directory, as pathname
Returns a pathname for the user's ``home directory'' on @var{host}.  The
@var{host} argument defaults to the value of @code{local-host}.  The
concept of a ``home directory'' is itself somewhat
implementation-dependent, but it should be the place where the user
keeps personal files, such as initialization files and mail.  For
example, on unix this is the user's unix home directory, whereas on
@sc{ms-dos} the home directory is determined from the @code{HOME},
@code{USER} and @code{USERDIR} environment variables.
@end deffn

@deffn {procedure+} system-library-pathname pathname
@cindex library, system pathname
Locates @var{pathname} in MIT Scheme's system library directory.  An
error of type @code{condition-type:file-operation-error} is signalled if
@var{pathname} cannot be located on the library search path.
@findex condition-type:file-operation-error

@example
@group
(system-library-pathname "compiler.com")
     @result{} #[pathname 45 "/usr/local/lib/mit-scheme/compiler.com"]
@end group
@end example
@end deffn

@deffn {procedure+} system-library-directory-pathname pathname
@cindex library, system pathname
Locates the pathname of a MIT Scheme system library directory.  An error
of type @code{condition-type:file-operation-error} is signalled if
@var{pathname} cannot be located on the library search path.

@example
@group
(system-library-directory-pathname "options")
     @result{} #[pathname 44 "/usr/local/lib/mit-scheme/options/"]
@end group
@end example
@end deffn

@node Working Directory, File Manipulation, Pathnames, File-System Interface
@section Working Directory

@cindex absolute pathname (defn)
@cindex pathname, absolute (defn)
@cindex relative pathname (defn)
@cindex pathname, relative (defn)
@cindex directory, current working (defn)
@cindex current working directory (defn)
@cindex working directory (see current working directory)
When MIT Scheme is started, the @dfn{current working
directory} (or simply, @dfn{working directory}) is initialized in an
operating-system dependent manner; usually, it is the directory in which
Scheme was invoked.  The working directory can be determined from within
Scheme by calling the @code{pwd} procedure, and changed by calling the
@code{cd} procedure.  Each @sc{rep} loop has its own working directory,
and inferior @sc{rep} loops initialize their working directory from the
value in effect in their superior at the time they are created.

@deffn {procedure+} working-directory-pathname
@deffnx {procedure+} pwd
Returns the current working directory as a pathname that has no name,
type, or version components, just host, device, and directory
components.  @code{pwd} is an alias for
@code{working-directory-pathname}; the long name is intended for
programs and the short name for interactive use.
@end deffn

@deffn {procedure+} set-working-directory-pathname! filename
@deffnx {procedure+} cd filename
@findex ->pathname
@findex pathname-as-directory
Makes @var{filename} the current working directory and returns the new
current working directory as a pathname.  @var{Filename} is coerced to a
pathname using @code{pathname-as-directory}.  @code{cd} is an alias for
@code{set-working-directory-pathname!}; the long name is intended for
programs and the short name for interactive use.

Additionally, @code{set-working-directory-pathname!} modifies the value
of @code{*default-pathname-defaults*} by merging the new working
directory into it.

In the unix implementation, when this procedure is executed in the
top-level @sc{rep} loop, it changes the working directory of the running
Scheme executable.

@example
@group
(set-working-directory-pathname! "/usr/morris/blisp")
     @result{}  #[pathname "/usr/morris/blisp/"]
(set-working-directory-pathname! "~")
     @result{}  #[pathname "/usr/morris/"]
@end group
@end example

This procedure signals an error if @var{filename} does not refer to an
existing directory.

If @var{filename} describes a relative rather than absolute pathname,
this procedure interprets it as relative to the current working
directory, before changing the working directory.

@example
@group
(working-directory-pathname)
     @result{}  #[pathname "/usr/morris/"]
(set-working-directory-pathname! "foo")
     @result{}  #[pathname "/usr/morris/foo/"]
@end group
@end example
@end deffn

@deffn {procedure+} with-working-directory-pathname filename thunk
This procedure temporarily rebinds the current working directory to
@var{filename}, invokes @var{thunk} (a procedure of no arguments), then
restores the previous working directory and returns the value yielded by
@var{thunk}.  @var{Filename} is coerced to a pathname using
@code{pathname-as-directory}.  In addition to binding the working
directory, @code{with-working-directory-pathname} also binds the
variable @code{*default-pathname-defaults*}, merging the old value of
that variable with the new working directory pathname.  Both bindings
are performed in exactly the same way as fluid binding of a variable
(@pxref{Fluid Binding}).
@end deffn

@node File Manipulation, Directory Reader, Working Directory, File-System Interface
@section File Manipulation

This section describes procedures that manipulate files and directories.
Any of these procedures can signal a number of errors for many reasons.
The specifics of these errors are much too operating-system dependent to
document here.  However, if such an error is signalled by one of
these procedures, it will be of type
@code{condition-type:file-operation-error}.
@findex condition-type:file-operation-error

@deffn {procedure+} file-exists? filename
@cindex existence, testing of file
Returns @code{#t} if @var{filename} is an existing file or directory;
otherwise returns @code{#f}.  In operating systems that support symbolic
links, if the file is a symbolic link, this procedure tests the
existence of the file linked to, not the link itself.
@end deffn

@deffn {procedure+} copy-file source-filename target-filename
@cindex copying, of file
Makes a copy of the file named by @var{source-filename}.  The copy is
performed by creating a new file called @var{target-filename}, and
filling it with the same data as @var{source-filename}.  If
@var{target-filename} exists prior to this procedure's invocation, it is
deleted before the new output file is created.
@end deffn

@deffn {procedure+} rename-file source-filename target-filename
@cindex renaming, of file
@cindex name, of file
Changes the name of @var{source-filename} to be @var{target-filename}.
In the unix implementation, this will not rename across file systems.
@end deffn

@deffn {procedure+} delete-file filename
@cindex deletion, of file
Deletes the file named @var{filename}.
@end deffn

@deffn {procedure+} ->truename filename
@cindex truename, of input file
This procedure attempts to discover and return the ``true name'' of the
file associated with @var{filename} within the file system.  An error of
type @code{condition-type:file-operation-error} is signalled if the
appropriate file cannot be located within the file system.
@findex condition-type:file-operation-error
@end deffn

@deffn {procedure+} call-with-temporary-filename procedure
@code{call-with-temporary-filename} generates a temporary filename, and
calls @var{procedure} with that filename as its sole argument.  The
filename is guaranteed not to refer to any existing file, and, barring
unusual circumstances, it can be used to open an output file without
error.  When @var{procedure} returns, if the file referred to by the
filename exists, it is deleted; then, the value yielded by
@var{procedure} is returned.  If @var{procedure} escapes from its
continuation, and the file referred to by the filename exists, it is
deleted.
@end deffn

@deffn {procedure+} file-directory? filename
@cindex directory, predicate for
Returns @code{#t} if the file named @var{filename} exists and is a
directory.  Otherwise returns @code{#f}.  In operating systems that
support symbolic links, if @var{filename} names a symbolic link, this
examines the file linked to, not the link itself.
@end deffn

@deffn {procedure+} file-symbolic-link? filename
@cindex symbolic link, predicate for
In operating systems that support symbolic links, if the file named
@var{filename} exists and is a symbolic link, this procedure returns the
contents of the symbolic link as a newly allocated string.  The returned
value is the name of the file that the symbolic link points to and must
be interpreted relative to the directory of @var{filename}.  If
@var{filename} either does not exist or is not a symbolic link, or if
the operating system does not support symbolic links, this procedure
returns @code{#f}.
@end deffn

@deffn {procedure+} file-readable? filename
Returns @code{#t} if @var{filename} names a file that can be opened for
input; i.e.@: a @dfn{readable} file.  Otherwise returns @code{#f}.
@end deffn

@deffn {procedure+} file-writable? filename
Returns @code{#t} if @var{filename} names a file that can be opened for
output; i.e.@: a @dfn{writable} file.  Otherwise returns @code{#f}.
@end deffn

@deffn {procedure+} file-access filename mode
@var{Mode} must be an exact integer between @code{0} and @code{7}
inclusive; it is a bitwise-encoded predicate selector with @code{1}
meaning ``executable'', @code{2} meaning ``writable'', and @code{4}
meaning ``readable''.  @code{file-access} returns @code{#t} if
@var{filename} exists and satisfies the predicates selected by
@var{mode}.  For example, if @var{mode} is @code{5}, then @var{filename}
must be both readable and executable.  If @var{filename} doesn't exist,
or if it does not satisfy the selected predicates, @code{#f} is
returned.
@end deffn

@deffn {procedure+} file-modes filename
If @var{filename} names an existing file, @code{file-modes} returns an
exact non-negative integer encoding the file's permissions.  The
encoding of this integer is operating-system dependent, but typically it
contains bits that indicate what users and processes are allowed to
read, write, or execute the file.  If @var{filename} does not name an
existing file, @code{#f} is returned.
@end deffn

@deffn {procedure+} set-file-modes! filename modes
@var{Filename} must name an existing file.  @var{Modes} must be an exact
non-negative integer that could have been returned by a call to
@code{file-modes}.  @code{set-file-modes!} modifies the file's
permissions to be those encoded by @var{modes}.
@end deffn

@deffn {procedure+} file-modification-time filename
@cindex modification time, of file
Returns the modification time of @var{filename} as an exact integer.
The result may be compared to other file times using ordinary integer
arithmetic.  If @var{filename} names a file that does not exist,
@code{file-modification-time} returns @code{#f}.

@findex file-modification-time-direct
@findex file-modification-time-indirect
In operating systems that support symbolic links, if @var{filename}
names a symbolic link, @code{file-modification-time} returns the
modification time of the file linked to.  An alternate procedure,
@code{file-modification-time-direct}, returns the modification time of
the link itself; in all other respects it is identical to
@code{file-modification-time}.  For symmetry,
@code{file-modification-time-indirect} is a synonym of
@code{file-modification-time}.
@end deffn

@deffn {procedure+} file-access-time filename
@cindex access time, of file
Returns the access time of @var{filename} as an exact integer.  The
result may be compared to other file times using ordinary integer
arithmetic.  If @var{filename} names a file that does not exist,
@code{file-access-time} returns @code{#f}.

Some operating systems don't implement access times; in those systems
@code{file-access-time} returns an unspecified value.

@findex file-access-time-direct
@findex file-access-time-indirect
In operating systems that support symbolic links, if @var{filename}
names a symbolic link, @code{file-access-time} returns the access time
of the file linked to.  An alternate procedure,
@code{file-access-time-direct}, returns the access time of the link
itself; in all other respects it is identical to
@code{file-access-time}.  For symmetry, @code{file-access-time-indirect}
is a synonym of @code{file-access-time}.
@end deffn

@deffn {procedure+} set-file-times! filename access-time modification-time
@var{Filename} must name an existing file, while @var{access-time} and
@var{modification-time} must be valid file times that might have been
returned by @code{file-access-time} and @code{file-modification-time},
respectively.  @code{set-file-times!} alters the access and modification
times of the file specified by @var{filename} to the values given by
@var{access-time} and @var{modification-time}, respectively.  For
convenience, either of the time arguments may be specified as @code{#f};
in this case the corresponding time is not changed.
@code{set-file-times!} returns an unspecified value.
@end deffn

@deffn {procedure+} file-attributes filename
@cindex attribute, of file
This procedure determines if the file named @var{filename} exists, and
returns information about it if so; if the file does not exist, it
returns @code{#f}.  The information returned is a vector of 10 items:

@enumerate
@item
The file type: @code{#t} if the file is a directory, a character string
(the name linked to) if a symbolic link, or @code{#f} for all other
types of file.

@item
The number of links to the file.

@item
The user id of the file's owner, an exact non-negative integer.

@item
The group id of the file's group, an exact non-negative integer.

@item
The last access time of the file, an exact non-negative integer.

@item
The last modification time of the file, an exact non-negative integer.

@item
The last change time of the file, an exact non-negative integer.

@item
The size of the file in bytes.

@item
The mode string of the file.  This is a newly allocated string showing
the file's mode bits.

@item
The inode number of the file, an exact non-negative integer.
@end enumerate

@findex file-attributes-direct
@findex file-attributes-indirect
In operating systems that support symbolic links, if @var{filename}
names a symbolic link, @code{file-attributes} returns the attributes of
the link itself.  An alternate procedure,
@code{file-attributes-indirect}, returns the attributes of the file
linked to; in all other respects it is identical to
@code{file-attributes}.  For symmetry, @code{file-attributes-direct} is
a synonym of @code{file-attributes}.
@end deffn

@node Directory Reader,  , File Manipulation, File-System Interface
@section Directory Reader
@cindex directory, reading

@deffn {procedure+} directory-read directory [sort?]
@var{Directory} must be an object that can be converted into a pathname
by @code{->pathname}.  The directory specified by @var{directory} is
read, and the contents of the directory is returned as a newly allocated
list of absolute pathnames.  The result is sorted according to the usual
sorting conventions for directories, unless @var{sort?} is specified as
@code{#f}.  If @var{directory} has name, type, or version components,
the returned list contains only those pathnames whose name, type, and
version components match those of @var{directory}; @code{wild} or
@code{#f} as one of these components means ``match anything''.
@end deffn

@node Error System, Graphics, File-System Interface, Top
@chapter Error System

@findex error
The Scheme error system provides a uniform mechanism for the signalling of
errors and other exceptional conditions.  For most purposes, the only part
of the error system that is needed is the special form @code{error}, which
is used to signal simple errors, specifying a message and some irritant
objects (@pxref{Simple Errors}).  In addition, an option to @code{error}
permits users to do simple formatting of their error messages
(@pxref{Error Messages}).

More demanding applications require more powerful facilities.  To give a
concrete example, suppose you want floating-point division to return a very
large number whenever the denominator is zero.  This behavior can be
implemented using the error system.

The Scheme arithmetic system can signal many different kinds of errors,
including floating-point divide by zero.  In our example, we would like to
handle this particular condition specially, allowing the system to handle
other arithmetic errors in its usual way.

The error system supports this kind of application by providing
mechanisms for distinguishing different types of error conditions and
for the specification of where control should be transferred should a
given condition arise.  In this example, there is a specific object
that represents the ``floating-point divide by zero'' condition type,
and it is possible to dynamically specify an arbitrary Scheme procedure
to be executed when a condition of that type is signalled.  This
procedure then finds the stack frame containing the call to the division
operator, and returns the appropriate value from that frame.

Another kind of behavior that is useful is the ability to specify uniform
handling for related classes of conditions.  For example, it might be
desirable, when opening a file for input, to gracefully handle a variety of
different conditions associated with the file system.  One such condition
might be that the file does not exist, in which case the program will try
some other action, perhaps opening a different file instead.  Another
related condition is that the file exists, but is read protected, so it
cannot be opened for input.  If these or any other related conditions
occur, the program would like to skip this operation and move on to
something else.

At the same time, errors unrelated to the file system should be treated in
their usual way.  For example, calling @code{car} on the argument @code{3}
should signal an error.  Or perhaps the name given for the file is
syntactically incorrect, a condition that probably wants to be handled
differently from the case of the file not existing.

@cindex taxonomical link, of condition type (defn)
@cindex specialization, of condition types (defn)
@cindex generalization, of condition types (defn)
To facilitate the handling of classes of conditions, the error system
taxonomically organizes all condition types.  The types are related to one
another by @dfn{taxonomical links}, which specify that one type is a ``kind
of'' another type.  If two types are linked this way, one is considered to
be a @dfn{specialization} of the other; or vice-versa, the second is a
@dfn{generalization} of the first.  In our example, all of the errors
associated with opening an input file would be specializations of the
condition type ``cannot open input file''.

The taxonomy of condition types imposes a partial order on the types,
because each type is allowed to have multiple generalizations.  This is
allowed because some condition types can be generalized in several
different ways.  An example of this is ``floating-point divide by zero'',
which can be generalized to either a ``floating-point overflow'' or a
``divide by zero''.  The latter generalization, ``divide by zero'', cannot
be a specialization of the former, because it can also be signalled by
arithmetic on numbers other than floating-point.

To summarize, the error system provides facilities for the following tasks.
The sections that follow will describe these facilities in more
detail.

@table @asis
@item Signalling conditions
Conditions may be signalled in a number of different ways.  Simple
errors may be signalled, without explicitly defining a condition type,
using @code{error}.  The @code{signal-condition} procedure provides the
most general signalling mechanism.

@item Handling conditions
The programmer can dynamically specify handlers for particular condition
types or for classes of condition types, by means of the
@code{bind-condition-handler} procedure.  Individual handlers have
complete control over the handling of a condition, and additionally may
decide not to handle a particular condition, passing it on to
previously bound handlers.

@item Classification of conditions
Each condition has a type, which is represented by a
@code{condition-type} object.  Each condition type may be a
specialization of some other condition types.  A group of types that
share a common generalization can be handled uniformly by specifying a
handler for the generalization.

@item Packaging condition state
Each condition is represented by an explicit object.  Condition objects
contain information about the nature of the condition as well as
information that describes the state of the computation from which the
condition arose.
@end table

@menu
* Simple Errors::               
* Error Handler::               
* Error Messages::              
* Condition Types::             
* Condition Instances::         
* Condition Signalling::        
* Condition Handling::          
* Predefined Errors::           
@end menu

@node Simple Errors, Error Handler,  , Error System
@section Simple Errors

@cindex irritants, of error (defn)
The simplest error-signalling mechanism is the special form
@code{error}.  It allows the programmer to signal errors by specifying
an error message and providing a list of some objects (@dfn{irritants})
that are relevant to the error.

@deffn {special form+} error message irritant @dots{}
Signals an error.  This special form expands into the following code:

@example
(error-procedure @var{message} (list @var{irritant} @dots{}) (the-environment))
@end example

@noindent
@findex the-environment
The use of @code{the-environment} would normally force the environment
in which it appears to be an interpreter environment.  However, the
compiler treats @code{error} expressions specially so that errors signalled
from compiled code do not supply the environment argument to
@code{error-procedure}.
@end deffn

@deffn {procedure+} error-procedure message irritants environment
Signals an error.  @var{Message} is normally a short string that
summarizes the error, and @var{irritants} is a list of objects that
contain interesting information about the error.  @var{Environment} is
the environment in which the error occurred.

Normally, the message and irritants are used to build a condition whose
type is @code{error-type:vanilla}, @var{environment} is attached to that
condition, and then the condition is signalled.  However, if
@var{message} is a @code{condition-type} object, then that object is
used (instead of @code{error-type:vanilla}) to build the condition.

The argument @var{environment} is used by the standard error handler.
Currently there is no mechanism to retrieve this information.
@end deffn

@defvr {condition type+} error-type:vanilla
This is the error type used by @code{error-procedure} when it signals
anonymous errors.  Do not use this type for signalling new errors, as some
of the system code expects to find the message in a special place for
errors of this type.  This object is made public solely so that condition
handlers can be bound to it.
@end defvr

@deffn {procedure+} warn message irritant @dots{}
This procedure takes arguments just like @code{error}, formats and prints a
message in the usual way, but does not signal an exception.  The output
goes to the output-port of the nearest @code{cmdl} object.  In the future
this may be made customizable in some ways, such as allowing conditional
error signalling based on a flag.
@end deffn

@node Error Handler, Error Messages, Simple Errors, Error System
@section Error Handler

@cindex standard error handler
@cindex error handler, standard
In the absence of more specific handling, errors invoke the
@dfn{standard error handler}.  This handler normally prints an error
message and enters a new @sc{rep} loop.

@deffn {procedure+} standard-error-handler condition
This procedure is used to handle error conditions that are not otherwise
taken care of.  It can be useful when building custom error
handlers.
@end deffn

While the standard error handler is executing, the following procedures
provide useful information.

@deffn {procedure+} error-condition
This procedure returns the condition that was passed to the standard
error handler as its argument.  If the standard error handler is not
executing, this procedure returns @code{#f}.
@end deffn

@deffn {procedure+} error-message
@deffnx {procedure+} error-irritants
@deffnx {procedure+} error-continuation
These procedures extract standard components from @code{(error-condition)}.
@code{error-continuation} returns @code{#f} if @code{error-condition}
does.
@end deffn

@node Error Messages, Condition Types, Error Handler, Error System
@section Error Messages

The error system provides a simple formatting language that allows the
programmer to have some control over the printing of error messages.  The
basic idea is as follows.

@findex display
@findex write
Error messages typically consist of a string describing the error,
followed by some irritant objects.  The string is printed using
@code{display}, and the irritants are printed using @code{write},
typically with a space between each irritant.  To allow simple
formatting, we introduce a @dfn{noise} object, which is printed using
@code{display}.  The irritant list may contain ordinary objects
interspersed with noise objects.  Each noise object is printed using
@code{display}, with no extra whitespace, while each normal object is
printed using @code{write}, prefixed by a single space character.

Here is an example:

@example
@group
(define (error-within-procedure message irritant procedure)
  (error message
         irritant
         (error-irritant/noise #\newline)    
         (error-irritant/noise "within procedure")      
         procedure))
@end group
@end example

This would format as follows:

@example
@group
(error-within-procedure "bad widget" 'widget-32 'invert-widget) @error{}

bad widget widget-32
within procedure invert-widget
@end group
@end example

Note the use of a separate noise object for the newline.  In general, for
characters such as newline or formfeed (i.e.@: non-graphic characters), this
is desirable since it makes it easier for the formatter to notice
formatting characters with special meanings and handle them specially
should it be necessary.

Here are the operations supporting error messages:

@deffn {procedure+} format-error-message message irritants port
@var{Message} must be a string, @var{irritants} a list of irritant
objects, and @var{port} an output port.  Formats @var{message} and
@var{irritants} to @var{port} in the standard way.  Note that, during
the formatting process, the depth and breadth to which lists are printed
are each limited to small numbers, to guarantee that the output from
each irritant is not arbitrarily large.
@end deffn

@deffn {procedure+} error-irritant/noise value
Creates and returns a noise object whose value is @var{value}.
@end deffn

@deffn {procedure+} error-irritant/noise? object
Returns @code{#t} if @var{object} was created by
@code{error-irritant/noise}; otherwise returns @code{#f}.
@end deffn

@deffn {procedure+} error-irritant/noise-value noise
Returns the value of the noise object @var{noise}.  This is the object that
was passed to @code{error-irritant/noise} as an argument when @var{noise}
was created.
@end deffn

@deffn {procedure+} error-irritants/sans-noise
@findex error-irritants
This returns the value of @code{error-irritants} with the noise objects
removed.  It could have been written:

@example
@group
(define (error-irritants/sans-noise)
  (list-transform-negative (error-irritants)
    error-irritant/noise?))
@end group
@end example
@end deffn

@node Condition Types, Condition Instances, Error Messages, Error System
@section Condition Types

@cindex condition type
@cindex type, of condition
Each condition has a @dfn{condition type} object associated with it.
These objects are used as a means of focusing on related classes of
conditions, first by concentrating all of the information about a
specific class of condition in a single place, and second by specifying
inheritance relationships between types.

Condition types are defined by the following operations.  Any argument
called @var{condition-type} is assumed to be a condition type
object.

@deffn {procedure+} make-condition-type generalizations reporter
This procedure creates and returns a new condition type.
@var{Generalizations} must be a list of condition types; the resulting
condition type will be a specialization of each of these types.
@var{Reporter} is a procedure of two arguments, a condition instance and
an output port, which will write a concise description of the condition
on the output port.  As a special option, @var{reporter} may be a
string, in which case a standard error message will be printed using
that string.
@end deffn

@deffn {procedure+} condition-type? object
@cindex type predicate, for condition type
Returns @code{#t} if @var{object} is a condition type; otherwise returns
@code{#f}.
@end deffn

@deffn {procedure+} guarantee-condition-type object
Signals an error if @var{object} is not a condition type.  Returns
@var{object} as its value otherwise.
@end deffn

@deffn {procedure+} condition-type/generalizations condition-type
Returns the generalizations of @var{condition-type}.  This is the reflexive
and transitive closure of the @var{generalizations} argument to
@code{make-condition-type}, i.e.@: all of the members of
@var{generalizations} plus all of their generalizations as well.  This list
always contains @var{condition-type}.
@end deffn

@deffn {procedure+} condition-type/reporter condition-type
Returns the report procedure for @var{condition-type}.
@end deffn

@deffn {procedure+} condition-type/properties condition-type
Each condition type contains a 1D table for associating arbitrary
properties with the condition type.  This operation returns the table
associated with @var{condition-type}.
@end deffn

@deffn {procedure+} condition-type/error? condition-type
@cindex error type (defn)
@cindex type, of error (defn)
This predicate is true only of condition types that are considered to be
errors.  Condition types satisfying this predicate are treated specially
under certain cirumstances, and are sometimes referred to as @dfn{error
types}.

The following two expressions are equivalent (as predicates):

@example
@group
(condition-type/error? x)
(memq condition-type:error (condition-type/generalizations x))
@end group
@end example
@end deffn

@defvr {condition type+} condition-type:error
The value of this variable a condition type with no generalizations that
is used to mark condition types as being errors.
@end defvr

@deffn {procedure+} make-error-type generalizations reporter
@findex make-condition-type
This operation is like @code{make-condition-type}, except that if none of
@var{generalizations} satisfies @code{condition-type/error?}, it adds
@code{condition-type:error} to the set of generalizations.
@end deffn

@deffn {procedure+} error-type? object
@cindex type predicate, for error type
Returns @code{#t} if @var{object} is a condition type that satisfies
@code{condition-type/error?}; otherwise returns @code{#f}.
@end deffn

@node Condition Instances, Condition Signalling, Condition Types, Error System
@section Condition Instances

@cindex condition (defn)
@cindex condition instance (defn)
@cindex instance, of condition (defn)
A @dfn{condition}, in addition to the information associated with its
type, usually contains other information that is not shared with other
conditions of the same type.  For example, the condition type associated
with unbound variable errors does not specify the name of the variable
that was unbound.  The additional information is captured in
@dfn{condition} objects, also called @dfn{condition instances}.

In addition to information that is specific to a given type of condition
(such as the variable name for ``unbound variable'' conditions), every
condition instance also contains a continuation that encapsulates the
state of the computation in which the condition occurred.  This
continuation is used when condition handlers want to restart the
computation in some way, or sometimes for analyzing the computation to
learn more about the context in which the condition occurred.

The following operations define the condition datatype.  Any argument
called @var{condition} is assumed to be a condition object.

@deffn {procedure+} make-condition condition-type irritants continuation
Makes a new condition instance, with a type of @var{condition-type}.
@var{Irritants} is a list of arbitrary objects, and @var{continuation}
must be a continuation, normally the continuation of the computation
which caused the condition.
@end deffn

@deffn {procedure+} condition? object
@cindex type predicate, for condition instance
Returns true iff @var{object} is a condition instance.
@end deffn

@deffn {procedure+} error? object
@cindex type predicate, for error instance
@findex condition-type/error?
Returns @code{#t} if @var{object} is a condition instance that satisfies
@code{condition/error?}; otherwise returns @code{#f}.
@end deffn

@deffn {procedure+} guarantee-condition object
Signals an error if @var{object} is not a condition instance.  Returns
@var{object} otherwise.
@end deffn

@deffn {procedure+} condition/type condition
Returns the condition type associated with @var{condition}.
@end deffn

@deffn {procedure+} condition/irritants condition
Returns the irritants associated with @var{condition}.
@end deffn

@deffn {procedure+} condition/continuation condition
Returns the continuation associated with @var{condition}.
@end deffn

@deffn {procedure+} condition/write-report condition [output-port]
Writes a concise description of @var{condition} to @var{output-port},
which defaults to the current output port.
@end deffn

@deffn {procedure+} condition/report-string condition
Returns a newly allocated string that is a concise description of
@var{condition}.
@end deffn

@deffn {procedure+} condition/properties condition
Each condition instance contains a 1D table for associating arbitrary
properties with the condition.  This procedure returns the table
associated with @var{condition}.
@end deffn

@deffn {procedure+} condition/internal? condition
This predicate is true of certain conditions that normally should not be
handled by user code.  Condition handlers that handle ``all'' conditions
should ignore conditions satisfying this predicate, unless the handler's
writer has a good understanding of internal conditions.
@end deffn

@deffn {procedure+} condition/generalizations condition
@deffnx {procedure+} condition/error? condition
@deffnx {procedure+} condition/reporter condition
These operations access the corresponding components in the type of
@var{condition}.  For example, the following expressions are
equivalent:

@example
(condition/generalizations condition)
(condition-type/generalizations (condition/type condition))
@end example

@cindex error condition (defn)
@cindex condition, error (defn)
Note that condition instances satisfying the predicate
@code{condition/error?} are sometimes referred to as @dfn{error
conditions}, or even @dfn{errors}.
@end deffn

@node Condition Signalling, Condition Handling, Condition Instances, Error System
@section Condition Signalling

@cindex condition signalling (defn)
@cindex signalling, of condition (defn)
@findex make-condition
Once a condition instance has been created using @code{make-condition}, it
can be @dfn{signalled}.  The act of signalling a condition is separated
from the act of creating the condition to allow more flexibility in how
conditions are handled.  For example, a condition instance could be
returned as the value of a procedure, indicating that something unusual has
happened, to allow the caller to clean up some state.  The caller could
then signal the condition once it is ready.

A more important reason for having a separate condition signalling
mechanism is that it allows @emph{resignalling}.  When a signalled
condition has been caught by a particular handler, and the handler decides
that it doesn't want to process that particular condition, it can signal
the condition again.  This is one way to allow other handlers to get a
chance to see the condition.

There is a single procedure responsible for signalling conditions.  All
other signalling mechanisms go through this procedure:

@deffn {procedure+} signal-condition condition [default-handler]
Signals @var{condition}.  @var{Default-handler}, if given, must be a
procedure of one argument.  The signalling procedure attempts to find a
handler for the condition, using the following rules:

@itemize @bullet
@item
The set of condition handlers is searched, until it finds one that will
handle any of the condition types specified by the generalizations of
@var{condition}.  Each handler specifies, at the time it is bound, a set of
condition types it will handle; if the intersection of that set and
@var{condition}'s generalizations is not empty, the handler is
selected.
@cindex condition handler
@cindex handler, of condition

If a handler is found, it is invoked on @var{condition}.  If it returns
@code{#f}, that means the handler has declined to handle the condition
and the search continues.  Otherwise the handler's value is returned as
the value of @code{signal-condition}.

@item
If no condition handler is found, and the argument @var{default-handler} is
supplied, it is invoked on @var{condition}; its value is returned as the
value of @code{signal-condition}.

@item
Otherwise, @code{#f} is returned, indicating that no handler could be
found.
@end itemize
@end deffn

@deffn {procedure+} signal-error condition
@findex standard-error-handler
Signals @var{condition}, which must be a condition instance.  If this
condition is not otherwise handled, the standard error handler is
invoked.  Equivalent to @code{(signal-condition @var{condition}
standard-error-handler)}.
@end deffn

@node Condition Handling, Predefined Errors, Condition Signalling, Error System
@section Condition Handling

@cindex condition handling (defn)
@cindex handling, of condition (defn)
@dfn{Condition handling} refers to the act of defining the behavior of a
signalled condition.  This is controlled by the binding of
@dfn{condition handlers}.

@cindex condition handler (defn)
@cindex handler, of condition (defn)
@findex signal-condition
A @dfn{condition handler} is a procedure of one argument.  When a handler
is invoked by @code{signal-condition}, a condition is supplied to
the handler as its argument.  The handler may return a value: if the value
is @code{#f}, this indicates that the handler has decided not to handle
this particular condition.  In that case, @code{signal-condition} continues
its search for another handler.  Otherwise the value returned by the
handler is returned as the value of @code{signal-condition}.

@cindex resignalling, of condition (defn)
Often, though, the handler will not return a value.  Usually a condition
handler will exit by invoking some continuation.  Sometimes it will
signal a different condition instead, or signal the same condition
again.  This latter action, @dfn{resignalling} the same condition, is
equivalent to returning @code{#f} from the handler.  This is because
when the handler is invoked, the set of condition-handler bindings is
unwound to the point at which the handler was bound.  In other words,
when a condition handler is bound, the set of condition handlers that is
in effect at the time of binding is the set that will be in effect when
the handler is invoked.

@cindex binding, of condition handler (defn)
@cindex condition handler, binding (defn)
A condition handler is @dfn{bound} by specifying that it will handle a
condition whose generalizations intersect a given set of condition types.
Condition handlers are bound using a mechanism very similar to fluid
binding of variables.  A condition handler binding has a dynamic extent
rather than a lexical scope, that is, it is effective for a specified time
segment rather than for a specified code segment.

The order in which the bindings are searched (by @code{signal-condition})
is the opposite from the order in which they are bound.  Thus, more
recently bound handlers appear earlier in the search order.

@deffn {procedure+} bind-condition-handler condition-types handler thunk
@findex condition/internal?
Executes @var{thunk}, handling any condition whose generalizations
intersect @var{condition-types} by passing it to @var{handler}.
@var{Condition-types} must be a list of condition-type objects.  If
@var{condition-types} is the empty list, it means @var{handler} should
handle @emph{all} conditions, regardless of their type; such handlers
should ignore conditions satisfying the predicate
@code{condition/internal?}.
@end deffn

@node Predefined Errors,  , Condition Handling, Error System
@section Predefined Errors

@defvr {condition type+} error-type:wrong-type-argument
Signalled when the argument to a procedure is determined to have an
incorrect type.  For example, this error is signalled by @code{car} if
its argument is not a pair.  This is a specialization of
@code{error-type:illegal-argument}.
@end defvr

@deffn {procedure+} error:illegal-datum object [procedure-name]
Signals @code{error-type:wrong-type-argument}.  @var{Object} is the
argument in question, and @code{procedure-name}, if supplied, is the
name of the procedure that determined the argument's incorrectness.
@end deffn

@defvr {condition type+} error-type:bad-range-argument
Signalled when the argument to a procedure is determined to have the
correct type but is not in the acceptable range.  For example, this
error is signalled by @code{vector-ref} if its second argument is an
exact negative integer.  This is a specialization of
@code{error-type:illegal-argument}.
@end defvr

@deffn {procedure+} error:datum-out-of-range object [procedure-name]
Signals @code{error-type:bad-range-argument}.  @var{Object} is the
argument in question, and @code{procedure-name}, if supplied, is the
name of the procedure that determined the argument's incorrectness.
@end deffn

@defvr {condition type+} error-type:illegal-argument
This type is not signalled -- one of its specializations is signalled
when the argument to a procedure is determined to be incorrect in some
fashion.
@end defvr

@defvr {condition type+} error-type:open-file
Signalled if an error occurs while trying to open a file for input or
output.
@end defvr

@defvr {condition type+} error-type:file
This type is not signalled -- one of its specializations is signalled
when any @sc{i/o} error occurs.  The name of this type is a misnomer; it
can be signalled by any @sc{i/o} operation, whether or not it involves
files.
@end defvr

@node Graphics, Win32 Package Reference, Error System, Top
@chapter Graphics
@cindex graphics

MIT Scheme has a simple two-dimensional line-graphics interface
that is suitable for many graphics applications.  In particular it is
often used for plotting data points from experiments.  The interface is
generic in that it can support different types of graphics devices in a
uniform manner.  At the present time only two types of graphics device
are implemented.

Procedures are available for drawing points, lines, and text; defining
the coordinate system; clipping graphics output; controlling some of the
drawing characteristics; and controlling the output buffer (for devices
that perform buffering).  Additionally, devices may support custom
operations, such as control of colors.

There are some constraints on the arguments to the procedures described
in this chapter.  Any argument named @var{graphics-device} must be a
graphics device object that was returned from a call to
@code{make-graphics-device}.  Any argument that is a coordinate must be
either an exact integer or an inexact real.

@menu
* Opening and Closing of Graphics Devices::  
* Coordinates for Graphics::    
* Drawing Graphics::            
* Characteristics of Graphics Output::  
* Buffering of Graphics Output::  
* Clipping of Graphics Output::  
* Custom Graphics Operations::  
* Images::                      
* Win32 Graphics::              Graphics on Microsoft Windows and Windows NT
* X Graphics::                  
* Starbase Graphics::           
@end menu

@node Opening and Closing of Graphics Devices, Coordinates for Graphics,  , Graphics
@section Opening and Closing of Graphics Devices
@cindex graphics, opening and closing devices

@deffn {procedure+} graphics-type-available? graphics-device-type
This predicate returns @code{#t} if the graphics system named by the
symbol @var{graphics-device-type} is implemented by the Scheme system.
Otherwise it returns @code{#f}, in which case it is an error to attempt
to make a graphics device using @var{graphics-device-type}.
@end deffn

@deffn {procedure+} enumerate-graphics-device-types
This procedure returns a list of symbols which are the names of all the
graphics device types that are supported by the Scheme system.  The
result is useful in deciding what additional arguments to supply to
@code{make-graphics-device}, as each device type typically has a unique
way of specifying the initial size, shape and other attributes.
@end deffn

@deffn {procedure+} make-graphics-device graphics-device-type object @dots{}
This operation creates and returns a graphics device object.
@var{Graphics-device-type} is a symbol naming a graphics device type,
and both the number and the meaning of the remaining arguments is
determined by that type (see the description of each device type for
details); @var{graphics-device-type} must satisfy
@code{graphics-type-available?}.  @var{Graphics-device-type} may also be
@code{#f}, in which case the graphics device type is chosen by the
system from what is available.  This allows completely portable graphics
programs to be written provided no custom graphics operations are used.
When @var{graphics-device-type} is @code{#f} no further arguments may be
given; each graphics device type will use some ``sensible'' defaults.
If more control is required then the program should use one of the two
procedures above to dispatch on the available types.

This procedure opens and initializes the device, which remains valid
until explicitly closed by the procedure @code{graphics-close}.
Depending on the implementation of the graphics device, if this object
is reclaimed by the garbage collector, the graphics device may remain
open or it may be automatically closed.  While a graphics device remains
open the resources associated with it are not released.
@end deffn

@deffn {procedure+} graphics-close graphics-device
Closes @var{graphics-device}, releasing its resources.  Subsequently it
is an error to use @var{graphics-device}.
@end deffn

@node Coordinates for Graphics, Drawing Graphics, Opening and Closing of Graphics Devices, Graphics
@section Coordinates for Graphics
@cindex graphics, coordinate systems

@cindex coordinates, graphics
@cindex device coordinates, graphics (defn)
@cindex graphics, device coordinates (defn)
@cindex virtual coordinates, graphics (defn)
@cindex graphics, virtual coordinates (defn)
Each graphics device has two different coordinate systems associated
with it: @dfn{device coordinates} and @dfn{virtual coordinates}.  Device
coordinates are generally defined by low-level characteristics of the
device itself, and often cannot be changed.  Most device coordinate
systems are defined in terms of pixels, and usually the upper-left-hand
corner is the origin of the coordinate system, with @var{x} coordinates
increasing to the right and @var{y} coordinates increasing downwards.

In contrast, virtual coordinates are more flexible in the units
employed, the position of the origin, and even the direction in which
the coordinates increase.  A virtual coordinate system is defined by
assigning coordinates to the edges of a device.  Because these edge
coordinates are arbitrary real numbers, any Cartesian coordinate system
can be defined.

All graphics procedures that use coordinates are defined on virtual
coordinates.  For example, to draw a line at a particular place on a
device, the virtual coordinates for the endpoints of that line are
given.

When a graphics device is initialized, its virtual coordinate system is
reset so that the left edge corresponds to an x-coordinate of @code{-1},
the right edge to x-coordinate @code{1}, the bottom edge to y-coordinate
@code{-1}, and the top edge to y-coordinate @code{1}.

@deffn {procedure+} graphics-device-coordinate-limits graphics-device
Returns (as multiple values) the device coordinate limits for
@var{graphics-device}.  The values, which are exact non-negative
integers, are: @var{x-left}, @var{y-bottom}, @var{x-right}, and
@var{y-top}.
@end deffn

@deffn {procedure+} graphics-coordinate-limits graphics-device
Returns (as multiple values) the virtual coordinate limits for
@var{graphics-device}.  The values, which are real numbers, are:
@var{x-left}, @var{y-bottom}, @var{x-right}, and @var{y-top}.
@end deffn

@deffn {procedure+} graphics-set-coordinate-limits graphics-device x-left y-bottom x-right y-top
Changes the virtual coordinate limits of @var{graphics-device} to the
given arguments.  @var{X-left}, @var{y-bottom}, @var{x-right}, and
@var{y-top} must be real numbers.  Subsequent calls to
@code{graphics-coordinate-limits} will return the new limits.  This
operation has no effect on the device's displayed contents.

Note: This operation usually resets the clip rectangle, although it is
not guaranteed to do so.  If a clip rectangle is in effect when this
procedure is called, it is necessary to redefine the clip rectangle
afterwards.
@end deffn

@node Drawing Graphics, Characteristics of Graphics Output, Coordinates for Graphics, Graphics
@section Drawing Graphics
@cindex graphics, drawing

The procedures in this section provide the basic drawing capabilities of
Scheme's graphics system.

@deffn {procedure+} graphics-clear graphics-device
Clears the display of @var{graphics-device}.  Unaffected by the current
drawing mode.
@end deffn

@deffn {procedure+} graphics-draw-point graphics-device x y
Draws a single point on @var{graphics-device} at the virtual coordinates
given by @var{x} and @var{y}, using the current drawing mode.
@end deffn

@deffn {procedure+} graphics-erase-point graphics-device x y
Erases a single point on @var{graphics-device} at the virtual
coordinates given by @var{x} and @var{y}.  This procedure is unaffected
by the current drawing mode.

This is equivalent to

@example
(lambda (device x y)
  (graphics-bind-drawing-mode device 0
    (lambda ()
      (graphics-draw-point device x y))))
@end example
@end deffn

@deffn {procedure+} graphics-draw-line graphics-device x-start y-start x-end y-end
@var{X-start}, @var{y-start}, @var{x-end}, and @var{y-end} must be real
numbers.  Draws a line on @var{graphics-device} that connects the points
(@var{x-start}, @var{y-start}) and (@var{x-end}, @var{y-end}).  The line
is drawn using the current drawing mode and line style.
@end deffn

@deffn {procedure+} graphics-draw-text graphics-device x y string
Draws the characters of @var{string} at the point (@var{x}, @var{y}) on
@var{graphics-device}, using the current drawing mode.  The
characteristics of the characters drawn are device-dependent, but all
devices are initialized so that the characters are drawn upright, from
left to right, with the leftmost edge of the leftmost character at
@var{x}, and the baseline of the characters at @var{y}.
@end deffn

@cindex graphics, cursor (defn)
@cindex cursor, graphics (defn)
The following two procedures provide an alternate mechanism for drawing
lines, which is more akin to using a plotter.  They maintain a
@dfn{cursor}, which can be positioned to a particular point and then
dragged to another point, producing a line.  Sequences of connected line
segments can be drawn by dragging the cursor from point to point.

Many graphics operations have an unspecified effect on the cursor.  The
following exceptions are guaranteed to leave the cursor unaffected:

@example
@group
graphics-device-coordinate-limits
graphics-coordinate-limits
graphics-enable-buffering
graphics-disable-buffering
graphics-flush
graphics-bind-drawing-mode
graphics-set-drawing-mode
graphics-bind-line-style
graphics-set-line-style
@end group
@end example

The initial state of the cursor is unspecified.

@deffn {procedure+} graphics-move-cursor graphics-device x y
Moves the cursor for @var{graphics-device} to the point (@var{x},
@var{y}).  The contents of the device's display are unchanged.
@end deffn

@deffn {procedure+} graphics-drag-cursor graphics-device x y
Draws a line from @var{graphics-device}'s cursor to the point (@var{x},
@var{y}), simultaneously moving the cursor to that point.  The line is
drawn using the current drawing mode and line style.
@end deffn

@node Characteristics of Graphics Output, Buffering of Graphics Output, Drawing Graphics, Graphics
@section Characteristics of Graphics Output

@cindex graphics, output characteristics
Two characteristics of graphics output are so useful that they are
supported uniformly by all graphics devices: @dfn{drawing mode} and
@dfn{line style}.  A third characteristic, @dfn{color}, is equally
useful (if not more so), but implementation restrictions prohibit a
uniform interface.

@cindex drawing mode, graphics (defn)
@cindex graphics, drawing mode (defn)
The @dfn{drawing mode}, an exact integer in the range @code{0} to
@code{15} inclusive, determines how the figure being drawn is combined
with the background over which it is drawn to generate the final result.
Initially the drawing mode is set to ``source'', so that the new output
overwrites whatever appears in that place.  Useful alternative drawing
modes can, for example, erase what was already there, or invert it.

Altogether 16 boolean operations are available for combining the source
(what is being drawn) and the destination (what is being drawn over).
The source and destination are combined by the device on a
pixel-by-pixel basis as follows:

@page
@example
@group
Mode    Meaning
----    -------
0       ZERO @r{[erase; use background color]}
1       source AND destination
2       source AND (NOT destination)
3       source
4       (NOT source) AND destination
5       destination
6       source XOR destination
7       source OR destination
8       NOT (source OR destination)
9       NOT (source XOR destination)
10      NOT destination
11      source OR (NOT destination)
12      NOT source
13      (NOT source) OR destination
14      (NOT source) OR (NOT destination)
15      ONE @r{[use foreground color]}
@end group
@end example

@cindex line style, graphics (defn)
@cindex graphics, line style (defn)
The @dfn{line style}, an exact integer in the range @code{0} to @code{7}
inclusive, determines which parts of a line are drawn in the foreground
color, and which in the background color.  The default line style,
``solid'', draws the entire line in the foreground color.
Alternatively, the ``dash'' style alternates between foreground and
background colors to generate a dashed line.  This capability is useful
for plotting several things on the same graph.

Here is a table showing the name and approximate pattern of the
different styles.  A @samp{1} in the pattern represents a foreground
pixel, while a @samp{-} represents a background pixel.  Note that the
precise output for each style will vary from device to device.  The only
style that is guaranteed to be the same for every device is ``solid''.

@example
@group
Style   Name                    Pattern
-----   -------                 -------
0       solid                   1111111111111111
1       dash                    11111111--------
2       dot                     1-1-1-1-1-1-1-1-
3       dash dot                1111111111111-1-
4       dash dot dot            11111111111-1-1-
5       long dash               11111111111-----
6       center dash             111111111111-11-
7       center dash dash        111111111-11-11-
@end group
@end example

@deffn {procedure+} graphics-bind-drawing-mode graphics-device drawing-mode thunk
@deffnx {procedure+} graphics-bind-line-style graphics-device line-style thunk
These procedures bind the drawing mode or line style, respectively, of
@var{graphics-device}, invoke the procedure @var{thunk} with no
arguments, then undo the binding when @var{thunk} returns.  The value of
each procedure is the value returned by @var{thunk}.  Graphics
operations performed during @var{thunk}'s dynamic extent will see the
newly bound mode or style as current.
@end deffn

@deffn {procedure+} graphics-set-drawing-mode graphics-device drawing-mode
@deffnx {procedure+} graphics-set-line-style graphics-device line-style
These procedures change the drawing mode or line style, respectively, of
@var{graphics-device}.  The mode or style will remain in effect until
subsequent changes or bindings.
@end deffn

@node Buffering of Graphics Output, Clipping of Graphics Output, Characteristics of Graphics Output, Graphics
@section Buffering of Graphics Output
@cindex buffering, of graphics output
@cindex graphics, buffering of output

To improve performance of graphics output, most graphics devices provide
some form of buffering.  By default, Scheme's graphics procedures flush
this buffer after every drawing operation.  The procedures in this
section allow the user to control the flushing of the output
buffer.

@deffn {procedure+} graphics-enable-buffering graphics-device
Enables buffering for @var{graphics-device}.  In other words, after this
procedure is called, graphics operations are permitted to buffer their
drawing requests.  This usually means that the drawing is delayed until
the buffer is flushed explicitly by the user, or until it fills up and
is flushed by the system.
@end deffn

@deffn {procedure+} graphics-disable-buffering graphics-device
Disables buffering for @var{graphics-device}.  By default, all graphics
devices are initialized with buffering disabled.  After this procedure
is called, all drawing operations perform their output immediately,
before returning.

Note: @code{graphics-disable-buffering} flushes the output buffer if
necessary.
@end deffn

@deffn {procedure+} graphics-flush graphics-device
Flushes the graphics output buffer for @var{graphics-device}.  This
operation has no effect for devices that do not support buffering, or if
buffering is disabled for the device.
@end deffn

@node Clipping of Graphics Output, Custom Graphics Operations, Buffering of Graphics Output, Graphics
@section Clipping of Graphics Output
@cindex graphics, clipping
@cindex clipping, of graphics

@cindex clip rectangle, graphics (defn)
Scheme provides a rudimentary mechanism for restricting graphics output
to a given rectangular subsection of a graphics device.  By default,
graphics output that is drawn anywhere within the device's virtual
coordinate limits will appear on the device.  When a @dfn{clip
rectangle} is specified, however, output that would have appeared
outside the clip rectangle is not drawn.

Note that changing the virtual coordinate limits for a device will
usually reset the clip rectangle for that device, as will any operation
that affects the size of the device (such as a window resizing
operation).  However, programs should not depend on this.

@deffn {procedure+} graphics-set-clip-rectangle graphics-device x-left y-bottom x-right y-top
Specifies the clip rectangle for @var{graphics-device} in virtual
coordinates.  @var{X-left}, @var{y-bottom}, @var{x-right}, and
@var{y-top} must be real numbers.  Subsequent graphics output is clipped
to the intersection of this rectangle and the device's virtual
coordinate limits.
@end deffn

@deffn {procedure+} graphics-reset-clip-rectangle graphics-device
Eliminates the clip rectangle for @var{graphics-device}.  Subsequent
graphics output is clipped to the virtual coordinate limits of the
device.
@end deffn

@node Custom Graphics Operations, Images, Clipping of Graphics Output, Graphics
@section Custom Graphics Operations
@cindex custom operations, on graphics device
@cindex graphics, custom operations

In addition to the standard operations, a graphics device may support
@dfn{custom operations}.  For example, most devices have custom
operations to control color.  @code{graphics-operation} is used to
invoke custom operations.

@deffn {procedure+} graphics-operation graphics-device name object @dots{}
Invokes the graphics operation on @var{graphics-device} whose name is
the symbol @var{name}, passing it the remaining arguments.  This
procedure can be used to invoke the standard operations, as well as
custom operations that are specific to a particular graphics device
type.  The names of the standard graphics operations are formed by
removing the @code{graphics-} prefix from the corresponding procedure.
For example, the following are equivalent:

@example
(graphics-draw-point device x y)
(graphics-operation device 'draw-point x y)
@end example

For information on the custom operations for a particular device, see
the documentation for its type.
@end deffn

@node Images, Win32 Graphics, Custom Graphics Operations, Graphics
@section Images
@cindex graphics, images
@cindex images, graphics
@cindex graphics, bitmaps
@cindex bitmaps, graphics

Some graphics device types support images, which are rectangular pieces
of picture that may be drawn into a graphics device.  Images are often
called something else in the host graphics system, such as bitmaps or
pixmaps.  The operations supported vary between devices, so look under
the different device types to see what operations are available.  All
devices that support images support the following operations.

@defop {operation+} graphics-device create-image width height
Images are created using the @code{create-image} graphics operation,
specifying the @var{width} and @var{height} of the image in device
coordinates (pixels).

@example
(graphics-operation device 'create-image 200 100)
@end example

@noindent
The initial contents of an image are unspecified.

@code{create-image} is a graphics operation rather than a procedure
because the kind of image returned depends on the kind of graphics
device used and the options specified in its creation.  The image may be
used freely with other graphics devices created with the same
attributes, but the effects of using an image with a graphics device
with different attributes (for example, different colors) is undefined.
Under X, the image is display dependent.
@end defop

@defop {operation+} graphics-device draw-image x y image
The image is copied into the graphics device at the specified position.
@end defop

@defop {operation+} graphics-device draw-subimage x y image im-x im-y w h
Part of the image is copied into the graphics device at the specified
(@var{x}, @var{y}) position.  The part of the image that is copied is the
rectangular region at @var{im-x} and @var{im-y} and of width @var{w} and
height @var{h}.  These four numbers are given in device coordinates
(pixels).
@end defop

@deffn {procedure+} image? object
Returns @code{#t} if @var{object} is an image, otherwise returns
@code{#f}.
@end deffn

@deffn {procedure+} image/destroy image
This procedure destroys @var{image}, returning storage to the system.
Programs should destroy images after they have been used because even
modest images may use large amounts of memory.  Images are reclaimed by
the garbage collector, but they may be implemented using memory outside
of Scheme's heap.  If an image is reclaimed before being destroyed, the
implementation might not deallocate that non-heap memory, which can
cause a subsequent call to @code{create-image} to fail because it is
unable to allocate enough memory.
@end deffn

@c @deffn {procedure+} image/descriptor image
@c The procedure returns the implementation dependent image.  Its use is
@c discouraged as it is non-portable.
@c @end deffn

@deffn {procedure+} image/height image
Returns the height of the image in device coordinates.
@end deffn

@deffn {procedure+} image/width image
Returns the width of the image in device coordinates.
@end deffn

@deffn {procedure+} image/fill-from-byte-vector image bytes
The contents of @var{image} are set in a device-dependent way, using one
byte per pixel from @var{bytes} (a string).  Pixels are filled row by
row from the top of the image to the bottom, with each row being filled
from left to right.  There must be at least @code{(* (image/height
@var{image}) (image/width @var{image}))} bytes in @var{bytes}.
@end deffn

@node Win32 Graphics, X Graphics, Images, Graphics
@section Win32 Graphics
@cindex Win32 graphics

MIT Scheme supports graphics on Microsoft Windows 3.1 and Microsoft
Windows NT 3.1.  In addition to the usual operations, there are
operations to control the size, position and colors of a graphics
window.  Win32 devices support images, which are implemented as device
independent bitmaps (@sc{dib}s).

The Win32 graphics device type is implemented as a top level window.
@code{graphics-enable-buffering} is implemented and gives a 2x to 4x
speedup on many graphics operations.  As a convenience, when buffering
is enabled clicking on the graphics window's title bar effects a
@code{graphics-flush} operation.  The user has the benefit of the
increased performance and the ability to view the progress in drawing at
the click of a mouse button.


@menu
* Win32 Graphics Type::         
* Custom Operations for Win32 Graphics::  Custom Operations for Win32 Graphics Devices
@end menu

@node Win32 Graphics Type, Custom Operations for Win32 Graphics,  , Win32 Graphics
@subsection Win32 Graphics Type

Win32 graphics devices are created by specifying the symbol @code{win32}
as the @var{graphics-device-type} argument to
@code{make-graphics-device}.  The Win32 graphics device type is
implemented as a top-level window and supports color drawing in addition
to the standard Scheme graphics operations.

Graphics devices are opened as follows:

@example
(make-graphics-device 'win32 #!optional @var{width} @var{height} @var{palette})
@end example

@noindent
where @var{width} and @var{height} specify the size, in pixels, of the
drawing area in the graphics window (i.e.@: excluding the frame).
@var{Palette} determines the colors available for drawing in the window.

When a color is specified for drawing, the nearest color available in
the palette is used.  Permitted values for @var{palette} are

@table @asis
@item @code{'grayscale}
The window allocates colors from a grayscale palette
of approximately 236 shades of gray.

@item @code{'grayscale-128}
The window allocates colors from a grayscale palette of 128 shades of
gray.

@item @code{'standard}
The standard palette has good selection of colors and grays.

@item @code{#f} or @code{'system}
The colors available are those in the system palette.  There are usually
16 to 20 colors in the system palette and these are usually sufficent
for simple applications like line drawings and x-vs-y graphs of
mathematical functions.  Drawing with the system palette can be more
efficient.

@end table
@noindent
If @var{palette} is not specified then the @code{standard} palette is
used.



@node Custom Operations for Win32 Graphics,  , Win32 Graphics Type, Win32 Graphics
@subsection Custom Operations for Win32 Graphics

Custom operations are invoked using the procedure
@code{graphics-operation}.  For example,

@example
(graphics-operation device 'set-foreground-color "blue")
@end example

@defop {operation+} win32-graphics-device set-background-color color-name
@defopx {operation+} win32-graphics-device set-foreground-color color-name
@findex set-background-color
@findex set-foreground-color
@cindex color
These operations change the colors associated with a window.
@var{Color-name} must be of one of the valid color specification forms
listed below.  @code{set-background-color} and
@code{set-foreground-color} change the colors to be used when drawing,
but have no effect on anything drawn prior to their invocation.  Because
changing the background color affects the entire window, we recommend
calling @code{graphics-clear} on the window's device afterwards.

The foreground color affects the drawing of text, points, lines,
ellipses and filled polygons.

Colors are specified in one of three ways:
@table @asis
@item An integer
This is the Win32 internal RGB value.

@item By name
A limited number of names are understood by the system.
Names are strings, e.g.@: @code{"red"}, @code{"blue"}, @code{"black"}.
More names can be registered with the @code{define-color} operation.


@item RGB (Red-Green-Blue) triples
A triple is either a vector or list of three integers in the range
0--255 inclusive which specify the intensity of the red, green and blue
components of the color.  Thus @code{#(0 0 0)} is black, @code{(0 0
128)} is dark blue and @code{#(255 255 255)} is white.
@end table

@noindent
If the color is not available in the graphics device then the nearest
available color is used instead.
@end defop


@defop {operation+} win32-graphics-device define-color name spec
Define the string @var{name} to be the color specified by @var{spec}.
@var{Spec} may be any acceptable color specification.  Note that the
color names defined this way are available to any Win32 graphics device,
and the names do @emph{not} have to be defined for each device.
@end defop

@defop {operation+} win32-graphics-device find-color name
Looks up a color previously defined by @code{define-color}.  This returns
the color in its most efficient form for operations
@code{set-foreground-color} or @code{set-background-color}.
@end defop


@defop {operation+} win32-graphics-device draw-ellipse left top right bottom
@cindex ellipse, graphics
@cindex circle, graphics
@cindex graphics, ellipse
@cindex graphics, circle
Draw an ellipse.  @var{Left}, @var{top}, @var{right} and @var{bottom}
indicate the coordinates of the bounding rectangle of the ellipse.
Circles are merely ellipses with equal width and height.  Note that the
bounding rectangle has horizontal and vertical sides.  Ellipses with
rotated axes cannot be drawn.  The rectangle applies to the center of the
line used to draw the ellipse; if the line width has been set to greater
than 1 then the ellipse will spill outside the bounding rectange by half
of the line width.
@end defop


@defop {operation+} win32-graphics-device fill-polygon points
@findex fill-polygon
Draws a filled polygon using the current foreground color.
@var{Points} is a vector of real numbers.
The numbers are in the order x1 y1 x2 y2 ... xn yn.
For example,
@example
(graphics-operation device 'fill-polygon #(0 0 0 1 1 0))
@end example
@noindent
draws a solid triangular region between the points (0, 0), (0, 1) and
(1, 0).
@end defop


@defop {operation+} win32-graphics-device load-bitmap pathname
@cindex bitmaps
The graphics device contents and size are initialized from the windows
bitmap file specified by @var{pathname}.  If no file type is supplied
then a @code{".BMP"} extension is added.  If a clip rectangle is in
effect when this procedure is called, it is necessary to redefine the
clip rectangle afterwards.
@end defop

@defop {operation+} win32-graphics-device save-bitmap pathname
@cindex printing graphics output
The graphics device contents are saved as a bitmap to the file specified
by @var{pathname}.  If no file type is supplied then a @code{".BMP"}
extension is added.  The saved bitmap may be incorporated into documents
or printed.
@end defop

@defop {operation+} win32-graphics-device move-window x y
The graphics device window is moved to the screen position specified by
@var{x} and @var{y}.
@end defop

@defop {operation+} win32-graphics-device resize-window width height
The graphics device window is resized to the specified @var{width} and
@var{height} in device coordinates (pixels).  If a clip rectangle is in effect
when this procedure is called, it is necessary to redefine the clip
rectangle afterwards.
@end defop

@defop {operation+} win32-graphics-device set-line-width width
This operation sets the line width for future drawing of lines, points
and ellipses.  It does not affect existing lines and has no effect on
filled polygons.  The line width is specified in device units.  The
default and initial value of this parameter is 1 pixel.
@end defop

@defop {operation+} win32-graphics-device set-window-name name
This sets the window title to the string @var{name}.  The window is
given the name @code{"Scheme Graphics"} at creation.
@end defop

@defop {operation+} win32-graphics-device set-font handle
Sets the font for drawing text.  Currently not well supported.  If you
can get a Win32 font handle it can be used here.
@end defop

@defop {operation+} win32-graphics-device copy-area source-x-left source-y-top width height destination-x-left destination-y-top
This operation copies the contents of the rectangle specified by
@var{source-x-left}, @var{source-y-top}, @var{width}, and @var{height}
to the rectangle of the same dimensions at @var{destination-x-left} and
@var{destination-y-top}.
@end defop

@node X Graphics, Starbase Graphics, Win32 Graphics, Graphics
@section X Graphics
@cindex X graphics

@cindex X window system
MIT Scheme supports graphics in the X window system (version 11).
Arbitrary numbers of displays may be opened, and arbitrary numbers of
graphics windows may be created for each display.  A variety of
operations is available to manipulate various aspects of the windows, to
control their size, position, colors, and mapping.  The X graphics
device type supports images, which are implemented as Xlib @code{XImage}
objects.  X display, window, and image objects are automatically closed
if they are reclaimed by the garbage collector.

@menu
* X Graphics Type::             
* Utilities for X Graphics::    
* Custom Operations on X Graphics Devices::  
@end menu

@node X Graphics Type, Utilities for X Graphics,  , X Graphics
@subsection X Graphics Type


A graphics device for X windows is created by passing the symbol
@code{x} as the graphics device type name to
@code{make-graphics-device}:

@example
(make-graphics-device 'x #!optional @var{display} @var{geometry} @var{suppress-map?})
@end example

@noindent
where @var{display} is either a display object, @code{#f}, or a string;
@var{geometry} is either @code{#f} or a string; and @var{suppress-map?}
is a boolean or a vector (see below).  A new window is created on the
appropriate display, and a graphics device representing that window is
returned.

@findex x-open-display
@var{Display} specifies which X display the window is to be opened on;
if it is @code{#f} or a string, it is passed as an argument to
@code{x-open-display}, and the value returned by that procedure is used
in place of the original argument.  @var{Geometry} is an X geometry
string, or @code{#f} which means to use the default geometry (which is
specified as a resource).

@var{Suppress-map?}, if given, may take two forms.  First, it may be a
boolean: if @code{#f} (the default), the window is automatically mapped
after it is created; otherwise, @code{#t} means to suppress this
automatic mapping.  The second form is a vector of three elements.  The
first element is a boolean with the same meaning as the boolean form of
@var{suppress-map?}.  The second element is a string, which specifies an
alternative resource name to be used for looking up the window's
resources.  The third element is also a string, which specifies a class
name for looking up the window's resources.  The default value for
@var{suppress-map?} is @code{#f}.

The default resource and class names are @code{"schemeGraphics"} and
@code{"SchemeGraphics"} respectively.

@cindex resources, X graphics
@cindex X resources, graphics
The window is initialized using the resource and class names specified
by @var{suppress-map?}, and is sensitive to the following resource
properties:

@example
@group
Property        Class           Default
--------        -----           -------
geometry        Geometry        512x384+0+0
font            Font            fixed
borderWidth     BorderWidth     2
internalBorder  BorderWidth     @r{[border width]}
background      Background      white
foreground      Foreground      black
borderColor     BorderColor     @r{[foreground color]}
cursorColor     Foreground      @r{[foreground color]}
pointerColor    Foreground      @r{[foreground color]}
@end group
@end example

The window is created with a @code{backing_store} attribute of
@code{Always}.  The window's name and icon name are initialized to
@code{"scheme-graphics"}.


@node Utilities for X Graphics, Custom Operations on X Graphics Devices, X Graphics Type, X Graphics
@subsection Utilities for X Graphics

@deffn {procedure+} x-open-display display-name
@cindex display, X graphics
@cindex X display, graphics
Opens a connection to the display whose name is @var{display-name},
returning a display object.  If unable to open a connection, @code{#f}
is returned.  @var{Display-name} is normally a string, which is an X
display name in the usual form; however, @code{#f} is also allowed,
meaning to use the value of the unix environment variable
@code{DISPLAY}.
@end deffn

@deffn {procedure+} x-close-display display
Closes @var{display}; after calling this procedure, it is an error to
use @var{display} for any purpose.  Any windows that were previously
opened on @var{display} are destroyed and their resources returned to
the operating system.
@end deffn

@deffn {procedure+} x-close-all-displays
Closes all open connections to X displays.  Equivalent to calling
@code{x-close-display} on all open displays.
@end deffn

@deffn {procedure+} x-geometry-string x y width height
@cindex geometry string, X graphics
@cindex X geometry string, graphics
This procedure creates and returns a standard X geometry string from the
given arguments.  @var{X} and @var{y} must be either exact integers or
@code{#f}, while @var{width} and @var{height} must be either exact
non-negative integers or @code{#f}.  Usually either @var{x} and @var{y}
are both specified or both @code{#f}; similarly for @var{width} and
@var{height}.  If only one of the elements of such a pair is specified,
it is ignored.

Examples:

@example
(x-geometry-string #f #f 100 200) @result{} "100x200"
(x-geometry-string 2 -3 100 200) @result{} "100x200+2-3"
(x-geometry-string 2 -3 #f #f) @result{} "+2-3"
@end example

Note that the @var{x} and @var{y} arguments cannot distinguish between
@code{+0} and @code{-0}, even though these have different meanings in X.
If either of those arguments is @code{0}, it means @code{+0} in X
terminology.  If you need to distinguish these two cases you must create
your own geometry string using Scheme's string and number primitives.
@end deffn

@node Custom Operations on X Graphics Devices,  , Utilities for X Graphics, X Graphics
@subsection Custom Operations on X Graphics Devices

Custom operations are invoked using the procedure
@code{graphics-operation}.  For example,

@example
(graphics-operation device 'set-foreground-color "blue")
@end example

@defop {operation+} x-graphics-device set-background-color color-name
@defopx {operation+} x-graphics-device set-foreground-color color-name
@defopx {operation+} x-graphics-device set-border-color color-name
@defopx {operation+} x-graphics-device set-mouse-color color-name
@findex graphics-clear
These operations change the colors associated with a window.
@var{Color-name} must be a string, which is the X server's name for the
desired color.  @code{set-border-color} and @code{set-mouse-color}
immediately change the border and mouse-cursor colors.
@code{set-background-color} and @code{set-foreground-color} change the
colors to be used when drawing, but have no effect on anything drawn
prior to their invocation.  Because changing the background color
affects the entire window, we recommend calling @code{graphics-clear} on
the window's device afterwards.  Color names include both mnemonic
names, like @code{"red"}, and intensity names specified in the
@code{"#@var{rrggbb}"} notation.
@end defop

@defop {operation+} x-graphics-device set-border-width width
@defopx {operation+} x-graphics-device set-internal-border-width width
@findex graphics-clear
These operations change the external and internal border widths of a
window.  @var{Width} must be an exact non-negative integer, specified in
pixels.  The change takes place immediately.  Note that changing the
internal border width can cause displayed graphics to be garbled; we
recommend calling @code{graphics-clear} on the window's device after
doing so.
@end defop

@defop {operation+} x-graphics-device set-font font-name
Changes the font used when drawing text in a window.  @var{Font-name}
must be a string that is a font name known to the X server.  This
operation does not affect text drawn prior to its invocation.
@end defop

@defop {operation+} x-graphics-device set-mouse-shape shape-number
Changes the shape of the mouse cursor.  @var{Shape-number} is an exact
non-negative integer that is used as an index into the mouse-shape font;
when multiplied by 2 this number corresponds to an index in the file
@file{/usr/include/X11/cursorfont.h}.
@end defop

@defop {operation+} x-graphics-device map-window
@defopx {operation+} x-graphics-device withdraw-window
These operations control the mapping of windows.  They correspond
directly to the Xlib procedures @code{XMapWindow} and
@code{XWithdrawWindow}.
@end defop

@defop {operation+} x-graphics-device resize-window width height
Changes the size of a window.  @var{Width} and @var{height} must be
exact non-negative integers.  The operation corresponds directly to the
Xlib procedure @code{XResizeWindow}.

This operation resets the virtual coordinate system and the clip
rectangle.
@end defop

@defop {operation+} x-graphics-device move-window x y
Changes the position of a window on the display.  @var{X} and @var{y}
must be exact integers.  The operation corresponds directly to the Xlib
procedure @code{XMoveWindow}.  Note that the coordinates @var{x} and
@var{y} do not take the external border into account, and therefore will
not position the window as you might like.  The only reliable way to
position a window is to ask a window manager to do it for you.
@end defop

@defop {operation+} x-graphics-device get-default resource property
This operation corresponds directly to the Xlib procedure
@code{XGetDefault}.  @var{Resource} and @var{property} must be strings.
The operation returns the character string corresponding to the
association of @var{resource} and @var{property}; if no such association
exists, @code{#f} is returned.
@end defop

@defop {operation+} x-graphics-device copy-area source-x-left source-y-top width height destination-x-left destination-y-top
This operation copies the contents of the rectangle specified by
@var{source-x-left}, @var{source-y-top}, @var{width}, and @var{height} to
the rectangle of the same dimensions at @var{destination-x-left} and
@var{destination-y-top}.
@end defop

@defop {operation+} x-graphics-device font-structure font-name
Returns a Scheme equivalent of the X font structure for the font named
@var{font-name}.  If the string @var{font-name} does not name a font
known to the X server, or names a 16-bit font, @code{#f} is returned.
@end defop

@deffn {procedure+} x-font-structure/name font-structure
@deffnx {procedure+} x-font-structure/direction font-structure
@deffnx {procedure+} x-font-structure/all-chars-exist font-structure
@deffnx {procedure+} x-font-structure/default-char font-structure
@deffnx {procedure+} x-font-structure/min-bounds font-structure
@deffnx {procedure+} x-font-structure/max-bounds font-structure
@deffnx {procedure+} x-font-structure/start-index font-structure
@deffnx {procedure+} x-font-structure/character-bounds font-structure
@deffnx {procedure+} x-font-structure/max-ascent font-structure
@deffnx {procedure+} x-font-structure/max-descent font-structure
These procedures extract the components of the font description
structure returned by the X graphics operation @code{font-structure}.  A
more complete description of these components appears in documentation
of the @code{XLoadQueryFont} Xlib call.  @code{start-index} is the index
of the first character available in the font.  The @code{min-bounds} and
@code{max-bounds} components are structures of type
@code{x-character-bounds}, and the @code{character-bounds} component is
a vector of the same type.
@end deffn

@deffn {procedure+} x-character-bounds/lbearing character-bounds
@deffnx {procedure+} x-character-bounds/rbearing character-bounds
@deffnx {procedure+} x-character-bounds/width character-bounds
@deffnx {procedure+} x-character-bounds/ascent character-bounds
@deffnx {procedure+} x-character-bounds/descent character-bounds
These procedures extract components of objects of type
@code{x-character-bounds}.  A more complete description of them appears
in documentation of the @code{XLoadQueryFont} Xlib call.
@end deffn

@node Starbase Graphics,  , X Graphics, Graphics
@section Starbase Graphics
@cindex starbase graphics

On Hewlett-Packard computers under the HP-UX operating system, Scheme
supports graphics through the Starbase graphics library.  Note that the
default distribution of Scheme for HP computers does not include support
for Starbase --- you must rebuild the microcode to get this support.

@defvr {variable+} starbase-graphics-device-type
This is the device type for Starbase graphics devices.  A Starbase
device is opened as follows:

@example
(make-graphics-device 'starbase @var{device-name} @var{driver-name})
@end example

where @var{device-name} and @var{driver-name} are strings that are used
as the device and driver arguments to the Starbase @code{gopen} call.
The device is opened with kind @code{OUTDEV} and mode @code{0}.  The
device is initialized to have a mapping mode of @code{DISTORT}, and a
line color index of @code{1}.
@end defvr

@defop {operation+} starbase-graphics-device write-image-file filename invert?
This operation writes an image of the Starbase device's display in the
file specified by @var{filename}.  The image is formatted to print on an
HP Laserjet printer.  Normally pixels with a color index of 0 are not
drawn by the printer, and all other pixels are; this results in the
background being white and the foreground being black in the printed
image.  If @var{invert?} is not @code{#f}, this is reversed: the
background is printed as black and the foreground is not printed.
@end defop

@defop {operation+} starbase-graphics-device color-map-size
Returns, as an exact non-negative integer, the number of entries in the
color map for the device.
@end defop

@defop {operation+} starbase-graphics-device define-color color-index red green blue
Defines the color associated with the color-map index @var{color-index}.
@var{Color-index} must be an exact non-negative integer strictly less
than the number of entries in the color map.  @var{Red}, @var{green},
and @var{blue} must be real numbers in the range 0 to 1 inclusive, which
define the color to be put in the map.
@end defop

@defop {operation+} starbase-graphics-device set-line-color color-index
Changes the foreground color used in graphics operations for this
device.  @var{Color-index} must be an exact non-negative integer
strictly less than the number of entries in the color map.  Graphics
drawn after this operation is invoked will appear in this new color.
@end defop

The text drawn by a Starbase device is controlled by the following
characteristics:

@table @asis
@item Aspect
The @dfn{aspect} of a character is its height-to-width ratio, a real
number.  By default, this has the value @code{1}.
@cindex aspect, of graphics character (defn)

@item Height
The @dfn{height} of a character in virtual device coordinates, a real
number.  This is measured along the ``up vector'', which is defined by
the slant of the character.  By default, the height is @code{.1}.
@cindex height, of graphics character (defn)

@item Rotation
The @dfn{rotation} of a character defines the direction in which the
characters are drawn.  It is specified as a real number in degrees, but
only 4 values have any meaning: @code{0}, @code{90}, @code{180}, and
@code{270}.  @code{0} draws left-to-right with upright characters;
@code{90} draws top-to-bottom with characters on their right side;
@code{180} draws right-to-left with upside-down characters; @code{270}
draws bottom-to-top with characters on their left side.  The default
rotation is @code{0}.
@cindex rotation, of graphics character (defn)

@item Slant
The @dfn{slant} of a character defines the ``up vector''; it is a real
number which is the tangent of the angle between the character's
``vertical'' (defined by the rotation), and the ``up vector'', measured
clockwise.  The default slant is @code{0}.
@cindex slant, of graphics character (defn)
@end table

@defop {operation+} starbase-graphics-device text-aspect
@defopx {operation+} starbase-graphics-device text-height
@defopx {operation+} starbase-graphics-device text-rotation
@defopx {operation+} starbase-graphics-device text-slant
These operations return the current values of the text
characteristics.
@end defop

@defop {operation+} starbase-graphics-device set-text-aspect aspect
@defopx {operation+} starbase-graphics-device set-text-height height
@defopx {operation+} starbase-graphics-device set-text-rotation rotation
@defopx {operation+} starbase-graphics-device set-text-slant slant
These operations alter the current values of the text characteristics.
They have no effect on text drawn prior to their invocation.
@end defop

@c WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
@node Win32 Package Reference, Index, Graphics, Top
@chapter Win32 Package Reference

@ifinfo
The Win32 implementation is still in a state of development.  It is
expected that changes will be necessary when MIT Scheme is ported to
Windows NT on the DEC Alpha architecture.  In particular, the
current system is not arranged in a way that adequately distinguishes 
between issues that are a consequence of the NT operating system and
those which are a consequence of the Intel x86 architecture.
@end ifinfo

@menu
* Win32 Package Overview::      
* Foreign function interface::  
* Device Independent Bitmap Utilities::  
@end menu


@node Win32 Package Overview, Foreign function interface,  , Win32 Package Reference
@section Overview


The Win32 implementation is still in a state of development.  It is
expected that changes will be necessary when MIT Scheme is ported to
Windows NT on the DEC Alpha architecture.  In particular, the
current system is not arranged in a way that adequately distinguishes
between issues that are a consequence of the NT operating system and
those which are a consequence of the Intel x86 architecture.
@cindex limitations

Thus this documentation is not definitive, it merely outlines how the
current system works.  Parts of the system will change and any project
implemented using the win32 system must plan for a re-implementation
stage.


The Win32 implementation has several components:

@itemize @bullet

@item
Special microcode primitives.

@item
A foreign function interface (FFI) for calling procedures in dynamically
linked libraries (DLLs).

@item
An interface for Edwin.

@item
The Win32 package provides support for using the features of the
Windows 3.1 and Windows NT 3.1 environments.

@item
Device Independent Bitmap utilities.  These are used by the win32 Scheme
Graphics implementation.  (The Scheme Graphics implementation is
described in the Reference Manual).

@end itemize

Note that all the names in the Win32 support are part of the
@code{win32} package.  The names are bound in the @code{(win32)}
environment, and do not appear as bindings in the user or root
environments.
An effect of this is that it is far easier to develop Win32 software in
the @code{(win32)} package environment or a child environment.

@node Foreign function interface, Device Independent Bitmap Utilities, Win32 Package Overview, Win32 Package Reference
@section Foreign Function Interface

The Win32 foreign function interface (FFI) is a primitive and fairly
simple system for calling procedures written in C in a
dynamically linked library (DLL).  Both user's procedures from a custom
DLL and system procedures (e.g.@: MessageBox) are called using the same
mechanism.

@cindex limitations
@strong{Warning:} The FFI as it stands has several flaws which make it
difficult to use reliably.  It is expected that both the interface to
and the mechanisms used by the FFI will be changed in the future.  We
provide it, and this documentation, only to give people an early start
in accessing some of the features of Win32 from Scheme.  Should you use
it in an experiment we welcome any feedback.

The FFI is designed for calling C procedures that use C data types
rather than Scheme data objects.  Thus it is not possible to write and
call a C procedure that returns, for example, a Scheme list.  The object
returned will always be an integer (which may represent the address of a
C data structure).

@cindex warning
@strong{Warning:} It is extremely dangerous to try to pass Scheme
callback procedures to C procedures.  It is only possible by passing
integer `handles' rather than the actual procedures, and even so, if a
garbage collection occurs during the execution of the callback procedure
objects in Scheme's heap will have moved.  Thus in a foreign procedure
that has a callback and a string, after calling the callback the string
value may no longer be valid.  Playing this game requires a profound
knowledge of the implementation.


The interface to the FFI has two main components: a language for
declaring the types of values passed to and returned from the foreign
procedures and a form for declaring foreign procedures.

@menu
* Windows Types::               
* Windows Foreign Procedures::  
* Win32 API names and procedures::  
@end menu

@node  Windows Types, Windows Foreign Procedures,  , Foreign function interface
@subsection Windows Types

@cindex Windows types
@cindex foreign type declarations
@cindex types, Windows
@cindex defining foreign types
Foreign types are designed to represent a correspondence between a
Scheme data type that is used to represent an object within the Scheme
world and a C data type that represents the data object in the C world.
Thus we cannot manipulate true C objects in Scheme, nor can we
manipulate Scheme objects in C.

Each foreign type has four aspects that together ensure that the
correspondence between the Scheme and C objects is maintained.  These
aspects are all encoded as procedures that either check for validity or
convert between representations.  Thus a foreign type is not a
declarative type so much as a procedural description of how to pass the
type.  The underlying foreign procedure call mechanism can pass integers
and vector-like Scheme objects, and returns integer values.  All other
objects must be translated into integers or some other basic type, and
must be recovered from integers.

The aspects are:

@table @var

@item check
A predicate that returns @code{#t} if the argument is of an acceptable
Scheme type, otherwise returns @code{#f}.
The @var{check} procedure is used for type-checking.

@item convert
A procedure of one argument which returns a Scheme object of one of the
basic types.
It is used to convert an object into a `simpler' object that will
eventually be converted into a C object.
The legal simpler objects are integers and strings.

@item return-convert
A procedure of one argument that, given an integer, returns a Scheme
object of a type satisfying @var{check}.
Its purpose is to convert the result returned by the foreign procedure
into a Scheme value.

@item revert
Some C procedures modify one or more of their arguments.  These
arguments are passed by reference, i.e.@: as a pointer to their address.
Since a Scheme object might have a different memory layout and storage
conventions, it must be passed by copy-in and copy-out rather than by
reference.
@var{Revert} is a procedure of two parameters, the original object
passed and the result of @var{convert} on that object.
@var{Revert} may then inspect the converted object and copy back the
changes to the original.

@end table

@deffn {special form+} define-windows-type name check convert return revert
@deffnx {special form+} define-similar-windows-type name model [check [convert [return [revert]]]]
@cindex defining foreign types
Both forms define a windows type.
The first form defines a type in terms of its aspects as described
above.
The second defines the type as being like another type, except for
certain aspects, which are redefined.
@var{Name} is the name of the type.
@var{Model} is the name of a type.
@var{Check}, @var{convert}, @var{return} and @var{revert} are
procedures or the value @code{#f}.
A @code{#f} means use the default value, which in the second form means
use the definition provided for @var{model}.
The defaults are

@table @var
@item check
@code{(lambda (x) #t)}, i.e.@: unchecked.
@item convert
@code{(lambda (x) x)}, i.e.@: no translation performed.
@item return
@code{(lambda (x) x)}, i.e.@: no translation performed.
@item revert
@code{(lambda (x y) unspecific)}, i.e.@: no update performed
@end table

The @code{unchecked} windows type (see below) is defined as:

@example
(define-windows-type unchecked #f #f #f #f)
@end example

Windows types are @emph{not} first class values, so they cannot be
stored in variables or defined using @code{define}:

@example
(define my-type unchecked)                       @error{}  Unbound variable
(define-similar-windows-type my-type unchecked)  @r{;; the correct way}
@end example

Scheme characters must be converted to integers.  This is accomplished
as follows:

@example
(define-windows-type char
   char?          @r{; check}
   char->integer  @r{; convert}
   integer->char  @r{; convert return value}
   #f             @r{; cannot be passed by reference}
)
@end example
@end deffn

@deffn {windows type} unchecked
The type which is not checked and undergoes only the basic conversion
from a Scheme integer to a C integer or from a Scheme string to a C
pointer to the first byte of the string.
Returned @code{unchecked} values are returned as integers.
@end deffn

@deffn {windows type} bool
Scheme booleans are analogous to C integers @code{0} and @code{1}.
Windows type @code{bool} have been defined as:

@example
(define-windows-type bool
   boolean?
   (lambda (x) (if x 1 0))
   (lambda (x) (if (eq? x 0) #f #t))
   #f)
@end example
@end deffn

@deffn {windows type} char
Scheme characters are converted into C objects of type @code{char},
which are indistinguishable from small integers.
@end deffn

@deffn {windows type} int
@deffnx {windows type} uint
@deffnx {windows type} long
@deffnx {windows type} ulong
@deffnx {windows type} short
@deffnx {windows type} ushort
@deffnx {windows type} word
@deffnx {windows type} byte
Various integer types that are passed without conversion.
@end deffn

@deffn {windows type} string
A string that is passed as a C pointer of type @code{char*} to the first
character in the string.
@end deffn

@deffn {windows type} char*
A string or @code{#f}.  The string is passed as a pointer to characters.
The string is correctly null-terminated.  @code{#f} is passed as the null
pointer.  This is an example where there is a more complex mapping
between C objects and Scheme objects.  C's @code{char*} type is
represented as one of two Scheme types depending on its value.  This
allows us us to distinguish between the C string (pointer) that points
to the empty sequence of characters and the null pointer (which doesnt
point anywhere).
@end deffn

@deffn {windows type} handle
@deffnx {windows type} hbitmap
@deffnx {windows type} hbrush
@deffnx {windows type} hcursor
@deffnx {windows type} hdc
@deffnx {windows type} hicon
@deffnx {windows type} hinstance
@deffnx {windows type} hmenu
@deffnx {windows type} hpalette
@deffnx {windows type} hpen
@deffnx {windows type} hrgn
@deffnx {windows type} hwnd
Various kinds of Win32 handle.  These names correspond to the same, but
all uppercase, names in the Windows C language header files.  Win32 API
calls are the source of values of this type and the values are
meaningless except as arguments to other Win32 API calls.  Currently
these values are represented as integers but we expect that Win32
handles will in future be represented by allocated Scheme objects
(e.g.@: records) that will allow predicates (e.g.@: @code{hmenu?}) and
sensible interlocking with the garbage collector to free the programmer
of the current tedious allocation and deallocation of handles.
@end deffn

@deffn {windows type} resource-id
A Windows resource identifier is either a small integer or a string.
In C, this distinction is possible because pointers look like
larger integers, so a machine word representing a small integer can be
distinguished from a machine word that is a pointer to the text of the
name of the resource.
@end deffn


@node Windows Foreign Procedures, Win32 API names and procedures, Windows Types, Foreign function interface
@subsection Windows Foreign Procedures

Foreign procedures are declared as callable entry-points in a module,
usually a dynamically linked library (DLL).


@deffn {procedure+} find-module name
@cindex loading DLLs
@cindex DLL, loading
Returns a module suitable for use in creating procedures with
@code{windows-procedure}.  @var{Name} is a string which is the name of a
DLL file.  Internally, @code{find-module} uses the @code{LoadLibrary}
Win32 API, so @var{name} should conform to the specifications for this
call.  @var{Name} should be either a full path name of a DLL, or the
name of a DLL that resides in the same directory as the Scheme binary
@file{SCHEME.EXE} or in the system directory.

The module returned is a description for the DLL, and the DLL need not
necessarily be linked at or immediately after this call.  DLL modules
are linked on need and unlinked before Scheme exits and when there
are no remaining references to entry points after a garbage-collection.
This behaviour ensures that the Scheme system can run when a DLL is
absent, provided the DLL is not actually used (i.e.@: no attempt is made
to call a procedure in the DLL).
@end deffn


@defvr {variable+} gdi32.dll
@cindex DLL, GDI32.DLL
This variable is bound to the module describing the @file{GDI32.DLL}
library, which contains the Win32 API graphics calls, e.g.@:
@code{LineTo}.
@end defvr

@defvr {variable+} kernel32.dll
@cindex DLL, KERNEL32.DLL
This variable is bound to the module describing the @file{KERNEL32.DLL}
library.
@end defvr

@defvr {variable+} user32.dll
@cindex DLL, USER32.DLL
This variable is bound to the module describing the @file{USER32.DLL}
library.  This module contains many useful Win32 API procedures, like
@code{MessageBox} and @code{SetWindowText}.
@end defvr


@deffn {special form+} windows-procedure (name (parameter type) ...) return-type module entry-name [options]
@cindex defining foreign procedures
This form creates a procedure, and could be thought of as
``foreign-named-lambda''.  The form creates a Scheme procedure that
calls the C procedure identified by the exported entry point
@var{entry-name} in the module identified by the value of @var{module}.
Both @var{entry-name} and @var{module} are evaluated at procedure
creation time, so either may be expression.  @var{Entry-name} must
evaluate to a string and @var{module} must evaluate to a module as
returned by @code{find-module}.
These are the only parts of the form that are evaluated at procedure
creation time.

@var{Name} is the name of the procedure and is for documentation
purposes only.  This form @emph{does not} define a procedure called
@var{name}.  It is more like @code{lambda}.  The name might be used for
debugging and pretty-printing.

A windows procedure has a fixed number of parameters (i.e.@: no `rest'
parameters or `varargs'), each of which is named and associated with a
windows type @var{type}.  Both the name @var{parameter} and the windows
type @var{type} must be symbols and are not evaluated.  The procedure
returns a value of the windows type @var{return-type}.

The following example creates a procedure that takes a window handle
(@code{hwnd}) and a string and returns a boolean (@code{bool}) result.
The procedure does this by calling the @code{SetWindowText} entry in the
module that is the value of the variable @code{user32.dll}.  The
variable @code{set-window-title} is defined to have this procedure as
it's value.

@example
(define set-window-title
  (windows-procedure (set-window-text (window hwnd) (text string))
    bool user32.dll "SetWindowText"))

(set-window-title my-win "Hi")   @result{}  #t
                                 @r{;; Changes window's title/text}

set-window-title                 @result{}  #[compiled-procedure  ...]
set-window-text                  @error{}  Unbound variable
@end example


When there are no @var{options} the created procedure will (a) check its
arguments against the types, (b) convert the arguments, (c) call the C
procedure and (d) convert the returned value.  No reversion is
performed, even if one of the @var{types} has a reversion defined.
(Reverted types are rare [I have never used one], so paying a cost for
this unless it is used seems silly).

The following options are allowed:

@table @asis
@item @code{with-reversions}
The reversions are included in the type conversions.

@item @code{expand}
A synonym for @code{with-reversions}.

@item @var{Scheme code}
The @var{Scheme code} is placed between steps (a) and (b) in the default
process.  The Scheme code can enforce constraints on the arguments,
including constraints between arguments such as checking that an index
refers to a valid position in a string.
@end table

If both options (i.e.@: @code{with-reversions} and Scheme code) are used,
@code{with-reversions} must appear first.  There can be arbitrarily many
Scheme expression.
@end deffn

@node Win32 API names and procedures,  , Windows Foreign Procedures, Foreign function interface
@subsection Win32 API names and procedures

This section is a moving target.
@cindex Win32 API names
@cindex naming conventions

The @code{#define} values from @file{wingdi.h} and @file{winuser.h} are
available as bindings in the @code{(win32)} package environment.  The
@code{#define} symbols are all uppercase; these have been translated to
all lowercase Scheme identifiers, thus @code{WM_LBUTTONUP} is the scheme
variable @code{wm_lbuttonup}.  As Scheme is case insensitive, the
upper-case version may be used and probably should to make the code look
more like conventional Windows code.  The Scheme bindings have been
produced automagically.  Most of the @code{#define}-symbols contain an
underscore so there are not many name clashes.  There is one very
notable name clash, however: @code{ERROR} is @code{#define}d to 0, which
shadows the scheme procedure @code{error} in the root package
environment.  To signal an error, use @code{access}:

@example
((access error ()) "Whine moan" ...)
@end example


The set of procedures is incomplete because procedures have been added
on a by-need basis for the implementation of other parts of the system,
e.g.@:  Scheme Graphics.  Look in the implementation for further details.

Win32 API procedure names have been uniformly converted into Scheme
identifiers as follows:

@itemize @bullet
@item
A leading uppercase letter is translated into a lowercase letter.
@item
Subsequent sequences of uppercase letters are translated into lowercase
letters preceeded by a hyphen (minus symbol), i.e.@: hyphens are inserted
at a lowercase to uppercase transition.
@item
Predicates beginning with @code{Is} finally have a
question-mark appended.
@end itemize
Example: applying these rules to @code{IsWindow} yields
@code{is-window?}, and @code{GetDC} is translated into @code{get-dc}.


@c [It might be worthwhile just keeping the same names.  As the
@c Win32 API procedure names are uniformly `WordWordWordACRONYMWord', case
@c insensitivity is unlikely to be a problem.  The only problem is the
@c potential for a clash between a procedure name and a type
@c name.]


@node Device Independent Bitmap Utilities,  , Foreign function interface, Win32 Package Reference
@section Device Independent Bitmap Utilities


The Device Independent Bitmap (DIB) utilities library @file{DIBUTILS.DLL}
and the associated procedures in @file{dib.scm} in the Win32 system
source is an example of how to use the foreign function interface to
access and manipulate non-Scheme objects.
@cindex DLL, DIBUTILS.DLL

@deffn {windows type} dib
In the C world a DIB is a @dfn{handle} to a piece of memory containing
the bits that represent information about the image and the pixels of
the image.  The handle is a machine-word sized piece of data which may
be thought of as a 32 bit integer.  The handle may be null (i.e.@: zero),
indicating that there is no block of memory describing the DIB.  The
null value is usually returned by C functions that are supposed to
create a DIB but failed, for some reason like the memory could not be
allocated or a file could not be opened.

In the Scheme world a DIB is a structure containing information
about the bitmap (specifically the integer that represents the handle).
We also include @code{#f} in the @code{dib} windows type to mirror the
null handle error value.
@example
(define dib-result
  (lambda (handle)
    (if (= handle 0)
        #f
        (make-dib handle))))

(define dib-arg
  (lambda (dib)
    (if dib
        (cell-contents (dib-handle dib))
        0)))  

(define-windows-type dib
  (lambda (thing) (or (dib? thing) (eq? thing #f)))
  dib-arg
  dib-result)
@end example
@end deffn


@menu
* DIB procedures::              
* Other parts of the DIB Utilities implementation::  
@end menu

@node DIB procedures, Other parts of the DIB Utilities implementation,  , Device Independent Bitmap Utilities
@subsection DIB procedures

The following procedures have typed parameters, using the same
convention as @code{windows-procedure}.

@deffn {procedure+} open-dib (filename string)
Return type: @var{dib}.  Calls the @code{OpenDIB} entry of
@file{DIBUTILS.DLL}.  If the return value is not @code{#f} then the file
@var{filename} was found, successfully opened, and the contents were
suitable for loading into memory as a device independent bitmap.
@end deffn

@deffn {procedure+} write-dib (filename string) (dib dib) 
Return type: @var{bool}.  Calls the @code{WriteDIB} entry of
@file{DIBUTILS.DLL}.  Returns @code{#t} if the file @var{filename} could
be opened and written to.  After this operation the file contains the
bitmap data in a standard format that is understood by @code{open-dib}
and various system utilities like the bitmap editor.  Any problems
resulting in failure are signalled by a @code{#f} return value.
@end deffn

@deffn {procedure+} bitmap-from-dib (dib dib) (palette hpalette)
Return type: @var{hbitmap}.
Calls the @code{BitmapFromDib} entry of @file{DIBUTILS.DLL}.  The returned
value is a device dependent bitmap.  The colours from the DIB are
matched against colors in @var{palette}.
@end deffn

@deffn {procedure+} dib-from-bitmap (bitmap hbitmap) (style dword) (bits word) (palette hpalette)
Return type: @var{dib}.
Returns a DIB containing the same image as the device dependent bitmap
@var{bitmap}.
@var{Style} determines the kind of DIB, e.g.@: compression style.
Calls the @code{DibFromBitmap} entry of @file{DIBUTILS.DLL}.
@end deffn

@deffn {procedure+} dib-blt (dest hdc) (x int) (y int) (w int) (h int) (src dib) (src-x int) (src-y int) (raster-op long)
Return type: @var{bool}.  Calls the @code{DibBlt} entry of
@file{DIBUTILS.DLL}.  Similar to the Win32 API @code{BitBlt} call, but
draws a DIB rather than a piece of another device context.  Draws the
@var{dib} on device context @var{hdc} at position (@var{x},@var{y}).  A
rectangle of width @var{w} and height @var{h} is copied from position
(@var{src-x},@var{src-y}) of @var{dib}.
@var{Raster-op} is supposed to allow the source and destination to be
combined but I don't think I got this right so stick to @code{SRCCOPY}.
@end deffn

@deffn {procedure+} %delete-dib (dib-handle handle)
Return type: @var{bool}.
Calls the @code{DeleteDIB} entry of @file{DIBUTILS.DLL}.
Note that the parameter is a @var{handle}, and not a @var{dib}.
This allows us to destroy a DIB and reclaim its memory by knowing only
the handle value, and not needing the @code{dib} record.
The importance of this is that if the @code{dib} record is GC-ed then a
GC hook can reclaim the storage knowing only the handle.
@end deffn

@deffn {procedure+} delete-dib (dib dib)
Return type: @var{bool}.
This procedure calls @code{%delete-dib} to reclaim the storage occupied
by a DIB.
After being deleted, the DIB should not be used.
This procedure allows the programmer to reclaim external heap storage
rather than risking it running out before the next garbage collection.
@end deffn

@deffn {procedure+} dib-height (dib dib)
Return type: @var{int}.
Calls the @code{DibHeight} expand entry of @file{DIBUTILS.DLL}, which returns
the height of the bitmap in pixels.
@end deffn

@deffn {procedure+} dib-width (dib dib)
Return type: @var{int}.
Calls the @code{DibWidth} entry of @file{DIBUTILS.DLL}, which returns
the width of the bitmap in pixels.
@end deffn

@deffn {procedure+} copy-bitmap (bm hbitmap)
Return type: @var{hbitmap}.
Calls the @code{CopyBitmap} of @file{DIBUTILS.DLL}, which creates a new
bitmap with the same size and contents as the original.
@end deffn

@deffn {procedure+} create-dib (width int) (height int) (style int) (depth int) (palette hpalette)
Return type: @var{dib}.
Calls the @code{CreateDIB} entry of @file{DIBUTILS.DLL}.
Creates a DIB of @var{width} by @var{height} pixels and @var{depth} bits
of colour information.
The @var{style} parameter determines how the bitmap is stored.
I have only ever used @code{BI_RGB}.
If @var{depth}<=8 then the @var{palette} determines the DIB's colour table.
@end deffn

@deffn {procedure+} crop-bitmap (bm hbitmap) (left int) (top int) (right int) (bottom int)
Return type: @var{hbitmap}.
Calls the @code{CropBitmap} entry of @file{DIBUTILS.DLL}.
Returns a new bitmap containing the image from a region of the original.
@end deffn

@deffn {procedure+} dib-set-pixels-unaligned dib (pixels string)
Return type: @var{bool}.
Calls the @code{DIBSetPixelsUnaligned} entry of @file{DIBUTILS.DLL}.  Stuffs
bytes from @var{pixels} into the bitmap.  There are no alignment
constraints on @var{pixels} (the usual way of doing this is to use the
@code{SetDIBits} function which requires that every scan line of the
bitmap is 32-bit word aligned, even if the scan lines are not a multiple
of 4 bytes long).  doing this
@end deffn

@node Other parts of the DIB Utilities implementation,  , DIB procedures, Device Independent Bitmap Utilities
@subsection Other parts of the DIB Utilities implementation


The @file{DIBUTILS.DLL} library is an ordinary DLL.  See the standard
Microsoft Windows documentation on how to create DLLs.  Look at the code
in the @file{WIN32/DIBUTILS} directory of the Scheme source.

Please note:
@itemize @bullet
@item
@cindex DLL, exports
For the foreign function interface to find the procedures they must be
declared as exports in the @file{.DEF} definition file.

@item
To load the @file{.DLL} file use the @code{find-module} Scheme function.
Look at @file{WIN32/DIB.SCM} to see how this is done.

@item
The current system works with C procedures with the @code{__stdcall} and
@code{__cdecl} calling conventions but @emph{not} the @code{__fastcall}
calling convention.
@end itemize


@c @node Writing windows procedures, Procedure Index, Device Independent Bitmap Utilities, Top
@c @section Writing windows procedures
@c 
@c @cindex warning
@c @strong{Warning:} Do not try to do this.  It is very hard to get it even
@c partly right and probably impossible to make the program 100% reliable.
@c 
@c It is possible to write Scheme procedures that determine the behaviour
@c of windows and controls on the screen.  To succeed at this you need a
@c good understanding of how you would do the same thing in C using the
@c Windows SDK, the limitations of mixed language working when C calls
@c Scheme, and lots of patience because debugging this kind of code is very
@c painful.
@c The only major example of this kind of code is the Scheme Graphics
@c implementation (source in @file{WIN32/GRAPHICS.SCM}, but you will need
@c to read @file{RUNTIME/GRAPHICS.SCM} and the DIB utilities too).
@c 
@c Currently, Scheme `wndprocs' are run during interrupt processing.  They
@c are run in the dynamic context of whatever was running when the
@c interrupt was signalled.  Any procedure that relies upon a fluid
@c variable cannot be used reliably.  Thus doing, say, a @code{display}
@c might result in the output unintentionally being inserted in a file
@c rather than appearing on the screen.  Errors are not handled, thus a
@c call to @code{(+ #f 5)} can result in the interrupt processing mechanism
@c becoming confused, and subsequently causing the system to lock up, as
@c all user input ultimately is processed using this same mechanism.
@c Obviously this state of affairs is not satisfactory and I intend to
@c improve things by running the wndprocs in a known dynamic context and
@c trapping errors, but not until Edwin's I/O handling is changed to
@c separate it more from this mechanism, and definitely not until after the
@c release.
@c 
@c @menu
@c * Procedures::                  
@c * Scheme WndProcs::             
@c @end menu
@c 
@c @node Procedures, ,  , Writing windows procedures
@c @subsection Procedures
@c 
@c @deffn {procedure+} get-handle index
@c Return a magic number that cannot be found any other way.
@c Subject to change, the current behaviour is:
@c 
@c @table @code
@c @item 0
@c The handle of the instance, @code{hInstance}, of the Scheme application
@c @item 1
@c The handle of the master tty window
@c @item 3
@c The address of the C function that invokes a Scheme wndproc.
@c @end table
@c @end deffn
@c 
@c @deffn {procedure+} create-scheme-window ex-style class name style x y w h parent menu inst param proc
@c Creates a window by calling @code{CreateWindowEx} with all the
@c parameters except @var{proc}.
@c 
@c @table @var
@c @item ex-style
@c Integer.
@c @item class
@c String.  Must name a window class created with a @code{lpfnWndProc}
@c entry that has the value of @code{(get-handle 3)}.
@c @item name
@c String.  Title of window.
@c @item style
@c Integer.
@c @item x y
@c Integer. Window position.
@c @item w h
@c Integer. Window size.
@c @item parent
@c Integer.  Handle of parent window.
@c @item menu
@c Integer or string.  Number or name of menu resource for this window's
@c menu.
@c 0 means no menu.
@c @item inst
@c Integer, should be the result of @code{(get-handle 0)}.
@c @item param
@c Integer.
@c @item proc
@c @var{Proc} is a Scheme procedure with four parameters, i.e.@: of the form
@c 
@c @example
@c (lambda (@var{hwnd} @var{msg} @var{wparam} @var{lparam})
@c   ...)
@c @end example
@c This procedure is the Scheme analogue of the C function that would
@c normally have been installed as the @code{lpfnWndProc} of the window
@c class.
@c @end table
@c @end deffn
@c 
@c @deffn {procedure+} subclass-window! hwnd subclass-behaviour
@c Replace @var{hwnd}'s wndproc with a wndproc formed by calling
@c @var{subclass-behaviour} on the original wndproc.
@c @end deffn
@c 
@c @deffn {procedure+} register-class  style wndproc clsExtra wndExtra hInstance hIcon hCursor hBackground menu-name class-name
@c A way to call @code{RegisterClass} without first constructing a C
@c @code{WNDCLASS} object.
@c @end deffn
@c 
@c @deffn {procedure+} default-scheme-wndproc
@c The Scheme equivalent of the C @code{DefWindowProc}.
@c @end deffn
@c 
@c @node Scheme WndProcs,  , Procedures, Writing windows procedures
@c @subsection  Scheme WndProcs
@c 
@c 
@c A Scheme wndproc is of the form
@c 
@c @cindex wndproc
@c @example
@c (lambda (hwnd msg wparam lparam)
@c   (cond ((= msg WM_CREATE)
@c          ...)
@c         (...
@c          ...)
@c         (else
@c          (default-scheme-wndproc hwnd msg wparam lparam))))
@c @end example
@c 
@c @cindex wndproc, higher-order
@c Scheme has the advantage over C that first class procedures can be used
@c to organize the data used by the window.
@c A useful idiom idiom is to parameterize the code with the default
@c behaviour.
@c This example behaves like @var{default-wndproc}, except that it
@c beeps every time the left mouse button is pressed.
@c 
@c @example
@c (define ((my-wndproc default-wndproc) hwnd msg wparam lparam)
@c   (define (default) (default-wndproc hwnd msg wparam lparam))
@c   (cond ((= msg WM_LBUTTONDOWN)
@c            (message-beep MB_OK)
@c            (default))
@c         (else
@c            (default))))
@c @end example
@c 
@c @noindent
@c @code{my-wndproc} is suitable for use with @code{subclass-window!}
@c For example,
@c 
@c @example
@c (subclass-window! (get-handle 1) my-wndproc)
@c @end example
@c Will cause the main Scheme window to beep every time the left mouse
@c button is pressed, but otherwise work normally.
@c 
@c In a similar fashion, Scheme wndprocs can be closed over state
@c describing the object that the window displays or edits.
@c An idiom for a complex kind of window is to have a record (structure)
@c representing the object, and to create the window procedure with that
@c object in scope.
@c The following extended example is a framework for an editor.
@c The @code{whizz-editor} record's @code{hwnd} field is set at window
@c creation time so that we can get the window handle from the record.  The
@c utility of this is demonstrated in @code{whizz-editor/set-title}.
@c 
@c @example
@c (define-structure whizz-editor
@c   hwnd
@c   magic-flag?
@c   @var{other stuff})
@c 
@c 
@c (define (make-whizz-editor-wndproc data)
@c   ;; @r{The following string is created once before the window comes}
@c   ;; @r{into existence}
@c   (define window-local-string (make-string 100))
@c 
@c   ;; @r{The normal wndproc}
@c   (define ((wndproc default-wndproc) hwnd msg wparam lparam)
@c     (define (default) (default-wndproc hwnd msg wparam lparam))
@c     (cond ((= msg WM_CREATE)
@c              (set-whizz-editor-hwnd! data hwnd)
@c              ...
@c              (default))
@c           (...
@c              ... (if (whizz-editor-magic-flag? data) ... ...)
@c              ...)
@c           (else
@c              (default))))
@c 
@c   wndproc)
@c      
@c 
@c (define (create-whizz-editor)
@c   (let* ((data     (make-whizz-editor 0 ...))
@c          (wndproc  (make-whizz-editor-wndproc data))
@c          
@c     (create-scheme-window
@c        0 "WHIZZ_EDITOR_CLASS" "Whizz Editor"
@c        (+ WS_VISIBLE WS_OVERLAPPED)
@c        CW_USEDEFAULT CW_USEDEFAULT CW_USEDEFAULT CW_USEDEFAULT
@c        0 0 (get-handle 0) 0
@c        (wndproc default-scheme-wndproc)))
@c     data))
@c 
@c (define (whizz-editor/set-title wh title)
@c   (set-window-text (whizz-editor-hwnd wh) title))
@c @end example
@c 
@c @noindent
@c Now we are ready to create a Whizz Editor and set its title:
@c 
@c @example
@c (define my-editor (create-whizz-editor))
@c (whizz-editor/set-title my-editor "A new title")
@c @end example
@c 
@c @node Procedure Index, Concept Index, , Top
@c @unnumbered Index of Procedures, Special Forms, and Variables
@c @printindex fn
@c 
@c @node Concept Index,  , Procedure Index, Top
@c @unnumbered Index of Concepts
@c @printindex cp
@c 
@c @node Procedure Index,  , Writing windows procedures, Top
@c @unnumbered Index
@c @printindex fn
@c 
@c @c @summarycontents
@c 
@c @contents
@c 
@c @c Local Variables:
@c @c eval: (auto-save-mode -1)
@c @c End:
@c 
@c @bye

@c WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

@ifset sicpstuff
@include pictures.texinfo
@end ifset

@node Index,  , Win32 Package Reference, Top
@unnumbered Index
@printindex cp

@summarycontents
@contents

@c Local Variables:
@c eval: (auto-save-mode -1)
@c End:

@bye
