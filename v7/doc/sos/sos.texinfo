\input texinfo @c -*-Texinfo-*-
@c %**start of header
@setfilename sos.info
@settitle @value{TITLE}
@c %**end of header
@setchapternewpage odd
@synindex vr fn

@c $Id: sos.texinfo,v 1.2 1993/02/24 05:52:51 cph Exp $

@set TITLE The SOS Reference Manual
@set EDITION 1.2
@set UPDATED 21 February 1993
@set UPDATE-MONTH February 1993

@ifinfo
Copyright @copyright{} 1993 Massachusetts Institute of Technology

This is Edition @value{EDITION}, last updated @value{UPDATED}, of
@cite{@value{TITLE}}.

This material was developed by the Scheme project at the Massachusetts
Institute of Technology, Department of Electrical Engineering and Computer
Science.  Permission to copy this document, to redistribute it, and to use
it for any purpose is granted, subject to the following restrictions and
understandings.

@enumerate
@item
Any copy made of this document must include this copyright notice in
full.

@item
Users of this document agree to make their best efforts (a) to return to
the MIT Scheme project any improvements or extensions that they make, so
that these may be included in future releases; and (b) to inform MIT of
noteworthy uses of this document.

@item
All materials developed as a consequence of the use of this document shall
duly acknowledge such use, in accordance with the usual standards of
acknowledging credit in academic research.

@item
MIT has made no warrantee or representation that the contents of this
document will be error-free, and MIT is under no obligation to provide any
services, by way of maintenance, update, or otherwise.

@item
In conjunction with products arising from the use of this material, there
shall be no use of the name of the Massachusetts Institute of Technology
nor of any adaptation thereof in any advertising, promotional, or sales
literature without prior written consent from MIT in each case.
@end enumerate
@end ifinfo

@titlepage
@title @value{TITLE}
@subtitle Edition @value{EDITION}
@subtitle @value{UPDATE-MONTH}
@author by Chris Hanson

@page

@vskip 0pt plus 1filll
Copyright @copyright{} 1993 Massachusetts Institute of Technology

This material was developed by the Scheme project at the Massachusetts
Institute of Technology, Department of Electrical Engineering and Computer
Science.  Permission to copy this document, to redistribute it, and to use
it for any purpose is granted, subject to the following restrictions and
understandings.

@enumerate
@item
Any copy made of this document must include this copyright notice in
full.

@item
Users of this document agree to make their best efforts (a) to return to
the MIT Scheme project any improvements or extensions that they make, so
that these may be included in future releases; and (b) to inform MIT of
noteworthy uses of this document.

@item
All materials developed as a consequence of the use of this document shall
duly acknowledge such use, in accordance with the usual standards of
acknowledging credit in academic research.

@item
MIT has made no warrantee or representation that the contents of this
document will be error-free, and MIT is under no obligation to provide any
services, by way of maintenance, update, or otherwise.

@item
In conjunction with products arising from the use of this material, there
shall be no use of the name of the Massachusetts Institute of Technology
nor of any adaptation thereof in any advertising, promotional, or sales
literature without prior written consent from MIT in each case.
@end enumerate
@end titlepage

@node Top, Object System, (dir), (dir)

This is Edition @value{EDITION}, last updated @value{UPDATED}, of
@cite{The SOS Reference Manual}.

@menu
* Object System::               
* Variable Index::              
* Concept Index::               

 --- The Detailed Node Listing ---

The Object System

* Language::                    
* Reflective Operations::       
* Meta-Object Protocol::        
* Miscellany::                  

The Language

* Classes::                     
* Predefined Classes::          
* Instances::                   
* Slots::                       
* Generic Procedures::          
* Methods::                     

Reflective Operations

* Class Reflectives::           Reflective Operations on Classes
* Generic Reflectives::         Reflective Operations on Generic Procedures
* Method Reflectives::          Reflective Operations on Methods
* Slot Reflectives::            Reflective Operations on Slots

The Meta-Object Protocol

* Generic Invocation Subprotocol::  
* Instantiation Subprotocol::   
* Class Initialization Subprotocol::  
@end menu

@node Object System, Variable Index, Top, Top
@chapter The Object System

@sc{sos} is a Scheme ``object system'' derived from ``Tiny @sc{clos}'',
written by Gregor Kiczales, which in turn was loosely derived from
@sc{clos}, the Common Lisp Object System.  Its basic design and
philosophy is closely related to Tiny @sc{clos}, but there are
differences in naming, interface, and in the meta-object protocol.

In the procedure descriptions that follow, certain argument names imply
restrictions on the corresponding argument:

@table @var
@item class
The argument must be a @dfn{class}, i.e.@: it must satisfy the predicate
@code{class?}.

@item instance
The argument must be an @dfn{instance}, i.e.@: it must satisfy the
predicate @code{instance?}.

@item name
The argument must be a symbol.

@item generic-procedure
The argument must be a @dfn{generic procedure}, i.e.@: it must satisfy
the predicate @code{generic-procedure?}.

@item generic
The argument must be a @dfn{generic procedure instance}, i.e.@: it must
satisfy the predicate @code{(lambda (x) (instance-of? x <generic>))}.

@item method
The argument must be a @dfn{method}, i.e.@: it must satisfy the
predicate @code{(lambda (x) (instance-of? x <method>))}.

@item procedure
The argument must be a procedure.

@item slot
The argument must be a @dfn{slot descriptor}, i.e.@: it must satisfy the
predicate @code{slot?}.

@item plist
The argument must be a @dfn{property list}, i.e.@: it must be a list of
even length, the even-numbered elements of which must be symbols.
@end table

@menu
* Language::                    
* Reflective Operations::       
* Meta-Object Protocol::        
* Miscellany::                  
@end menu

@node Language, Reflective Operations,  , Object System
@section The Language

@menu
* Classes::                     
* Predefined Classes::          
* Instances::                   
* Slots::                       
* Generic Procedures::          
* Methods::                     
@end menu

@node Classes, Predefined Classes,  , Language
@subsection Classes

@cindex class
@cindex instance
A @dfn{class} is an object that determines the structure and behavior of
a set of other objects, which are called its @dfn{instances}.

@cindex subclass
@cindex superclass
A class can inherit structure and behavior from other classes.  A class
whose definition refers to other classes for the purpose of inheriting
from them is said to be a @dfn{subclass} of each of those classes.  The
classes that are designated for purposes of inheritance are said to be
@dfn{superclasses} of the inheriting class.

@cindex class name
@cindex name, of class
A class can have a @dfn{name}.  The procedure @code{class-name} takes a
class object and returns its name.  The name of an anonymous class is
@code{#f}.

@cindex direct superclass
@cindex superclass, direct
@cindex direct subclass
@cindex subclass, direct
A class @code{c[1]} is a @dfn{direct superclass} of a class @code{c[2]}
if @code{c[2]} explicitly designates @code{c[1]} as a superclass in its
definition.  In this case, @code{c[2]} is a @dfn{direct subclass} of
@code{c[1]}.  A class @code{c[n]} is a @dfn{superclass} of a class
@code{c[1]} if there exists a series of classes @code{c[2]}, @dots{},
@code{c[n-1]} such that @code{c[i+1]} is a direct superclass of
@code{c[i]} for all @code{i} between @code{1} and @code{n}.  In this
case, @code{c[1]} is a @dfn{subclass} of @code{c[n]}.  A class is
considered neither a superclass nor a subclass of itself.  That is, if
@code{c[1]} is a superclass of @code{c[2]}, then @code{c[1]} is
different from @code{c[2]}.  The set of classes consisting of some given
class @code{c} along with all of its superclasses is called ``@code{c}
and its superclasses.''

@cindex class precedence list
@cindex precedence list, class
Each class has a @dfn{class precedence list}, which is a total ordering
on the set of the given class and its superclasses.  The total ordering
is expressed as a list ordered from the most specific to the least
specific.  The class precedence list is used in several ways.  In
general, more specific classes can @dfn{shadow}, or override, features
that would otherwise be inherited from less specific classes.  The
method selection and combination process uses the class precedence list
to order methods from most specific to least specific.

@cindex local precedence order
@cindex precedence order, local
@cindex order, local precedence
When a class is defined, the order in which its direct superclasse are
mentioned in the defining form is important.  Each class has a
@dfn{local precedence order}, which is a list consisting of the class
followed by its direct superclasses in the order mentioned in the
defining form.

A class precedence list is always consistent with the local precedence
order of each class in the list.  The classes in each local precedence
order appear within the class precedence list in the same order.  If the
local precedence orders are inconsistent with each other, no class
precedence list can be constructed, and an error is signalled.

Classes are organized into a @dfn{directed acyclic graph}.  There are
two distinguished classes, named @code{<object>} and @code{<instance>}.
The class named @code{<object>} has no superclasses.  It is a superclass
of every class except itself.  The class named @code{<instance>} is an
instance of the class @code{<class>} and is a superclass of every class
that is an instance of @code{<class>} except itself.

@cindex metaclass
Classes are represented by objects that are themselves instances of
classes.  The class of the class of an object is termed the
@dfn{metaclass} of that object.  When no misinterpretation is possible,
the term @dfn{metaclass} will be used to refer to a class that has
instances that are themselves classes.  The metaclass determines the
form of the instances of those classes.  @sc{sos} provides a default
metaclass, @code{<class>}, that is appropriate for most programs.  The
meta-object protocol provides mechanisms for defining and using new
metaclasses.

Except where otherwise specified, all classes mentioned in this chapter
are instances of the class @code{<class>}, all generic procedures are
instances of the class @code{<generic-procedure>}, and all methods are
instances of the class @code{<method>}.

@deffn Syntax define-class name direct-superclasses direct-slot @dots{}
Define @var{name} to be a class.  In its basic form, @code{define-class}
might have been defined by

@lisp
(define-syntax define-class
  (syntax-rules ()
    ((define-class name (class ...) slot ...)
     (define name
       (make-class (quote name)
                   (list class ...)
                   (quote (slot ...)))))))
@end lisp

@cindex class options
@code{define-class} permits the specification of @dfn{class options},
which are options that pertain to the class as a whole.  Class options
are specified by overloading @var{name}: instead of a symbol, specify a
pair whose @sc{car} is a symbol and whose @sc{cdr} is an alist.  At
present only one class option is recognized:

@table @code
@item (metaclass @var{class})
Specifies that @var{class} is the metaclass of the class being defined.
If this option is not given, the metaclass defaults to @code{<class>}.
@end table
@end deffn

@deffn Procedure make-class name direct-superclasses direct-slots
Creates and returns a new class object.

@var{Name} is used for debugging: it is a symbol that appears in the
printed representation of the class and has no role in the semantics of
the class.  Alternatively, @var{name} may be @code{#f} to indicate that
the class is anonymous.

@var{Direct-superclasses} must be a list of class objects.  The new
class inherits both methods and slots from the classes in this list.
Specifying the empty list for @var{direct-superclasses} is equivalent to
specifying @code{(list <instance>)}.

@var{Direct-slots} describes additional slots that instances of this
class will have.  It is a list, each element of which must have one of
the following forms:

@example
@var{NAME}
(@var{NAME} . @var{PLIST})
@end example

@noindent
where @var{name} is a symbol, and @var{plist} is a property list.  The
first of these two forms is equivalent to the second with an empty
@var{plist}.

Each of the elements of @var{direct-slots} defines one slot named
@var{name}.  @var{Plist} is used to describe additional properties of
that slot.  The meaning of @var{plist} is defined by
@code{compute-slot-descriptor}; by default these properties are
recognized:

@table @code
@item initializer
A procedure of no arguments that is called (by @code{allocate-instance})
whenever an instance containing this slot is created.  The value
returned by the procedure is the initial value of the slot.  If the
@code{initializer} property is not specified, or if it is specified as
@code{#f}, the slot is not initialized.

The use of the @code{initializer} is automatic if the slot has an
@code{allocation} of @code{instance}; otherwise the meta-object protocol
must invoke @code{initializer} and use its value to initialize the slot.

@item accessor
This property specifies a generic procedure; @code{make-class} will add
an accessor method for this slot to the procedure.

@item modifier
This property specifies a generic procedure; @code{make-class} will add
a modifier method for this slot to the procedure.

@item initpred
This property specifies a generic procedure; @code{make-class} will add
an ``initialized?'' predicate method for this slot to the procedure.

@item allocation
A symbol describing how the slot should be allocated.  If the
@code{allocation} property is the symbol @code{instance}, or if it is
not specified, then the slot is an ordinary instance slot.  Otherwise
the slot is a virtual slot and the meaning of the symbol is defined by
the virtual slot protocol.
@end table

Please note that the following are equivalent, although the former is
slightly faster:

@lisp
(make-class @var{name} @var{superclasses} @var{slots})
(make-instance <class> @var{name} @var{superclasses} @var{slots})
@end lisp
@end deffn

@deffn Procedure class? object
Returns @code{#t} if @var{object} is a class, otherwise returns
@code{#f}.
@end deffn

@deffn Procedure object-class object
Returns the class of @var{object}.  @var{Object} may be any Scheme
object; if @var{object} is known to be an instance, it is better to use
@code{instance-class} rather than @code{object-class}.
@end deffn

@deffn Procedure instance-class instance
Returns the class of @var{instance}.
@end deffn

@node Predefined Classes, Instances, Classes, Language
@subsection Predefined Classes

@defvr Class <object>
This is the class of all Scheme objects.  It has no direct superclasses,
and all classes are subclasses of this class.
@end defvr

@defvr Class <instance>
This is the class of instances.  It is a direct subclass of
@code{<object>}.  The members of this class are the objects that satisfy
the predicate @code{instance?}.
@end defvr

@defvr Class <class>
This is the class of class objects.  It is a direct subclass of
@code{<instance>}.  The members of this class are the objects that
satisfy the predicate @code{class?}.
@end defvr

@defvr Class <generic>
This is the class of generic procedure instances.  It is a direct
subclass of @code{<instance>}.
@end defvr

@defvr Class <method>
This is the class of method objects.  It is a direct subclass of
@code{<instance>}.
@end defvr

@defvr Class <boolean>
@defvrx Class <char>
@defvrx Class <number>
@defvrx Class <pair>
@defvrx Class <procedure>
@defvrx Class <string>
@defvrx Class <symbol>
@defvrx Class <vector>
These are the classes of their respective Scheme objects.  They are all
direct subclasses of @code{<object>}.  The members of each class are the
objects that satisfy the corresponding predicate; for example, the
members of @code{<procedure>} are the objects that satisfy
@code{procedure?}.
@end defvr

The following are the classes of Scheme numbers.  Note that
@code{object-class} will never return one of these classes; instead it
returns an implementation-specific class that is associated with a
particular numeric representation.  The implementation-specific class is
a subclass of one or more of these implementation-independent classes,
so you should use these classes for specialization.

@defvr Class <complex>
@defvrx Class <real>
@defvrx Class <rational>
@defvrx Class <integer>
These are the classes of the Scheme numeric tower.  @code{<complex>} is
a direct subclass of @code{<number>}, @code{<real>} is a direct subclass
of @code{<complex>}, etc.
@end defvr

@defvr Class <exact>
@defvrx Class <exact-complex>
@defvrx Class <exact-real>
@defvrx Class <exact-rational>
@defvrx Class <exact-integer>
These are the classes of exact numbers.  @code{<exact>} is a direct
subclass of @code{<number>}, @code{<exact-complex>} is a direct
subclass of @code{<exact>} and @code{<complex>}, and in general, each is
a direct subclass of preceding class and of the class without the
@code{exact-} prefix.
@end defvr

@defvr Class <inexact>
@defvrx Class <inexact-complex>
@defvrx Class <inexact-real>
@defvrx Class <inexact-rational>
@defvrx Class <inexact-integer>
These are the classes of inexact numbers.  @code{<inexact>} is a direct
subclass of @code{<number>}, @code{<inexact-complex>} is a direct
subclass of @code{<inexact>} and @code{<complex>}, and in general, each
is a direct subclass of preceding class and of the class without the
@code{inexact-} prefix.
@end defvr

@defvr Class <entity>
This is the class of entity objects.  It is a direct subclass of
@code{<procedure>}.  This class is defined only in @sc{mit} Scheme.
@end defvr

@defvr Class <record>
This is the class of record objects.  It is a direct subclass of
@code{<object>}.  This class is defined only in @sc{mit} Scheme.
@end defvr

@node Instances, Slots, Predefined Classes, Language
@subsection Instances

@deffn Procedure make-instance class initarg @dots{}
Creates and returns a new instance of @var{class}.

The instance is created by a two-step process, which is described here
to explain the meaning of the @var{initarg} arguments.

@enumerate
@item
@code{allocate-instance} is called with @var{class} as its argument to
allocate a new instance.

@item
@code{initialize-instance} is called with the new instance and the
@var{initarg}s as its arguments.
@end enumerate

@noindent
In other words, @code{make-instance} might be defined by

@lisp
(define (make-instance class . initargs)
  (let ((instance (allocate-instance class)))
    (apply initialize-instance instance initargs)
    instance))
@end lisp

Note that the meaning of the @var{initarg}s is completely determined by
@code{initialize-instance}.  The default method for
@code{initialize-instance} does not accept any @var{initarg}s; if you
want to pass @var{initarg}s when creating an instance, you must define a
method on @code{initialize-instance} to accept them.

Here is an example showing how this is done:

@lisp
(define-class <position> (<instance>)
  x
  y)

(define position-x (slot-accessor 'x))
(define position-y (slot-accessor 'y))
(define set-position-x! (slot-modifier 'x))
(define set-position-y! (slot-modifier 'y))

(define-method initialize-instance ((position <position>) x y)
  (set-position-x! position x)
  (set-position-y! position y))

(make-instance <position> 3.0 5.3)
@end lisp
@end deffn

@deffn Procedure instance? object
Returns @code{#t} if @var{object} is an instance, otherwise returns
@code{#f}.
@end deffn

@deffn Procedure instance-of? instance class
Returns @code{#t} if @var{instance} is a general instance of
@var{class}, otherwise returns @code{#f}.  In other words, this
predicate is true if the class of @var{instance} is @var{class} or one
of its subclasses.
@end deffn

@node Slots, Generic Procedures, Instances, Language
@subsection Slots
@cindex slots

An object that has @code{<class>} as its metaclass has zero or more
named slots.  The slots of an object are determined by the class of the
object.  Each slot can hold one value.  The name of a slot is a symbol.

@cindex uninitialized slot
@cindex slot, uninitialized
When a slot does not have a value, the slot is said to be
@dfn{uninitialized}.  The default initial value for a slot is defined by
the @code{initializer} slot option.

@cindex instance slot
@cindex slot, instance
An @dfn{instance slot} is defined to be a slot that is visible to
exactly one instance, namely the one in which the slot is allocated.
The @code{allocation} slot option to @code{make-class} controls the kind
of slot that is defined.  If the value of the @code{allocation} slot
option is @code{instance}, an instance slot is created.

@cindex accessibility of slots
A slot is said to be @dfn{accessible} in an instance of a class if the
slot is defined by the class of the instance or is inherited from a
superclass of that class.  At most one slot of a given name can be
accessible in an instance.

Slots can be accessed in two ways: by use of the primitive procedures
@code{slot-accessor}, @code{slot-modifier}, @code{slot-value}, and
@code{set-slot-value!}, and by use of methods generated by
@code{make-class}.

The procedures @code{slot-accessor}, @code{slot-modifier},
@code{slot-value}, and @code{set-slot-value!} can be used with any slot
name specified in the call to @code{make-class} to access a specific
slot accessible in an instance of the given class.

@cindex accessor, for slot
@cindex slot accessor
@cindex modifier, for slot
@cindex slot modifier
The procedure @code{make-class} provides slot options for generating
methods to read and write slots.  If an @dfn{accessor} is requested, a
method is automatically generated for reading the value of the slot.  If
a @dfn{modifier} is requested, a method is automatically generated for
storing a value into the slot.  When an accessor or modifier is
specified for a slot, the generic procedure to which the generated
method belongs is directly specified.  The procedure specified for the
accessor takes one argument, the instance.  The procedure specified for
the modifier takes two arguments, the instance and the new value, in
that order.

Accessor and modifier methods can also be generated by the procedures
@code{slot-accessor-method} and @code{slot-modifier-method},
respectively.  These methods may be added to a generic function by
passing them as arguments to @code{add-method}.  The methods generated
by these procedures are completely equivalent to those generated by the
options to @code{make-class}.

Note that @code{slot-value}, @code{set-slot-value!}, and
@code{slot-initialized?} should not be used in most code, as they are
inherently slower than the other slot access mechanisms.

To clarify the relationships between the various access mechanisms, here
are implementations of @code{slot-accessor-method} and
@code{slot-value}, both in terms of @code{slot-accessor}.  These
implementations are semantically correct, but do not accurately depict
performance.

@lisp
(define (slot-accessor-method slot)
  (make-method
   (list (slot-class slot))
   (let ((accessor (slot-accessor (slot-name slot))))
     (lambda (call-next-method instance)
       (accessor instance)))))

(define (slot-value instance name)
  ((slot-accessor name) instance))
@end lisp

@deffn Procedure slot-accessor name
Returns a procedure of one argument which is an accessor for the slot
@var{name}; @var{name} may be either a symbol or a slot descriptor.  The
argument to this procedure must be an instance.  When the procedure is
called, it returns the contents of the slot @var{name} in that instance.
If the given instance does not have such a slot, or if the slot is not
initialized, an error is signalled.
@end deffn

@deffn Procedure slot-modifier name
Returns a procedure of two arguments which is a modifier for the slot
@var{name}; @var{name} may be either a symbol or a slot descriptor.
This first argument to this procedure must be an instance, and the
second argument may be any object.  When the procedure is called, it
modifies the slot @var{name} in the instance to contain the second
argument.  If the given instance does not have such a slot, an error is
signalled.
@end deffn

@deffn Procedure slot-initpred name
Returns a procedure of one argument which is an ``initialized?''
predicate for the slot @var{name}; @var{name} may be either a symbol or
a slot descriptor.  The argument to this procedure must be an instance.
When the procedure is called, it return @code{#t} if the slot @var{name}
in that instance is initialized, otherwise it returns @code{#f}.  If the
given instance does not have such a slot, an error is signalled.
@end deffn

@deffn Procedure slot-accessor-method slot
Returns an accessor method for @var{slot}.  This method has one required
argument, an instance, and the specializer for that argument is the
@code{slot-class} of @var{slot}.  When invoked, the method returns the
contents of the slot specified by @var{slot} in the instance.  However,
if that slot is not initialized, an error is signalled instead.
@end deffn

@deffn Procedure slot-modifier-method slot
Returns a modifier method for @var{slot}.  This method has two required
arguments, an instance and an object.  The specializer for the first
argument is the @code{slot-class} of @var{slot}; the second argument is
not specialized.  When invoked, the method stores the second argument in
the slot specified by @var{slot} in the instance.
@end deffn

@deffn Procedure slot-initpred-method slot
Returns an ``initialized?'' predicate method for @var{slot}.  This
method has one required argument, an instance, and the specializer for
that argument is the @code{slot-class} of @var{slot}.  When invoked, the
method returns @code{#t} if the slot specified by @var{slot} is
initialized in the instance; otherwise it returns @code{#f}.
@end deffn

@deffn Procedure slot-value instance name
Returns the contents of the slot @var{name} in @var{instance};
@var{name} may be either a symbol or a slot descriptor.  If
@var{instance} does not have such a slot, or if the slot is not
initialized, an error is signalled.
@end deffn

@deffn Procedure set-slot-value! instance name object
Modifies the slot @var{name} in @var{instance} to contain @var{object};
@var{name} may be either a symbol or a slot descriptor.  If
@var{instance} does not have such a slot, an error is signalled.
@end deffn

@deffn Procedure slot-initialized? instance name
Returns @code{#t} if the slot @var{name} in @var{instance} is
initialized, otherwise returns @code{#f}; @var{name} may be either a
symbol or a slot descriptor.  If @var{instance} does not have such a
slot, an error is signalled.
@end deffn

@node Generic Procedures, Methods, Slots, Language
@subsection Generic Procedures

Like an ordinary Scheme procedure, a generic procedure takes arguments,
performs a series of operations, and perhaps returns useful values.  An
ordinary procedure has a single body of code that is always executed
when the procedure is called.  A generic procedure has a set of bodies
of code of which a subset is selected for execution.  The selected
bodies of code and the manner of their combination are determined by the
classes of one or more of the arguments to the generic procedure.

Ordinary procedures and generic procedures are called with identical
procedure-call syntax.

Generic procedures are true procedures that can be passed as arguments,
returned as values, and otherwise used in all the ways an ordinary
procedure may be used.  In particular, generic procedures satisfy the
predicate @code{procedure?}.

@deffn Syntax define-generic-procedure name lambda-list
Defines @var{name} to be a generic procedure.  @var{Lambda-list} is an
ordinary parameter list, which is exactly like the parameter list in a
@code{lambda} special form.  @code{define-generic-procedure} expands
into

@lisp
(define @var{name}
  (make-generic-procedure (quote @var{name})
                          @var{min-arity}
                          @var{max-arity}))
@end lisp

@noindent
where @var{min-arity} and @var{max-arity} are determined from
@var{lambda-list}.
@end deffn

@deffn Procedure make-generic-procedure name min-arity max-arity
Creates and returns a new generic procedure.  The generic procedure
requires at least @var{min-arity} arguments, and at most @var{max-arity}
arguments; if @var{max-arity} is @code{#f}, there is no upper bound on
the number of arguments accepted.

@var{Name} is used for debugging: it is a symbol that has no role in the
semantics of the generic procedure.  Alternatively, @var{name} may be
@code{#f} to indicate that the generic procedure is anonymous.

@var{Min-arity} must be an exact positive integer.  @var{Max-arity}
must be @code{#f} or an exact integer greater than or equal to
@var{min-arity}.
@end deffn

@deffn Procedure generic-procedure? object
Returns @code{#t} if @var{object} is a generic procedure, otherwise
returns @code{#f}.  Note that every generic procedure satisfies the
predicate @code{procedure?}.
@end deffn

@node Methods,  , Generic Procedures, Language
@subsection Methods

A method object contains a method procedure and a sequence of
@dfn{parameter specializers} that specify when the given method is
applicable.

A method object is not a procedure and cannot be invoked as a procedure.
Various mechanisms in @sc{sos} take a method object and invoke its
method procedure, as is the case when a generic procedure is called.
When this occurs it is said that the method is invoked or called.

@deffn Syntax define-method generic-procedure lambda-list body @dots{}
Defines a method of @var{generic-procedure}.  @var{Lambda-list} is like
the parameter list of a @code{lambda} special form, except that the
required parameters may have associated specializers.  A parameter with
an associated specializer is written as a list of two elements: the
first element is the parameter's name, and the second element is an
expression that evaluates to a class.

@var{Lambda-list} must contain at least one required parameter, and at
least one required parameter must be specialized.

A @code{define-method} special form expands into the following:

@lisp
(add-method @var{generic-procedure}
  (make-method (list @var{specializer} @dots{})
    (lambda (call-next-method . @var{stripped-lambda-list})
      @var{body} @dots{})))
@end lisp

@noindent
where @var{stripped-lambda-list} is @var{lambda-list} with the
specialized parameters replaced by their names, and the
@var{specializer}s are the corresponding expressions from the
specialized parameters.  If necessary, the @var{specializer}s are
interspersed with references to @code{<object>} in order to make them
occur in the correct position in the sequence.

For example,

@lisp
(define-method add ((x <integer>) (y <rational>)) ...)
@end lisp

@noindent
expands into

@lisp
(add-method add
  (make-method (list <integer> <rational>)
    (lambda (call-next-method x y) ...)))
@end lisp

Note that the list of specializers passed to @code{make-method} will
correspond to the required parameters of the method; the specializer
corresponding to a non-specialized required parameter is
@code{<object>}.
@end deffn

@deffn Procedure add-method generic-procedure method
Adds @var{method} to @var{generic-procedure}.  If
@var{generic-procedure} already has a method with the same specializers
as @var{method}, then the old method is discarded and @var{method} is
used in its place.
@end deffn

@deffn Procedure make-method specializers procedure
Creates and returns a new method object.  @var{Specializers} must be a
non-null list of class objects.  @var{Procedure} should accept one more
argument than the generic procedure to which this method will be added;
when called, the first argument will be a ``call-next-method''
procedure, and the remaining arguments will be the arguments that were
passed to the generic procedure.  The ``call-next-method'' procedure
accepts arguments, which are passed directly to the next method in place
of the generic procedure's arguments.  It is the method writer's
responsibility to see that the ``call-next-method'' procedure's
arguments are sensible.

@quotation
@strong{Please note:} In Dylan, calling the ``call-next-method''
procedure with no arguments causes the next method to be called with the
arguments passed to the calling method; in this system, this calls the
next method with no arguments.
@end quotation
@end deffn

@node Reflective Operations, Meta-Object Protocol, Language, Object System
@section Reflective Operations

@menu
* Class Reflectives::           Reflective Operations on Classes
* Generic Reflectives::         Reflective Operations on Generic Procedures
* Method Reflectives::          Reflective Operations on Methods
* Slot Reflectives::            Reflective Operations on Slots
@end menu

@node Class Reflectives, Generic Reflectives,  , Reflective Operations
@subsection Reflective Operations on Classes

@deffn Procedure class-name class
Returns the name of @var{class}.  This is the @var{name} argument passed
to @code{make-class} when @var{class} was created.
@end deffn

@deffn Procedure class-direct-superclasses class
Returns a list of the direct superclasses of @var{class}.  If a
non-empty @var{direct-superclasses} argument was passed to
@code{make-class} when @var{class} was created, this list is
@code{equal?} to that argument.

The returned value must not be modified.
@end deffn

@deffn Procedure class-precedence-list class
Returns a list of the superclasses of @var{class}.  The order of this
list is significant: it is the method resolution order.  This list will
always have @var{class} as its first element, and @code{<object>} as its
last element.

The returned value must not be modified.
@end deffn

@node Generic Reflectives, Method Reflectives, Class Reflectives, Reflective Operations
@subsection Reflective Operations on Generic Procedures

Generic procedures have associated objects, called @dfn{generic
procedure instances}, that contain interesting information about the
generic procedure.  The reflective operations for generic procedures do
not act directly on generic procedures, but rather on generic procedure
instances.  This division might seem clumsy, but it serves a purpose: it
separates the accessing of reflective data in the instance from the
mapping between the generic procedure and its associated instance.  This
is desirable because the mapping between a generic procedure and its
instance is much slower than an instance slot access.  More
specifically, @code{procedure->generic} is much slower than
@code{generic-min-arity}.

@deffn Procedure procedure->generic procedure
If @var{procedure} is a generic procedure, this procedure returns the
generic procedure instance associated with @var{procedure}.  Otherwise,
it returns @code{#f}.
@end deffn

@deffn Procedure generic->procedure generic
Returns the generic procedure associated with @var{generic}.
@end deffn

@deffn Procedure generic-name generic
@deffnx Procedure generic-min-arity generic
@deffnx Procedure generic-max-arity generic
These procedures return the arguments that were passed to
@code{make-generic-procedure} to create the generic procedure associated
with @var{generic}.
@end deffn

@deffn Procedure generic-methods generic
Returns a list of the method objects that are contained in the generic
procedure associated with @var{generic}.  This list is in no particular
order, and it must not be modified.
@end deffn

@node Method Reflectives, Slot Reflectives, Generic Reflectives, Reflective Operations
@subsection Reflective Operations on Methods

@deffn Procedure method-specializers method
Returns the list of specializers of @var{method}.  This list must not be
modified.
@end deffn

@deffn Procedure method-procedure method
Returns the procedure of @var{method}.
@end deffn

@node Slot Reflectives,  , Method Reflectives, Reflective Operations
@subsection Reflective Operations on Slots

@deffn Procedure slot-descriptors class
Returns a list of the slot descriptors for the slots of @var{class}.
This list is in no particular order and must not be modified.
@end deffn

@deffn Procedure slot-descriptor instance name
Returns the slot descriptor for the slot @var{name} in @var{instance}.
@end deffn

@deffn Procedure slot? object
Returns @code{#t} if @var{object} is a slot descriptor, otherwise
returns @code{#f}.
@end deffn

@deffn Procedure slot-name slot
Returns the name of @var{slot}.
@end deffn

@deffn Procedure slot-class slot
Returns the class of @var{slot}.  This is the class with which
@var{slot} is associated.  This is not necessarily the class that
defines @var{slot}; it could also be a subclass of that class.  If
@var{slot} was returned by @code{slot-descriptors}, this class is the
argument to @code{slot-descriptors}.  If @var{slot} was returned by
@code{slot-descriptor}, this class is the class of the instance that was
passed to @code{slot-descriptor}.
@end deffn

@deffn Procedure slot-allocation slot
Returns the allocation of @var{slot}.  This is a symbol that says how
the storage for the slot is allocated.  For instance slots, this symbol
is @code{instance}.
@end deffn

@deffn Procedure slot-initializer slot
Returns the initializer for @var{slot}.  This is a procedure of no
arguments that is called to produce an initial value for @var{slot}.
The initializer may also be @code{#f} meaning that the slot has no
initializer.
@end deffn

@deffn Procedure slot-plist slot
Returns the property list of @var{slot}.  This list is constructed from
the class definitions that contributed to @var{slot}'s definition.  This
list must not be modified.
@end deffn

@deffn Procedure slot-plist-lookup plist name default
Looks up @var{name} in @var{plist}.  If found, the associated datum is
returned; otherwise, @var{default} is returned.  @var{Default} may be
any object.
@end deffn

@deffn Procedure slot-property slot name [default]
Looks up @var{name} in @var{slot}'s property list.  If found, the
associated datum is returned.  Otherwise, if @var{default} is given it
is returned.  Otherwise, an error is signalled.  @var{Default}, if
given, may be any object.
@end deffn

@node Meta-Object Protocol, Miscellany, Reflective Operations, Object System
@section The Meta-Object Protocol

@menu
* Generic Invocation Subprotocol::  
* Instantiation Subprotocol::   
* Class Initialization Subprotocol::  
@end menu

@node Generic Invocation Subprotocol, Instantiation Subprotocol,  , Meta-Object Protocol
@subsection The Generic Invocation Subprotocol

@deffn {Generic Procedure} compute-apply-generic generic
@cindex discriminating procedure
Computes and returns the @dfn{discriminating procedure} for
@var{generic}.

This generic procedure is called to determine the discriminating
procedure for a generic procedure.  When a generic procedure is called,
the @emph{installed} discriminating procedure is called with the full
set of arguments received by the generic procedure, and must implement
the behavior of calling the generic procedure: determining the ordered
set of applicable methods, determining the effective method procedure,
and running the effective method procedure.

To determine the ordered set of applicable methods, the discriminating
procedure calls @code{compute-methods}.  The discriminating procedure is
permitted to memoize the value of @code{compute-methods} as follows.
The discriminating procedure may reuse the list of applicable methods
without calling @code{compute-methods} again provided that all of the
following are true:

@enumerate
@item
The generic procedure is being called again with required arguments
which are instances of the same classes.

@item
The generic procedure has not been reinitialized.

@item
No method has been added to or removed from the generic procedure.

@item
For all of the specializers of all the generic procedure's methods which
are classes, their class precedence lists have not changed.

@item
For any such memoized value, the class precedence list of the class of
each of the required arguments has not changed.
@end enumerate

Determination of the effective method procedure is done by calling
@code{compute-effective-method-procedure}.  When the effective method
procedure is run, the first applicable method's procedure is called.
The first argument to that procedure is a ``call-next-method''
procedure, and the remaining arguments are the arguments that were
received by the generic procedure.  If the first argument calls the
``call-next-method'' procedure, then the next method in the sequence of
applicable methods is invoked.  The arguments to the next method's
procedure are a ``call-next-method'' procedure, followed by the
arguments received by the first method's ``call-next-method'' procedure.
This process continues until there are no more applicable methods or
until one of the methods does not call its ``call-next-method''
procedure.

The generic procedure @code{compute-apply-generic} is called, and its
result installed, by @code{add-method}.

This procedure is similar to @code{compute-discriminating-function} in
@sc{clos}.
@end deffn

@deffn {Generic Procedure} compute-methods generic classes
@var{Classes} is a non-empty list of class objects.  This generic
procedure returns a list of method objects.

This generic procedure is called to determine the method applicability
of a generic procedure given only the classes of the required arguments.
This generic procedure returns that list as its value.  The returned list
of method objects is sorted by precedence order, the most specific
method coming first.  If no methods are applicable to arguments with the
specified classes, the empty list is returned.

The result of the generic procedure @code{compute-method-more-specific?}
is used to sort the returned list of methods.

When a generic procedure is invoked, the discriminating procedure must
determine the ordered list of methods applicable to its arguments.
Depending on the generic procedure and its arguments, this is done in
one of two ways: using a memoized value; or calling
@code{compute-methods}.  (Refer to the description of
@code{compute-apply-generic} for the details of this process.)

The list returned by this generic procedure will not be mutated by the
implementation.  The results are undefined if a program mutates the list
returned by this generic procedure.

The primary method of this generic procedure is specialized on
@code{<generic>}.  This method can be overridden.

@quotation
Remarks:  This generic procedure exists to allow user extensions which
alter method lookup rules, but which base the new rules only on the
classes of the required arguments, to take advantage of the class-based
method lookup memoization in the implementation.

To get appropriate performance, other kinds of extensions may require
methods on @code{compute-apply-generic} which implement their own
memoization scheme.
@end quotation

This procedure is similar to
@code{compute-applicable-methods-using-classes} in @sc{clos}.
@end deffn

@deffn {Generic Procedure} compute-method-more-specific? generic
This generic procedure computes and returns a procedure of three
arguments.

This generic procedure is called to determine a sorting predicate which
can be used by @code{compute-methods} to order a set of methods.  The
sorting predicate is a procedure of three arguments; the first two
arguments are the methods being compared, and the third argument is a
list of the classes of the required arguments to the generic procedure
whose methods are being sorted.  The result of the sorting predicate is
a true value if the first method is more specific than the second method
(given the required argument classes of the third argument); otherwise,
the result is @code{#f}.

The arguments passed to the sorting predicate must not be modified.

This generic procedure is called by @code{compute-methods}.
@end deffn

@deffn {Generic Procedure} compute-effective-method-procedure generic methods
@cindex effective method procedure
@var{Methods} must be a list of method objects.

This generic procedure is called to determine the effective method
procedure from a sorted list of method objects.

An effective method procedure is a procedure that describes how the
applicable methods are to be combined.  It is invoked with the arguments
passed to the generic procedure associated with @var{generic}, and
invokes the first applicable method with those arguments, preceded by a
``call-next-method'' argument, as described earlier for
@code{compute-apply-generic}.

This generic procedure can be called by the user or the implementation.
It is called by discriminating procedures whenever a sorted list of
applicable methods must be converted to an effective method procedure.

The primary method of this generic procedure is specialized on
@code{<generic>}.  This method can be overwritten.

This procedure is similar to @code{compute-effective-method} in
@sc{clos}.
@end deffn

@node Instantiation Subprotocol, Class Initialization Subprotocol, Generic Invocation Subprotocol, Meta-Object Protocol
@subsection The Instantiation Subprotocol

@deffn {Generic Procedure} allocate-instance class
Called by @code{make-instance} to allocate a new instance; should not be
called by applications.
@end deffn

@deffn {Generic Procedure} initialize-instance instance initarg @dots{}
Called by @code{make-instance} to initialize a newly allocated instance;
should not be called by applications.  @var{initarg}s are the
@var{initarg}s arguments that were passed to @code{make-instance}.  The
default method for this procedure accepts no @var{initarg}s; if you wish
to pass arguments to @code{make-instance} you must define a
corresponding method on @code{initialize-instance} to decipher the
meaning of those arguments.
@end deffn

@node Class Initialization Subprotocol,  , Instantiation Subprotocol, Meta-Object Protocol
@subsection The Class Initialization Subprotocol

@deffn {Generic Procedure} compute-precedence-list class
@end deffn

@deffn {Generic Procedure} compute-slots class
@end deffn

@deffn {Generic Procedure} compute-slot-descriptor class slots
@end deffn

@deffn Procedure make-slot name class allocation initializer plist
Creates and returns a new slot descriptor.  @var{Allocation} must be a
symbol.  @var{Initializer} must be @code{#f} or a procedure of no
arguments.  This should be called only by methods of
@code{compute-slot-descriptor}.
@end deffn

@deffn {Generic Procedure} compute-virtual-slot-accessors class slot
@end deffn

@node Miscellany,  , Meta-Object Protocol, Object System
@section Miscellany

@deffn {Generic Procedure} write-instance instance output-port
This is called by the default method on @code{unparse-instance} to
generate the printed representation of @var{instance}.  Users should
define methods on this procedure in preference to
@code{unparse-instance} since the former is not portable.
@end deffn

@deffn {Generic Procedure} unparse-instance instance state
This is called automatically by the unparser when it tries to print an
instance; it should not be called by applications.  @var{Instance} is
the instance to be printed, and @var{state} is an unparser-state object.

This generic procedure is only defined in the MIT Scheme implementation.
@end deffn

@deffn Procedure ppi object
``Pretty print'' @var{object}.  If @var{object} is an instance, the
slots of the instance are individually pretty printed.  Otherwise, the
procedure @code{pp} is called with @var{object} as its argument.

This procedure is a kludge that would not be needed if the pretty
printer had some kind of hook which would enable this behavior to be
specified.
@end deffn

@defvr Class <primitive-class>
@end defvr

@defvr Class <procedure-class>
@end defvr

@node Variable Index, Concept Index, Object System, Top
@unnumbered Variable Index
@printindex fn

@node Concept Index,  , Variable Index, Top
@unnumbered Concept Index
@printindex cp

@contents
@bye

@c Local Variables:
@c selective-display: t
@c truncate-lines: t
@c End:
