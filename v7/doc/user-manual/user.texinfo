\input texinfo @c -*-Texinfo-*-
@tex
\special{twoside}
@end tex
@c %**start of header
@setfilename user.info
@settitle MIT Scheme User's Manual
@c %**end of header
@setchapternewpage odd
@synindex vr fn


@ifinfo
This file documents the use of MIT Scheme.

Copyright @copyright{} 1991-1993 Massachusetts Institute of Technology

This material was developed by the Scheme project at the Massachusetts
Institute of Technology, Department of Electrical Engineering and Computer
Science.  Permission to copy this document, to redistribute it, and to use
it for any purpose is granted, subject to the following restrictions and
understandings.

@enumerate
@item
Any copy made of this document must include this copyright notice in
full.

@item
Users of this document agree to make their best efforts (a) to return to
the MIT Scheme project any improvements or extensions that they make, so
that these may be included in future releases; and (b) to inform MIT of
noteworthy uses of this document.

@item
All materials developed as a consequence of the use of this document shall
duly acknowledge such use, in accordance with the usual standards of
acknowledging credit in academic research.

@item
MIT has made no warrantee or representation that the contents of this
document will be error-free, and MIT is under no obligation to provide any
services, by way of maintenance, update, or otherwise.

@item
In conjunction with products arising from the use of this material, there
shall be no use of the name of the Massachusetts Institute of Technology
nor of any adaptation thereof in any advertising, promotional, or sales
literature without prior written consent from MIT in each case.
@end enumerate
@end ifinfo

@titlepage
@title{MIT Scheme User's Manual}
@subtitle Edition 0.9
@subtitle for Scheme Release 7.3
@subtitle DRAFT: @today{}
@author by Chris Hanson, Stephen Adams and others

@page

@vskip 0pt plus 1filll
Copyright @copyright{} 1991-1993 Massachusetts Institute of Technology

This material was developed by the Scheme project at the Massachusetts
Institute of Technology, Department of Electrical Engineering and Computer
Science.  Permission to copy this document, to redistribute it, and to use
it for any purpose is granted, subject to the following restrictions and
understandings.

@enumerate
@item
Any copy made of this document must include this copyright notice in
full.

@item
Users of this document agree to make their best efforts (a) to return to
the MIT Scheme project any improvements or extensions that they make, so
that these may be included in future releases; and (b) to inform MIT of
noteworthy uses of this document.

@item
All materials developed as a consequence of the use of this document shall
duly acknowledge such use, in accordance with the usual standards of
acknowledging credit in academic research.

@item
MIT has made no warrantee or representation that the contents of this
document will be error-free, and MIT is under no obligation to provide any
services, by way of maintenance, update, or otherwise.

@item
In conjunction with products arising from the use of this material, there
shall be no use of the name of the Massachusetts Institute of Technology
nor of any adaptation thereof in any advertising, promotional, or sales
literature without prior written consent from MIT in each case.
@end enumerate
@end titlepage

@node Top, Installation, (dir), (dir)

@menu
* Installation::                
* Running Scheme::              Running Scheme
* REPL::                        The Read-Eval-Print Loop
* Debugging::                   Debugging
* Loading Files::               Loading Files
* World Images::                World Images
* Compiling Files::             Compiling Files
* GNU Emacs Interface::         GNU Emacs Interface
* Edwin::                       Edwin
* Win32 Package Reference::     
* Variable Index::              Variable, Declaration, and Option Index
* Key Index::                   Key Index
* Concept Index::               Concept Index

--- The Detailed Node Listing ---

Running Scheme

 --- The Detailed Node Listing ---

Installation

* Generic Unix::                
* C-backend::                   
* Microsoft Windows and Windows NT installation::  

DOS, Microsoft Windows and Windows NT installation

* System requirements::         
* Manifest::                    
* Installation-win32::          Installation
* Known Problems::              

Running Scheme

* Basics of Starting Scheme::   Basics of Starting Scheme
* Customizing Scheme::          
* Command-Line Options::        Command-Line Options
* Environment Variables::       Environment Variables
* Starting Scheme from Microsoft Windows 3.1/NT::  
* Leaving Scheme::              Leaving Scheme

Environment Variables

* General Environment Variables::  
* Environment variables for Bchscheme::  
* Environment variables for PC versions::  
* Environment variables that affect the runtime system::  
* Environment variables that affect Edwin::  

The Read-Eval-Print Loop

* The Prompt and Level Number::  The Prompt and Level Number
* Interrupting::                Interrupting
* Proceeding::                  Proceeding
* The Current REPL Environment::  The Current REPL Environment

Debugging

* Subproblems and Reductions::  Subproblems and Reductions
* Debugger::                    The Debugger

Compiling Files

* Compilation Procedures::      Compilation Procedures
* Declarations::                Declarations

Declarations

* Standard Names::              Standard Names
* In-line Coding::              In-line Coding
* Operator Reduction::          Operator Reduction

Win32 Package Reference

* Overview::                    
* Foreign function interface::  
* Device Independent Bitmap Utilities::  

Foreign Function Interface

* Windows Types::               
* Windows Foreign Procedures::  
* Win32 API names and procedures::  

Device Independent Bitmap Utilities

* DIB procedures::              
* Other parts of the DIB Utilities implementation::  
@end menu

@node Installation, Running Scheme, Top, Top
@chapter Installation



@menu
* Generic Unix::                
* C-backend::                   
* Microsoft Windows and Windows NT installation::  
@end menu

@node Generic Unix, C-backend,  , Installation
@section Generic Unix

Installation information for Unix versions goes here.
(perhaps several a multitude of unixes?


@node C-backend, Microsoft Windows and Windows NT installation, Generic Unix, Installation
@section C-backend

Installation information for C back-end versions goes here?


@c NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
@node Microsoft Windows and Windows NT installation,  , C-backend, Installation
@section DOS, Microsoft Windows and Windows NT installation

This section describes how to install MIT Scheme on DOS, Microsoft
Windows 3.1 and Microsoft Windows NT.  We would prefer that the Windows
version is used to the DOS version because we intend to maintain this
version only so long as it is convienient.
We have only tested the DOS version on Microsoft DOS 5.0.
 For the most part the
installation any of these platforms uses the same files, and the
procedure is similar.  It is possible to install MIT Scheme so that it
will run under all three operating systems on one computer, but this
does require some care with the configuration of the system.

@menu
* System requirements::         
* Manifest::                    
* Installation-win32::          Installation
* Known Problems::              
@end menu

@node System requirements, Manifest,  , Microsoft Windows and Windows NT installation
@subsection System requirements

MIT Scheme requires at least a 386SX with 8Mb RAM.
The bare minimum
disk space required is 5.5Mb, which gives you a command line interface
for Scheme.  We strongly recommend a more advanced environment.  To
build the Edwin editor band requires an additional 4.3Mb.  The whole
installation without source code occupies 36Mb of disk.

@node Manifest, Installation-win32, System requirements, Microsoft Windows and Windows NT installation
@subsection Manifest

The installation comprises the following files:

@example
bin.zip         @r{Scheme binaries for Windows 3.1/Windows NT}
dosbin.zip      @r{Scheme binaries for PC-DOS}
lib.zip         @r{Smaller files from Scheme library}
runtime.zip     @r{@file{runtime.com} band}
runnoflo.zip    @r{@file{runtime.com} band for machines with no FP hardware}
eddel.zip       @r{@file{eddel.com}: a kit to build @file{edwin.com} band}
compedl.zip     @r{@file{compdel.com}: a kit to build @file{compiler.com} band}

bcirun1.zip     @r{Debugging information for runtime system}
bcirun2.zip     @r{    "          "       "     "      "}
bcirun3.zip     @r{    "          "       "     "      "}
bcied1.zip      @r{Debugging information for Edwin}
bcied2.zip      @r{    "          "       "    "}
bcied3.zip      @r{    "          "       "    "}
bcicomp1.zip    @r{Debugging information for compiler}
bcicomp2.zip    @r{    "          "       "      "}
bcicomp3.zip    @r{    "          "       "      "}

srcrun.zip      @r{Source code for the runtime system}
srcuc.zip       @r{Source code for the microcode (C)}
srced.zip       @r{Source code for Edwin}
srccomp.zip     @r{Source code for i386 compiler}

win32s.zip      @r{Win32s installation floppy from Microsoft}
install.txt     @r{These instructions}
unzip.exe       @r{Program to unpack the @file{.zip} files}
@end example


@node Installation-win32, Known Problems, Manifest, Microsoft Windows and Windows NT installation
@subsection Installation

These installation instructions describe how to install MIT Scheme on
one or more of PC-DOS, Microsoft Windows 3.1 and Microsoft Windows NT.
If you are installing for PC-DOS and another operating system, you
should do the bulk of the installation using the windowing environment.

In each of the following steps the amount of disk space consumed is
indicated in square brackets.
These sizes do not include the @file{.zip} files which are required
only during installation.

@enumerate
@item 
MIT Scheme under Windows 3.1 requires the Win32s system (version 1.1) to
be installed.  If you have not previously installed the Win32s system
then you should create a floppy disk containing the contents of the
@file{win32s.zip} file, e.g:

@example
a:
unzip @var{wherever}\win32s.zip   
@end example

Run the @file{setup} command on the floppy disk.

@noindent
If you are not sure whether you have Win32s installed, or what version
you have installed, try to install it anyway.  If you have version 1.0
then the Win32s installation disk will upgrade your Win32s system to
version 1.1.

@example
a:setup
@end example

@item
Decide on where to install MIT Scheme.
We suggest the default: @file{C:\SCHEME}.
Create the root directory which we from now on refer to as @var{scheme}.
If for example, you choose the default:

@example
mkdir c:\scheme
cd \scheme
@end example

@noindent
@var{scheme} is the string `@code{C:\scheme}'.

@item
In the @var{scheme} directory unzip the following essential files:
@file{bin.zip}, @file{lib.zip} and @file{runtime.zip} [5.5Mb].

@example
unzip @var{wherever}\bin.zip
unzip @var{wherever}\lib.zip
unzip @var{wherever}\runtime.zip
@end example

This will create the directory structures @file{@var{scheme}\bin},
@file{@var{scheme}\lib} and @file{@var{scheme}\etc}, and unpacks the
essential files.
(@var{Wherever} stands for the place that you have put the @file{.zip}
files, which might be another directory or a floppy disk.)

@noindent
If you have a computer without floating-point hardware (e.g. a 386
machine or a 486SX) and you wish to run the DOS version then you must
install the runtime with special floating point support instead of
@file{runtime.zip}:

@example
unzip @var{wherever}\runnoflo.zip
@end example

@item
To install the DOS binaries, unzip the @file{dosbin.zip} file.

@example
unzip @var{wherever}\dosbin.zip
@end example

This creates a @file{@var{scheme}\dos-bin} directory containing the DOS
versions of the @file{.exe} files.  These files are different to the
Windows versions, so they are placed in a different directory to allow
the different version to co-exist on your computer.  It is only the
@file{.exe} files that differ between DOS and Windows.  The other parts
of the MIT Scheme system are shared.  The DOS version will run under
Windows 3.1 but not under NT.  Either running on DOS or Windows 3.1, the
DOS version has @emph{no} graphics support

@item
If you are installing for Windows 3.1 only, do @emph{one} of the
following:
@itemize @bullet
@item
Put the following line in the @file{autoexec.bat} file to ensure that
the @file{@var{scheme}\bin\win31} directory is on the path:

@example
path %PATH%;@var{scheme}\bin\win31
@end example

@noindent
This command must be in a @file{.bat} file to work.
@item
Copy the files from @file{@var{scheme}\bin\win31} into
@file{@var{scheme}\bin}.
@end itemize

@item
If you are installing for Windows NT only, do @emph{one} of the
following:
@itemize @bullet
@item
As system
administrator add @file{@var{scheme}\bin\nt} to the @code{PATH} in the
system environment (using the Registry Editor, @code{regedt32})
@item
As an individual place @code{PATH=}@var{scheme}@code{\bin\nt} in your
environment (use the control panel's system option)
@item
Copy the files from @file{@var{scheme}\bin\nt} into
@file{@var{scheme}\bin}.
@end itemize

@item
If you are installing for both Windows 3.1 and Windows NT then you must
use use environment variables and the @code{PATH} rather than copying
files, i.e.  you must arrange for Windows 3.1 to be run with
@file{@var{scheme}\bin\win31} on the path and for Windows NT to be run
with @file{@var{scheme}\bin\nt} on the path.
This can be done by putting

@example
path %PATH%;@var{scheme}\bin\win31
@end example

in the @file{autoexec.bat} file and adding @file{@var{scheme}\bin\nt} to
the Windows NT system environment path.


@item
If you are installing for DOS there is no need to add things to the
@code{PATH}.

@item
If you did not choose the default installation directory, make sure that
the environment variable @code{MITSCHEME_LIBRARY_PATH} is defined:

@example
set MITSCHEME_LIBRARY_PATH=@var{scheme}\lib
@end example


@item
Now test the installation so far.
Under either Windows system, 
you should be able to get a Scheme system running in its terminal
window by running the following from the Program Manager or the File
Manager

@example
@var{scheme}\bin\scheme
@end example

From DOS you should be able to get Scheme running by typing the
following at the DOS prompt:

@example
@var{scheme}\dos-bin\scheme
@end example

@noindent
If there are any problems at this stage review the installation so far.
Remember that you might have to restart your machine to get the effect
of any changes that you made in @file{autoexec.bat} or the NT registry.

@item
Windows versions only.
Now you should create a Program Manager group for MIT Scheme.
This can be done by running a Scheme program from the Program Manager
using the @code{File|Run} option:

@example
@var{scheme}\bin\scheme -load @var{scheme}\etc\pmgrp
@end example

@noindent
This program creates a program group called `MIT Scheme' which contains
@itemize @bullet
@item
Icons for running scheme in several configurations
@item
Windows Help versions of the Scheme Reference Manual and the MIT Scheme
User's Manual.
@item
`Mincer' icons for building the rest of the system
@end itemize

@noindent
At this point only the Scheme icon called `Runtime' will execute.
Test it.  The other Scheme icons (`Edwin', `Compiler' and `MIT Scheme'
shield) should report that they cannot find their bands.


@item
To install the Edwin editor you need to build the @file{edwin.com} band.
First unpack the delta file @file{eddel.com} [1.6Mb]:

@example
cd @var{scheme}
unzip @var{wherever}\eddel.zip
@end example

To build @file{edwin.com} start the `build EDWIN.COM band' icon, or run
the following command:

@example
@var{scheme}\bin\scheme -large -load @var{scheme}\etc\build -eval (edwin.com)
@end example

@noindent
This will load in @file{eddel.com} and create the new band [4.3Mb].
After a successful build the program will exit.
The @file{edwin.com} band can be used by both the DOS and Windows
versions, so you only need to do this step once, even if you are
installing for more than one of DOS, Windows 3.1 and Windows NT.

If you are installing only for DOS you will have to build
@file{edwin.com} from the command line.  Be sure to run the DOS
@file{scheme.exe} rather than the Windows version:

@example
@var{scheme}\dos-bin\scheme -large -load @var{scheme}\etc\build -eval (edwin.com)
@end example


@item
To install the compiler you need to build the @file{compiler.com} band.
First unpack the @file{compdel.com} delta file [2.5Mb]:

@example
cd @var{scheme}
unzip @var{wherever}\compdel.zip
@end example

To build @file{compiler.com} start the `build COMPILER.COM band' icon,
or run the following command:

@example
@var{scheme}\bin\scheme -large -load @var{scheme}\etc\build -eval (compiler.com)
@end example

@noindent
This will load in @file{compdel.com} and create the new
@file{compiler.com} band [4.8Mb].  After a successful build the program
will exit.
As for Edwin, this step needs to be done only once.

If you choose to build this band under using the DOS version be sure to
run the DOS @file{scheme.exe} rather than the Windows version:

@example
@var{scheme}\dos-bin\scheme -large -load @var{scheme}\etc\build -eval (compiler.com)
@end example


@item
If you want both Edwin and the compiler in one band you should build the
@file{all.com} band.  First unpack the delta files [4.1Mb unless already
unpacked in previous steps]:

@example
cd @var{scheme}
unzip @var{wherever}\eddel.zip
unzip @var{wherever}\compdel.zip
@end example

To build @file{all.com} start the `build ALL.COM band' icon, or run the
following command:

@example
@var{scheme}\bin\scheme -large -load @var{scheme}\etc\build -eval (all.com)
@end example

@noindent
This will load in both @file{eddel.com} and @file{compdel.com} into the
runtime band and create the new band [6.7Mb].  After a successful build
the program will exit.

If you choose to build this band under DOS, be sure to run the DOS
@file{scheme.exe} rather than the Windows version:

@example
@var{scheme}\dos-bin\scheme -large -load @var{scheme}\etc\build -eval (all.com)
@end example


@item
Any combination of @file{edwin.com}, @file{compiler.com} and
@file{all.com} may be used.  They may be built in any order: it is not
necessary to build either of @file{edwin.com} and @file{compiler.com}
before building and using @file{all.com}.
The bands are shared by all of the supported operating systems so you
only have to build the bands once, even if you want to use them from,
say, both DOS and Windows 3.1

After building the bands you may tidy the MIT Scheme group by removing
the mincer icons and recover disk space by deleting the delta files
[4.1Mb] and the @file{runtime.com} band [2.3Mb] if you do not need it.

To create icons that use @code{bchscheme} instead of @code{scheme} copy
the icons and edit the command lines to change `scheme' to `bchschem'
(that is right: no tailing `e').

@item
Debugging information can be installed by uncompressing the
@file{bci*.zip} files in the Scheme root directory @var{scheme}.  The
total space required for all of the debugging information is 11.3Mb.
The most useful is the runtime debugging info which is in
@file{bcirun1.zip} through @file{bcirun3.zip} [3.6Mb installed].

Debugging information files can be installed in the Scheme root
directory or in another directory.  If another directory is chosen then
set the @code{MITSCHEME_INF_DIRECTORY} environment variable to this
directory.  @file{bcied1.zip} through @file{bcied3.zip} [3.8Mb
installed] and @file{bcicomp1.zip} through @file{bcicomp3.zip} [4Mb
installed] hold the debugging information files for Edwin and the
compiler respectively.

@end enumerate



@node Known Problems,  , Installation-win32, Microsoft Windows and Windows NT installation
@subsection Known Problems in this Beta Release

@itemize @bullet

@item
The Windows version of MIT Scheme is more robust under NT than Windows
3.1

@item
[NT] Exclusive file access problems.
Edwin sometimes can't write a file that is still open for reading.

Typically you will have entered @code{(load "foo.scm")} in the
interaction buffer and got an error, say a mis-matched parenthesis.
You then switch to the @code{foo.scm} buffer, fix the problem and then
try to save the file.
Edwin refuses, saying

@example
Unable to open file "@var{your-path}\\foo.scm" because: Unknown
@end example

Work-around: In the interaction buffer: Quit to top level.  Do a
@code{(gc-flip)}, which forces the file to be closed when the file port
is garbage-collected.  Now you will be able to save the file.

@item
@code{MITSCHEME_INF_DIRECTORY} sometimes does not work.
The runtime system cannot find the debugging information unless it is on
the @file{C:} drive.
To test if the debugging information is available, try

@example
(pp pp)
@end example

If the debugging information is available the @code{pp} procedure
pretty-prints procedures as Scheme code.
If the information cannot be found then it prints the procedure as an
opaque object, similar to this:

@example
#[compiled-procedure 13 (pp "pp" #x2) #xF #x646BF7]
@end example

@item
Edwin autoloads.
A few files that are automatically part of Edwin under unix are not part
of Edwin in the PC.  These can be loaded manually from the auto-load
directory, for example, by putting

@example
(edwin-load "dabbrev")
@end example

@noindent
in your @file{edwin.ini} file.


@end itemize



@c @node
@c @subsection NT build
@c 
@c 
@c @table @asis
@c @item Build
@c The Windows/NT version can be built only under Windows NT.
@c 
@c @item no TOUCH command
@c Create the following 1 line script in @file{TOUCH.BAT}:
@c 
@c @example
@c echo on > %1
@c @end example
@c 
@c @item can't find @file{w32sut.h}
@c These files are a part of Win32S: @file{w32sut.h}, @file{?.dll}, @file{?.dll}
@c You need to copy @file{w32sut.h} from 
@c @end table
@c 
@c 
@c w32sut.h & dlls to ntutl/config?

@c NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN





@node Running Scheme, REPL, Installation, Top
@chapter Running Scheme

This chapter describes how to run MIT Scheme on a unix system or a PC
running DOS, Microsoft Windows 3.1, or Microsoft Windows NT.
It also describes how you can customize the behavior of MIT Scheme
using command-line options and environment variables.

@menu
* Basics of Starting Scheme::   Basics of Starting Scheme
* Customizing Scheme::          
* Command-Line Options::        Command-Line Options
* Environment Variables::       Environment Variables
* Starting Scheme from Microsoft Windows 3.1/NT::  
* Leaving Scheme::              Leaving Scheme
@end menu

@node Basics of Starting Scheme, Customizing Scheme,  , Running Scheme
@section Basics of Starting Scheme

Usually, MIT Scheme is invoked by typing

@example
scheme
@end example

@noindent
at your operating system's command interpreter. (Under Microsoft Windows
3.1 you must use the Program Manager's @var{Run} command, or an icon.)
Scheme will load itself, clear the screen, and print something like
this:

@example
Scheme saved on Monday December 10, 1990 at 9:55:37 PM
  Release 7.3.0 (beta)
  Microcode 11.146
  Runtime 14.164
@end example

@noindent
This information, which can be printed again by evaluating

@findex identify-world
@lisp
(identify-world)
@end lisp

@cindex release number
@cindex microcode, version
@cindex runtime system, version
@cindex version numbers
@noindent
tells you the following version information.  ``Release'' is the release
number for the entire Scheme system.  This number is changed each time a
new version of Scheme is released.  An ``(alpha)'' or ``(beta)''
following the release number indicates that this is a alpha- or
beta-test release.  ``Microcode'' is the version number for the part of
the system that is written in C.  ``Runtime'' is the version number for
the part of the system that is written in Scheme.

@cindex subsystem versions
@cindex SF, version
@cindex compiler, version
@cindex Edwin, version
@cindex student package, version
@cindex compatibility package, version
Following this there may be additional version numbers for specific
subsystems.  @samp{SF} refers to the scode optimization program
@code{sf}, @samp{Liar} is the native-code compiler, 
@samp{Edwin} is the Emacs-like text editor,
and @samp{Student} is the S&ICP compatibility package.

@cindex compiler, starting
If the compiler is supported for your machine, you can invoke it by
giving Scheme the @samp{-compiler} option:

@example
scheme -compiler
@end example

@noindent
This option causes Scheme to use a larger constant space and heap, and
to load the world image containing the compiler.


@node Customizing Scheme, Command-Line Options, Basics of Starting Scheme, Running Scheme
@section Customizing Scheme

You can customize your setup by using a variety of tools:

@itemize @bullet
@item
@cindex command line options
@dfn{Command-line options}.
Many parameters, like memory usage and the location of libraries, may be
varied by command line options.

@item
@dfn{Command scripts or batch files}.
@cindex command scripts
You might like to write scripts that invoke Scheme with your favourite
command line options.  For example, under DOS you might not have enough
memory to run edwin or the compiler with its default memory parameters
(it will print something like ``Not enough memory for this
configuration'' and halt when started), you can write a shell script
(unix) or a @file{.bat} file (PC) that will invoke Scheme with the
appropriate "@code{-heap}" and other parameters.

@item
@cindex init file
Scheme supports @dfn{init files}: if the file @file{.scheme.init} exists
in your home directory, it is loaded immediately after the
identification banner, and before the input prompt is printed.
In addition, when it starts up, edwin loads the file @file{.edwin} from
your home directory into the edwin environment. You can use both of
these files to define new procedures, commands, or change defaults in
the system.

The @code{-no-init-file} command
line option causes Scheme to ignore the @file{.scheme.init} file (see
@xref{Command-Line Options}).

On PC systems these initialization files are called @file{scheme.ini}
and @file{edwin.ini} respectively and are searched for in the directory
identified by the @code{HOME} environment variable.

@item
@dfn{Environment variables}. Most microcode parameters, and some runtime
system and Edwin parameters, can be specified by means of
environment variables.
See @xref{Environment Variables}.

@item
@dfn{Icons}.
@cindex icons
Under Microsoft Windows and Windows NT it is possible to create icons in
the Program Manager that invoke Scheme with different parameters.
@end itemize


One of the important parameters that can be customized is how much
memory Scheme uses and how that memory is used.  Scheme uses four kinds
of memory:
@cindex memory
@cindex heap space
@cindex stack space
@cindex constant space

@itemize @bullet
@item
A @dfn{stack} which is used for recursive procedure calls,
@item
A @dfn{heap} which is used for dynamically allocated objects, like @samp{cons}
cells and strings.
Storage used for objects in the heap which become unreferenced is
eventually reclaimed by @dfn{garbage collection}.
@item
A @dfn{constant space}, which is used for allocated objects, like the
heap.
Unlike the heap, storage used for objects in constant space is not
reclaimed by garbage collection.
Constant space is used for objects that are essentially permanent, like
procedures from the runtime system.
@item
An amount of extra storage which is used by the Microcode (the part
of the system that is implemented in C).
@end itemize

@findex bchscheme
All aspects except the last may be controlled both by command-line
options and by environment variables.  MIT Scheme uses a two-space
copying garbage collector for reclaiming storage in the heap.  There are
two version of Scheme which handle garbage collection differently.
Ordinary @code{scheme} has two heaps, one for each `space'.
@code{bchscheme} has one heap and uses a disk file for the other
`space', thus trading memory usage against garbage collection speed.

The total storage required by @code{scheme} is:

@example
@var{stack} + (@var{constant} + 2*@var{heap}) + @var{extra}
@end example

@noindent
where @var{stack}, @var{constant} and @var{heap} are parameters that may
be selected when @samp{scheme} starts.
For @code{bchscheme}, which has only one heap in memory, the equation is

@example
@var{stack} + (@var{constant} + @var{heap}) + @var{extra}
@end example

Once the storage is allocated for the constant space and the heap,
Scheme will dynamically adjust the proportion of the total that is used
for constant space.
The stack and the extra microcode storage is not included in this adjustment.
The dynamic adjustment of the heap and constant space avoids the problem
with previous versions of MIT Scheme of having to know the amount of
constant space that is required when loading your own bands with the
@code{-band} option.  Now all that is required is that the total space
is sufficient.
The Scheme procedure @code{(print-gc-statistics)} shows how much heap
and constant space is available.


@node Command-Line Options, Environment Variables, Customizing Scheme, Running Scheme
@section Command-Line Options

Scheme accepts the command-line options detailed in the following
sections.  The options may appear in any order, with the restriction
that the microcode options must appear before the runtime options, and
the runtime options must appear before any other arguments on the
command line.
(At present, any arguments other than these options will generate a
warning message when Scheme starts.  In the future, there will be an
advertised mechanism by which the extra arguments can be handled by user
code.)


These are the microcode options:

@table @code

@item -band @var{filename}
@findex -band
@findex MITSCHEME_BAND
@cindex world image
@cindex band
Specifies the initial world image file (@dfn{band}) to be loaded.
Searches for @var{filename} in the working directory and the library
directories, using the full pathname of the first readable file of that
name.  If @var{filename} is an absolute pathname (on unix, this means it
starts with @samp{/}), then no search occurs --- @var{filename} is
tested for readability and then used directly.  If this option isn't
given, the filename is the value of the environment variable
@code{MITSCHEME_BAND}, or if that isn't defined, @file{runtime.com}; in
these cases the library directories are searched, but not the working
directory.

@item -compiler
@findex -compiler
@findex MITSCHEME_COMPILER_BAND
This option specifies defaults appropriate for loading the compiler.  It
specifies the use of large sizes, exactly like @code{-large}.  If the
@code{-band} option is also specified, that is the only effect of this
option.  Otherwise, the default band's filename is the value of the
environment variable @code{MITSCHEME_COMPILER_BAND}, if defined, or
@file{compiler.com}; the library directories are searched to locate this
file.  Note that the @code{-compiler} option is available only on
machines with compiled-code support.

@item -edwin
@findex -edwin
@findex MITSCHEME_EDWIN_BAND
This option specifies defaults appropriate for loading the editor.  It
specifies the use of large sizes, exactly like @code{-large}.  If the
@code{-band} option is also specified, that is the only effect of this
option.  Otherwise, the default band's filename is the value of the
environment variable @code{MITSCHEME_EDWIN_BAND}, if defined, or
@file{edwin.com}; the library directories are searched to locate this
file.  Note that the @code{-edwin} option is available only on machines
with compiled-code support.

@item -large
@findex -large
Specifies that large heap, constant, and stack sizes should be used.
These are specified by the environment variables

@findex MITSCHEME_LARGE_HEAP
@findex MITSCHEME_LARGE_CONSTANT
@findex MITSCHEME_LARGE_STACK
@example
MITSCHEME_LARGE_HEAP
MITSCHEME_LARGE_CONSTANT
MITSCHEME_LARGE_STACK
@end example

@noindent
If this option isn't given, the small sizes are used, specified by the
environment variables

@findex MITSCHEME_SMALL_HEAP
@findex MITSCHEME_SMALL_CONSTANT
@findex MITSCHEME_SMALL_STACK
@example
MITSCHEME_SMALL_HEAP
MITSCHEME_SMALL_CONSTANT
MITSCHEME_SMALL_STACK
@end example

@noindent
There are reasonable built-in defaults for all of these environment
variables, should any of them be undefined.  Note that any or all of the
defaults can be individually overridden by the @code{-heap},
@code{-constant}, and @code{-stack} options.

@findex print-gc-statistics
Note: the Scheme procedure @code{(print-gc-statistics)} shows how much
heap and constant space is available and in use.

@item -heap @var{blocks}
@findex -heap
Specifies the size of the heap in 1024-word blocks.  Overrides any
default.  Normally two such heaps are allocated; @code{bchscheme}
allocates only one, and uses a disk file for the other.

@item -constant @var{blocks}
@findex -constant
Specifies the size of constant space in 1024-word blocks.  Overrides any
default.  Constant space holds the compiled code for the runtime system
and other subsystems.

@item -stack @var{blocks}
@findex -stack
Specifies the size of the stack in 1024-word blocks.  Overrides any
default.  This is Scheme's stack, @emph{not} the unix stack used by C
programs.

@item -option-summary
@findex -option-summary
Causes Scheme to write an option summary to standard error.  This shows
the values of all of the settable microcode option variables.

@item -emacs
@findex -emacs
Specifies that Scheme is running as a subprocess of GNU Emacs.  This
option is automatically supplied by GNU Emacs, and should not be given
under other circumstances.

@item -interactive
@findex -interactive
If this option isn't specified, and Scheme's standard @sc{i/o} is not a
terminal, Scheme will detach itself from its controlling terminal.  This
will prevent it from getting signals sent to the process group of that
terminal.  If this option is specified, Scheme will not detach itself
from the controlling terminal.

This detaching behavior is useful for running Scheme as a background
job.  For example, using the C shell in unix, the following will run
Scheme as a background job, redirecting its input and output to files,
and preventing it from being killed by keyboard interrupts or by logging
out:

@example
scheme < /usr/cph/foo.in >& /usr/cph/foo.out &
@end example

This option only makes sense under unix.

@item -nocore
@findex -nocore
Specifies that Scheme should not generate a core dump under any
circumstances.  Under unix, if this option is not given, and Scheme
terminates abnormally, you will be prompted to decide whether a core
dump should be generated.
This option is ignored on PC versions.

@item -library @var{path}
@findex -library
@findex MITSCHEME_LIBRARY_PATH
Sets the library search path to @var{path}.  This is a colon-separated
list of directories that is searched to find various library files, such
as bands.  If this option is not given, the value of the environment
variable @code{MITSCHEME_LIBRARY_PATH} is used; if that isn't defined,
the default is used (@file{/usr/local/lib/mit-scheme} on Unix, @file{c:\scheme}
on PCs).

@item -utabmd @var{filename}
@item -utab @var{filename}
@findex -utabmd
@findex -utab
@findex MITSCHEME_UTABMD_FILE
Specifies that @var{filename} contains the microcode tables (the
microcode tables are information that informs the runtime system about
the microcode's structure).  @var{Filename} is searched for in the
working directory and the library directories.  If this option isn't
given, the filename is the value of the environment variable
@code{MITSCHEME_UTABMD_FILE}, or if that isn't defined,
@file{utabmd.bin}; in these cases the library directories are searched,
but not the working directory.

@code{-utab} is an alternate name for the @code{-utabmd} option.  At
most one of these options may be given.

@item -fasl @var{filename}
@findex -fasl
Specifies that a @dfn{cold load} should be performed, using
@var{filename} as the initial file to be loaded.  If this option isn't
given, a normal load is performed instead.  This option may not be used
together with the @code{-band} option.  This option is useful only for
maintainance and development of the MIT Scheme runtime system.

@end table


@noindent
The following options are runtime options.
They are processed after the microcode options and after runtime, Edwin
or other band is loaded.

@table @code
@item -no-init-file
@findex -no-init-file
This option causes Scheme to ignore the @file{~/.scheme.init} or
@file{scheme.ini} file, normally loaded automatically when Scheme starts
(if it exists).

@item -eval
@findex -eval
This option causes Scheme to evaluate the expressions following it on
the command line, up to (but not including) the next option that starts
with a hyphen.  The expressions are evaluated in the
@code{user-initial-environment}.
Unless explicitly handled, errors during evaluation are silently ignored.

@item -load
@findex -load
This option causes Scheme to load the files (or lists of files)
following it on the command line, up to (but not including) the next
option that starts with a hyphen.  The files are loaded in the
@code{user-initial-environment} using the default syntax table.
Unless explicitly handled, errors during loading are silently ignored.
@end table

@noindent
In addition to the above, @code{bchscheme} recognises the following
command line options, all of which specify parameters affecting how
@code{bchscheme} uses disk storage to do garbage collection:

@table @code
@item -gc-directory @var{directory}
@findex -gc-directory
@findex MITSCHEME_GC_DIRECTORY
Specifies that @var{directory} should be used to create files for
garbage collection.  If the option is not given, the value of
environment variable @code{MITSCHEME_GC_DIRECTORY} is used instead, and
if that is not defined, @file{/tmp} is used.

@item -gc-end-position @var{number}
@findex -gc-end-position
@findex MITSCHEME_GC_END_POSITION
It specifies the last byte position in @code{-gc-file} at which this
invocation of scheme can write.  If the option is not given, the value
of environment variable @code{MITSCHEME_GC_END_POSITION} is used
instead, and if that is not defined, it is computed from the start
position (as provided with -gc-start-position) and the heap size.  The
area of the file used (and locked if possible) is the region between
@code{-gc-start-position} and @code{-gc-end-position}.


@item -gc-file @var{filename}
@itemx -gcfile @var{filename}
@findex -gc-file
@findex -gcfile
@findex MITSCHEME_GC_FILE
Specifies that @var{filename} should be used for garbage collection.  If
the option is not given, the value of environment variable
@code{MITSCHEME_GC_FILE} is used, and if this is not defined, a unique
filename is generated in the directory specified with
@code{-gc-directory}.

@code{-gcfile} is an alias for @code{-gc-file}.  At most one of these
options should be specified.


@item -gc-keep
@findex -gc-keep
Specifies that the gc file used for garbage collection should not be
deleted when scheme terminates.
The gc file is deleted only if the file was created
by this invocation of scheme, and this option is not set.

@item -gc-start-position @var{number}
@findex -gc-start-position
@findex MITSCHEME_GC_START_POSITION
It specifies the first byte position in @code{-gc-file} at which this
invocation of scheme can write.  If the option is not given, the value
of environment variable @code{MITSCHEME_GC_START_POSITION} is used
instead, and if that is not defined, 0 is used, meaning the beginning of
the file.  The area of the file used (and locked if possible) is the
region between @code{-gc-start-position} and @code{-gc-end-position}.

@item -gc-window-size @var{blocks}
@findex -gc-window-size
@findex MITSCHEME_GC_WINDOW_SIZE
Specifies the size of the windows into new space during garbage
collection.  If this option is not given, the value of environment
variable @code{MITSCHEME_GC_WINDOW_SIZE} is used instead, and if that is
not defined, the value 16 is used.
@end table

@noindent
The following command line options are only used by an experimental
version of @code{bchscheme} that uses Unix System V-style shared memory,
and only then if the @code{gcdrone} program is installed in the lib
directory.

@table @code
@item -gc-drone @var{program}
@findex -gc-drone
@findex MITSCHEME_GC_DRONE
Specifies that @var{program} should be used as the drone program for
overlapped I/O during garbage collection.  This option is recognized
only by @code{bchscheme}.  If the option is not given, the value of
environment variable @code{MITSCHEME_GC_DRONE} is used instead, and if
that is not defined, @file{gcdrone} is used.

@item -gc-read-overlap @var{N}
@findex -gc-read-overlap
@findex MITSCHEME_GC_READ_OVERLAP
Specifies that scheme should delegate at most @var{N} simultaneous disk
read operations during garbage collection.  This option is recognized
only by @code{bchscheme}.  If the option is not given, the value of
environment variable @code{MITSCHEME_GC_READ_OVERLAP} is used instead,
and if that is not defined, 0 is used, disabling overlapped reads.

@item -gc-write-overlap @var{N}
@findex -gc-write-overlap
@findex MITSCHEME_GC_WRITE_OVERLAP
Specifies that scheme should delegate at most @var{N} simultaneous disk
write operations during garbage collection.  This option is recognized
only by @code{bchscheme}.  If the option is not given, the value of
environment variable @code{MITSCHEME_GC_WRITE_OVERLAP} is used instead,
and if that is not defined, 0 is used, disabling overlapped writes.
@end table

@node Environment Variables, Starting Scheme from Microsoft Windows 3.1/NT, Command-Line Options, Running Scheme
@section Environment Variables


There are many environment variables that Scheme (and Edwin, etc.) look
for.  Environment variables that affect the microcode must be defined
before you start Scheme, but others can be defined or overwritten within
Scheme by using the @code{set-environment-variable!} procedure, e.g.

@example
  (set-environment-variable! "EDWIN_FOREGROUND" "32")
@end example

The rest of this section is a summary of the environment variables that
are specific to MIT Scheme.  The environment variables are organised
according to the parts of MIT Scheme that they affect.

@menu
* General Environment Variables::  
* Environment variables for Bchscheme::  
* Environment variables for PC versions::  
* Environment variables that affect the runtime system::  
* Environment variables that affect Edwin::  
@end menu

@node
@subsection Environment Variables that affect the Microcode

@table @asis

@item @code{MITSCHEME_BAND} (default: @file{runtime.com} on the library path)
@findex MITSCHEME_BAND
The initial band to be loaded.  Overridden by @code{-band},
@code{-compiler}, or @code{-edwin}.

@item @code{MITSCHEME_COMPILER_BAND} (default: @file{compiler.com} on the library path)
@findex MITSCHEME_COMPILER_BAND
The initial band to be loaded if the @code{-compiler} option is given.
Overridden by @code{-band}.

@item @code{MITSCHEME_EDWIN_BAND} (default: @file{edwin.com} on the library path)
@findex MITSCHEME_EDWIN_BAND
The initial band to be loaded if the @code{-edwin} option is given.
Overridden by @code{-band}.

@item @code{MITSCHEME_LARGE_CONSTANT} (default: @samp{1000})
@findex MITSCHEME_LARGE_CONSTANT
The size of constant space, in 1024-word blocks, if the @code{-large},
@code{-compiler}, or @code{-edwin} options are given.  Overridden by
@code{-constant}.  Note: default is somewhat larger on RISC machines.

@item @code{MITSCHEME_LARGE_HEAP} (default: @samp{1000})
@findex MITSCHEME_LARGE_HEAP
The size of the heap, in 1024-word blocks, if the @code{-large},
@code{-compiler}, or @code{-edwin} options are given.  Overridden by
@code{-heap}.

@item @code{MITSCHEME_LARGE_STACK} (default: @samp{100})
@findex MITSCHEME_LARGE_STACK
The size of the stack, in 1024-word blocks, if the @code{-large},
@code{-compiler}, or @code{-edwin} options are given.  Overridden by
@code{-stack}.

@item @code{MITSCHEME_LIBRARY_PATH}
@findex MITSCHEME_LIBRARY_PATH
A list of directories.  These directories are searched,
left to right, to find bands and various other files.
On Unix systems the list is colon separated, with the default
@file{/usr/local/lib/mit-scheme}.
On PC systems the list is semi-colon separated with the default
@file{c:\scheme\lib}


@item @code{MITSCHEME_INF_DIRECTORY}
Directory containing the debugging information files for the system. It
should contain subdirectories corresponding to the subdirectories in the
source tree.  For example, if its value is @file{f:\random}, then runtime system
debugging files will be expected in @file{f:\random\runtime}, while edwin
debugging files will be expected in @file{f:\random\edwin}

@item @code{MITSCHEME_SMALL_CONSTANT} (default: @samp{400})
@findex MITSCHEME_SMALL_CONSTANT
The size of constant space, in 1024-word blocks, if the size options are
not given.  Overridden by @code{-constant}, @code{-large},
@code{-compiler}, or @code{-edwin}.  Note: default is somewhat larger on
RISC machines.

@item @code{MITSCHEME_SMALL_HEAP} (default: @samp{250})
@findex MITSCHEME_SMALL_HEAP
The size of the heap, in 1024-word blocks, if the size options are not
given.  Overridden by @code{-heap}, @code{-large}, @code{-compiler}, or
@code{-edwin}.

@item @code{MITSCHEME_SMALL_STACK} (default: @samp{100})
@findex MITSCHEME_SMALL_STACK
The size of the stack, in 1024-word blocks, if the size options are not
given.  Overridden by @code{-stack}, @code{-large}, @code{-compiler}, or
@code{-edwin}.

@item @code{MITSCHEME_UTABMD_FILE} (default: @file{utabmd.bin} in the library path)
@findex MITSCHEME_UTABMD_FILE
The file containing the microcode tables.  Overridden by @code{-utabmd}
and @code{-utab}.  It is only necessary when re-building
@file{runtime.com}.

@end table

@node Environment variables for Bchscheme, Environment variables for PC versions, General Environment Variables, Environment Variables
@subsection Environment variables for Bchscheme

@table @asis

@item @code{MITSCHEME_GC_DIRECTORY} (default: @file{/tmp})
@findex MITSCHEME_GC_DIRECTORY
The directory where to write gc files.  Overriden by @code{-gc-directory}.

@item @code{MITSCHEME_GC_END_POSITION} (default: start-position + heap-size)
@findex MITSCHEME_GC_END_POSITION
The last position in the gc file to use.  Overriden by
@code{-gc-end-position}.

@item @code{MITSCHEME_GC_FILE} (default: @file{GCXXXXXX})
@findex MITSCHEME_GC_FILE
The name of the file to use for garbage collection.  If it ends in 6 Xs,
the Xs are replaced by a letter and process id of the scheme process,
thus generating a unique name.  Overriden by @code{-gc-file}.

@item @code{MITSCHEME_GC_START_POSITION} (default: 0)
@findex MITSCHEME_GC_START_POSITION
The first position in the gc file to use.  Overriden by
@code{-gc-start-position}.

@item @code{MITSCHEME_GC_WINDOW_SIZE} (default: 16)
@findex MITSCHEME_GC_WINDOW_SIZE
The size in blocks of windows into new space (in the gc file).
Overriden by @code{-gc-window-size}.
@end table

@noindent
The following environment variables are only used by an experimental
version of Bchscheme that uses Unix System V-style shared memory, and
only then if the @code{gcdrone} program is installed:

@table @asis
@item @code{MITSCHEME_GC_DRONE} (default: @file{gcdrone})
@findex MITSCHEME_GC_DRONE
The program to use as the I/O drone during garbage collection.
Overriden by @code{-gc-drone}.

@item @code{MITSCHEME_GC_READ_OVERLAP} (default: 0)
@findex MITSCHEME_GC_READ_OVERLAP
The maximum number of simultaneous read operations.  Overriden by
@code{-gc-read-overlap}.

@item @code{MITSCHEME_GC_WRITE_OVERLAP} (default: 0)
@findex MITSCHEME_GC_WRITE_OVERLAP
The maximum number of simultaneous write operations.  Overriden by
@code{-gc-write-overlap}.
@end table

@node Environment variables for PC versions, Environment variables that affect the runtime system, Environment variables for Bchscheme, Environment Variables
@subsection Environment variables for PC versions

These environment variables only make sense to the Microsoft Windows,
Windows NT or MS-DOS versions of MIT Scheme.

@table @asis
@item @code{MITSCHEME_DPMI_EXT_KBD} (default: @samp{false})
@findex MITSCHEME_DPMI_EXT_KBD
DOS version only.
Boolean option specifying whether Scheme inserts its own keyboard handling
routine when running under DPMI (DOS Protected Mode Interface) or Windows.

@item @code{MITSCHEME_X32_EXT_KBD} (default: @samp{false})
@findex MITSCHEME_X32_EXT_KBD
DOS version only.
Boolean option specifying whether Scheme inserts its own keyboard handling
routine when @emph{not} running under DPMI or Windows.

@item @code{MITSCHEME_TRAP_ALT_TAB} (default: @samp{false})
@findex MITSCHEME_TRAP_ALT_TAB
@item @code{MITSCHEME_TRAP_ALT_ESCAPE} (default: @samp{false})
@findex MITSCHEME_TRAP_ALT_ESCAPE
Microsoft Windows and Windows NT only.
Boolean option specifying the handling of system command accelerators.
These options do not actually work.

@item @code{MITSCHEME_GEOMETRY} (default: @samp{-1,-1,-1,-1})
@findex MITSCHEME_GEOMETRY
Microsoft Windows and Windows NT only.  Four integers separated by
commas or spaces that specify the placement and size of the MIT Scheme
window as a @var{left,top,width,height} quadruple.  The units are screen
pixels, and @samp{-1} means allow the system to choose this parameter.
E.g.  @samp{-1,-1,500,300} places a 500 by 300 pixel window at some
system determined position on the screen.  The width and height include
the window border and title.

@item @code{MITSCHEME_FOREGROUND} (default: according to desktop color scheme)
@findex MITSCHEME_FOREGROUND
Microsoft Windows and Windows NT only.  An value specifying the window
text color.  The color is specified as hex blue, green and red values
(@emph{not} RGB):, E.g. @code{0xff0000} for blue.

@item @code{MITSCHEME_BACKGROUND} (default: according to desktop color scheme)
@findex MITSCHEME_BACKGROUND
Microsoft Windows and Windows NT only.  A value specifying the window
background color.  See @code{MITSCHEME_FOREGROUND}.

@end table

@node Environment variables that affect the runtime system, Environment variables that affect Edwin, Environment variables for PC versions, Environment Variables
@subsection Environment variables that affect the runtime system


@table @asis
@item @code{HOME}
@findex HOME
Directory where to look for init files.  E.g. @samp{c:\users\joe} or
@samp{/homes/joe}

@item @code{TEMP}, @code{TMP}
@findex TMP
@findex TEMP
Directory for various temporary files.  @code{TEMP} is given preference
to @code{TMP}.

@end table

@node Environment variables that affect Edwin,  , Environment variables that affect the runtime system, Environment Variables
@subsection Environment variables that affect Edwin

@table @asis
@item @code{EDWIN_BINARY_DIRECTORY} (default: @file{edwin/autoload} on the library path)
@findex EDWIN_BINARY_DIRECTORY
Directory where edwin expects to find files providing autoloaded
facilities.

@item @code{EDWIN_INFO_DIRECTORY} (default: @file{edwin/info} on the library path)
@findex EDWIN_INFO_DIRECTORY
Directory where edwin expects to find files for the `info' documentation
subsystem.

@item @code{EDWIN_ETC_DIRECTORY} (default: @file{edwin/etc} on the library path)
@findex EDWIN_ETC_DIRECTORY
Directory where edwin expects to find utility programs and documentation
strings.

@item @code{EDWIN_FOREGROUND} (default: none (white))
@findex EDWIN_FOREGROUND
DOS version only.
ANSI foreground color specifier. Must be a two-digit sequence in the range
30-37.  E.g. 32 (green).

@item @code{EDWIN_BACKGROUND} (default: none (black))
@findex EDWIN_BACKGROUND
DOS version only.
ANSI background color specifier. Must be a two-digit sequence in the range
40-47. E.g. 40 (black).

@item @code{TERM}
@findex TERM
Terminal type.  For DOS, should be @samp{ansi.sys} or
@samp{ibm_pc_bios}.  For Windows and Windows NT it should be
@samp{ansi.sys}, which is the default if not set.

@item @code{LINES} (default: auto-sense)
@findex LINES
Unix only.
Number of text lines on the screen, depending on the terminal type.

@item @code{MITSCHEME_LINES} (default: auto-sense or 25)
@findex MITSCHEME_LINES
DOS only.  Number of text lines on the screen, depending on the video
adapter and support software.  E.g. 43.

@item @code{COLUMNS} (default: auto-sense)
@findex COLUMNS
Unix only.
Number of text columns on the screen, depending on the terminal type (Unix) or
video adapter and support software (DOS).  E.g. 132.

@item @code{MITSCHEME_COLUMNS} (default: auto-sense, or 80)
@findex MITSCHEME_COLUMNS
DOS only.  Number of text columns on the screen, depending on the video
adapter and support software.  E.g. 132.

@end table


@node Starting Scheme from Microsoft Windows 3.1/NT, Leaving Scheme, Environment Variables, Running Scheme
@section Starting Scheme from Microsoft Windows 3.1/NT

There are two distinct versions of MIT Scheme that run on IBM
`compatible' PCs: the DOS version is a character-mode only
implementation, which can also run under Windows 3.1 as a DOS application.
The Windows version runs as graphics based application under Microsoft
Windows 3.1 or Microsoft Windows NT.
The DOS version will not run under Windows NT.

Under Microsoft Windows 3.1, Scheme must be run from the Program Manager or
the File Manager.  Scheme cannot be run from the command line, because
only DOS programs can be run from the command line.
(This is the case even with WXSERVER as it appears not to work with
win32s-based programs).
Windows NT overcomes this restriction, but it is still useful to know
how to run Scheme from the Program Manager.

Once an icon is set up to run Scheme with some particular cmmand line
options, Scheme is run by double-clicking that icon.
The rest of this section gives some tips on how to set up icons in the
Program Manager that run Scheme.  If you are unfamiliar with this
concept you should read about it under the help topic of the Program
Manager.

Under Windows NT program manager groups can be @emph{common} or
@emph{personal}.  When setting up icons in a common group it is
important to make the icons independent of the vagaries of the
environment of which user is running them.  It is often worthwhile doing
this under Windows 3.1 and for personal groups too:

@itemize @bullet
@item
Give the icon an accurate @var{Description}.
@item
Include absolute pathnames to @code{scheme.exe} and @code{bchscheme.exe}
in the icon @var{Command line} if these executables are not in a
directory on the default @code{PATH}.
@item
Set the icon's @var{Working Directory} to: @code{%HOMEPATH%}
@item
There are several icons available --- choose one that best represents
the options given on the command line.
@item
Specifying a band that contains Edwin is not sufficient to invoke the
editor.  You also have to put

@example
-eval (edit)
@end example

at the end of the command line.
@end itemize





@node Leaving Scheme,  , Starting Scheme from Microsoft Windows 3.1/NT, Running Scheme
@section Leaving Scheme

There are two ways you can leave Scheme.  The first is to evaluate

@findex exit
@lisp
(exit)
@end lisp

@noindent
which will halt the Scheme system, after first requesting confirmation.
Any information that was in the environment is lost, so this should not
be done lightly.

The second way to leave Scheme is to suspend it; when this is done you
may later restart where you left off.  Unfortunately this is not
possible in all operating systems --- currently it is known to work on
BSD Unix, Ultrix, SunOS, HP-UX (version 6.5 or later).  It does
@emph{not} work on AT&T Unix or on PC platforms.  (Specifically, for
unix or POSIX systems, suspension is available if the system supports
job control.)

Scheme is suspended by evaluating

@findex quit
@lisp
(quit)
@end lisp

@noindent
If your system supports suspension, this will cause Scheme to stop, and
you will be returned to the operating system's command interpreter.
Scheme remains stopped, and can be continued using the job-control
commands of your command interpreter.  If your system doesn't support
suspension, this procedure does nothing.  (Calling the @code{quit}
procedure is analogous to typing Control-@code{Z}, but it allows Scheme
to respond by typing a prompt when it is unsuspended.)


@node REPL, Debugging, Running Scheme, Top
@chapter The Read-Eval-Print Loop

@cindex REPL
When you first start up Scheme from the command line (i.e not under
Edwin), you will be typing at a program called the @dfn{Read-Eval-Print
Loop} (abbreviated @dfn{REPL}).  It displays a prompt at the left hand
side of the screen whenever it is waiting for input.  You then type an
expression (terminating it with @key{RET}).  Scheme evaluates the
expression, prints the result, and gives you another prompt.

@menu
* The Prompt and Level Number::  The Prompt and Level Number
* Interrupting::                Interrupting
* Proceeding::                  Proceeding
* The Current REPL Environment::  The Current REPL Environment
@end menu

@node The Prompt and Level Number, Interrupting,  , REPL
@section The Prompt and Level Number

@cindex prompt, REPL
The @sc{repl} @dfn{prompt} normally has the form

@example
1 ]=>
@end example

@cindex level number, REPL
@noindent
The @samp{1} in the prompt is a @dfn{level number}, which is always a
positive integer.  This number is incremented under certain
circumstances, the most common being an error.  For example, here is
what you will see if you type @kbd{f o o @key{RET}} after starting
Scheme:

@example
;Unbound variable: foo
;To continue, call RESTART with an option number:
; (RESTART 3) => Specify a value to use instead of foo.
; (RESTART 2) => Define foo to a given value.
; (RESTART 1) => Return to read-eval-print level 1.


2 error> 
@end example

@noindent
In this case, the level number has been incremented to @samp{2}, which
indicates that a new @sc{repl} has been started (also the prompt string
has been changed to remind you that the @sc{repl} was started because of
an error).  The @samp{2} means that this new @sc{repl} is ``over'' the
old one.  The original @sc{repl} still exists, and is waiting for you to
return to it, for example, by entering @code{(restart 1)}.  Furthermore,
if an error occurs while you are in this @sc{repl}, yet another
@sc{repl} will be started, and the level number will be increased to
@samp{3}.  This can continue ad infinitum, but normally it is rare to
use more than a few levels.

The normal way to get out of an error @sc{repl} and back to the top
level @sc{repl} is to use the @kbd{C-g} interrupt.  This is a
single-keystroke command executed by holding down the @key{CTRL} key and
pressing the @key{G} key.  @kbd{C-g} always terminates whatever is
running and returns you to the top level @sc{repl} immediately.

Note: The appearance of the @samp{error>} prompt does not mean that
Scheme is in some weird inconsistent state that you should avoid.  It is
merely a reminder that your program was in error: an illegal operation
was attempted, but it was detected and avoided.  Often the best way to
find out what is in error is to do some poking around in the error
@sc{repl}.  If you abort out of it, the context of the error will be
destroyed, and you may not be able to find out what happened.

@node Interrupting, Proceeding, The Prompt and Level Number, REPL
@section Interrupting

@kindex C-g
@kindex C-c
Scheme has two interrupt keys under unix: @kbd{C-g} and @kbd{C-c}.  
Other systems, like the PC may have more than two.
The PC version has @kbd{C-b}, @kbd{C-x} and @kbd{C-u} as well as
@kbd{C-g} and @kbd{C-c}.
The @kbd{C-g} key stops any Scheme
evaluation that is running and returns you to the top level @sc{repl}.
@kbd{C-c} prompts you for another character and performs some action
based on that character.  It is not necessary to type @key{RET} after
@kbd{C-g} or @kbd{C-c}, nor is it needed after the character that
@kbd{C-c} will ask you for.

Here are the more common options for @kbd{C-c}.

@table @kbd

@item C-c i
@kindex C-c i
Ignore the interrupt.  Type this if you made a mistake and didn't
really mean to type @kbd{C-c}.

@item C-c ?
@kindex C-c ?
Print help information.  This will describe any other options not
documented here.

@item C-c q
@kindex C-c q
@findex exit
Similar to typing @code{(exit)} at the @sc{repl}, except that it works
even if Scheme is running an evaluation, and does not request
confirmation.

@item C-c z
@kindex C-c z
@findex quit
Similar to typing @code{(quit)} at the @sc{repl}, except that it works
even if Scheme is running an evaluation.

@item C-c C-c
@kindex C-c C-c
Identical to typing @kbd{C-g}.  If no evaluation is running, this is
equivalent to evaluating

@findex cmdl-interrupt/abort-top-level
@lisp
(cmdl-interrupt/abort-top-level)
@end lisp

@noindent
@kindex C-c C-g
@kindex C-c g
The options @kbd{C-c C-g} and @kbd{C-c g}, supplied for compatibility
with older implementations, are equivalent to @kbd{C-c C-c}.

@item C-c C-x
@kindex C-c C-x
Abort whatever Scheme evaluation is currently running and return to the
``current'' @sc{repl}.  If no evaluation is running, this is equivalent
to evaluating

@findex cmdl-interrupt/abort-nearest
@lisp
(cmdl-interrupt/abort-nearest)
@end lisp

@kindex C-c x
The option @kbd{C-c x}, supplied for compatibility with older
implementations, is equivalent to @kbd{C-c C-x}.

@kindex C-x
On the PC version @kbd{C-x} is equivalent to @kbd{C-c C-x}.

@item C-c C-u
@kindex C-c C-u
Abort whatever Scheme evaluation is running and go up one level.  If you
are already at level number 1, it just aborts the evaluation, leaving
you at level 1.  If no evaluation is running, this is equivalent to
evaluating

@findex cmdl-interrupt/abort-previous
@lisp
(cmdl-interrupt/abort-previous)
@end lisp

@kindex C-c u
The option @kbd{C-c u}, supplied for compatibility with older
implementations, is equivalent to @kbd{C-c C-u}.

@kindex C-u
On the PC version @kbd{C-u} is equivalent to @kbd{C-c C-u}.

@item C-c C-b
@kindex C-c C-b
@cindex breakpoint
Suspend whatever Scheme evaluation is running and start a
@dfn{breakpoint} @sc{repl}.  The evaluation can be resumed by evaluating

@findex proceed
@lisp
(proceed)
@end lisp

@noindent
in that @sc{repl} at any time.

@kindex C-c b
The option @kbd{C-c b}, supplied for compatibility with older
implementations, is equivalent to @kbd{C-c C-b}.

@kindex C-b
On the PC version @kbd{C-b} is equivalent to @kbd{C-c C-b}.
@end table


@node Proceeding, The Current REPL Environment, Interrupting, REPL
@section Proceeding

Another way of exiting a @sc{repl} is to use the @code{proceed}
procedure:

@deffn {procedure+} proceed [value]
@cindex error REPL, proceeding from
There are two ways to use this procedure from an error @sc{repl} (usage
from other kinds of @sc{repl} is not necessarily the same).  If
@var{value} is not given, @code{proceed} retries the expression that
caused the error.  Unless you have done something to fix the error
condition, this will just cause the error to happen all over again.  If,
for example, you are in an error @sc{repl} caused by evaluating an
unbound variable, the proper way to use @code{proceed} is to first
define a value for the variable, then to evaluate @code{(proceed)}.
Your program should continue from that point normally.

One caveat: when you get an unbound variable error, the environment for
the error @sc{repl} is the environment in which you looked up the
variable, which is not necessarily the environment in which the variable
should be defined.  It is best to use the @code{ge} procedure to
guarantee that your definition goes into the right place.

If @var{value} is given, @code{proceed} returns it in place of the
expression that caused the error.  Thus, if you cannot easily fix a
particular bug, but you know a correct value for the erring expression,
you can continue the computation this way.
@end deffn

@node The Current REPL Environment,  , Proceeding, REPL
@section The Current REPL Environment

@cindex current REPL environment
@findex user-initial-environment
@findex system-global-environment
Every @sc{repl} has a @dfn{current environment}, which is the place
where expressions are evaluated and definitions are stored.  When Scheme
is started, this environment is the value of the variable
@code{user-initial-environment}.  There are a number of other
environments in the system, for example
@code{system-global-environment}, where the runtime system's bindings
are stored.

You can get the current @sc{repl} environment by evaluating

@findex nearest-repl/environment
@lisp
(nearest-repl/environment)
@end lisp

There are several other ways to obtain environments.  For example, if
you have a procedure object, you can get a pointer to the environment in
which it was closed by evaluating

@findex procedure-environment
@lisp
(procedure-environment @var{procedure})
@end lisp

Your programs create new environments whenever a procedure is called.
When an error occurs, the error @sc{repl} that is created is usually
initialized so that its current environment is the one in which the
error occurred.  When it is not possible to supply the error's
environment, the following message is printed:

@lisp
There is no environment available;
using the current REPL environment
@end lisp

@noindent
This message tells you that the error @sc{repl} is using the same
environment as the @sc{repl} whose level number is one less than the
error @sc{repl}'s.

Here is the procedure that changes the @sc{repl}'s environment:

@deffn {procedure+} ge environment
Changes the current @sc{repl} environment to be @var{environment}
(@code{ge} stands for ``Goto Environment'').  @var{Environment} is
allowed to be a procedure as well as an environment object.  If it is a
procedure, then the closing environment of that procedure is used in its
place.
@end deffn

@deffn {procedure+} gst syntax-table
In addition to the current environment, each @sc{repl} maintains a
current @dfn{syntax table}.  The current syntax table tells the
@sc{repl} which keywords are used to identify special forms (e.g.
@code{if}, @code{lambda}).  If you write macros, often you will want to
make your own syntax table, in which case it is useful to be able to
make that syntax table be the current one.  @code{Gst} allows you to do
that.
@end deffn

@node Debugging, Loading Files, REPL, Top
@chapter Debugging

This chapter is adapted from @cite{Don't Panic: A 6.001 User's Guide to
the Chipmunk System}, by Arthur A. Gleckler.

@cindex bugs
@cindex debugging
Even computer software that has been planned carefully and written well
may not always work correctly.  Mysterious creatures called @dfn{bugs}
may creep in and wreak havoc, leaving the programmer to clean up the
mess.  Some have theorized that a program fails only because its author
made a mistake, but experienced computer programmers know that bugs are
always to blame.  This is why the task of fixing broken computer
software is called @dfn{debugging}.

It is impossible to prove the correctness of any non-trivial program;
hence the Cynic's First Law of Debugging:

@quotation
Programs don't become more reliable as they are debugged; the bugs just
get harder to find.
@end quotation

@cindex breakpoints
Scheme is equipped with a variety of special software for finding and
removing bugs.  The debugging tools include facilities for tracing a
program's use of specified procedures, for examining Scheme
environments, and for setting @dfn{breakpoints}, places where the
program will pause for inspection.

@cindex error
Many bugs are detected when programs try to do something which is
impossible, like adding a number to a symbol, or using a variable which
does not exist; this type of mistake is called an @dfn{error}.
Whenever an error occurs, Scheme prints an error message and starts a
new @sc{repl}.  For example, using a nonexistent variable @code{foo} will
cause Scheme to respond

@example
1 ]=> foo

;Unbound variable: foo
;To continue, call RESTART with an option number:
; (RESTART 3) => Specify a value to use instead of foo.
; (RESTART 2) => Define foo to a given value.
; (RESTART 1) => Return to read-eval-print level 1.


2 error> 
@end example

Sometimes, a bug will never cause an error, but will still cause the
program to operate incorrectly.  For instance,

@lisp
(prime? 7)   @result{}   #f
@end lisp

In this situation, Scheme does not know that the program is misbehaving.
The programmer must notice the problem and, if necessary, start the
debugging tools manually.

There are several approaches to finding bugs in a Scheme program:

@itemize @bullet
@item
Inspect the original Scheme program.

@item
Use the debugging tools to follow your program's progress.

@item
Edit the program to insert checks and breakpoints.
@end itemize

@noindent
Only experience can teach how to debug programs, so be sure to
experiment with all these approaches while doing your own debugging.
Planning ahead is the best way to ward off bugs, but when bugs do
appear, be prepared to attack them with all the tools available.

@menu
* Subproblems and Reductions::  Subproblems and Reductions
* Debugger::                    The Debugger
@end menu

@node Subproblems and Reductions, Debugger,  , Debugging
@section Subproblems and Reductions

@cindex subproblem
@cindex reduction
@cindex subexpression
Understanding the concepts of @dfn{reduction} and @dfn{subproblem} is
essential to good use of the debugging tools.  The Scheme interpreter
evaluates an expression by @dfn{reducing} it to a simpler expression.
In general, Scheme's evaluation rules designate that evaluation proceeds
from one expression to the next by either starting to work on a
@dfn{subexpression} of the given expression, or by reducing the entire
expression to a new (simpler, or reduced) form.  Thus, a history of the
successive forms processed during the evaluation of an expression will
show a sequence of subproblems, where each subproblem may consist of a
sequence of reductions.

For example, both @code{(+ 5 6)} and @code{(+ 7 9)} are subproblems of
the following combination:

@lisp
(* (+ 5 6) (+ 7 9))
@end lisp

If @code{(prime? n)} is true, then @code{(cons 'prime n)} is a reduction
for the following expression:

@lisp
(if (prime? n)
    (cons 'prime n)
    (cons 'not-prime n))
@end lisp

This is because the entire subproblem of the @code{if} combination can
be reduced to the problem @code{(cons 'prime n)}, once we know that
@code{(prime?  n)} is true; the @code{(cons 'not-prime n)} can be
ignored, because it will never be needed.  On the other hand, if
@code{(prime? n)} were false, then @code{(cons 'not-prime n)} would be
the reduction for the @code{if} combination.

The @emph{subproblem level} is a number representing how far back in the
history of the current computation a particular evaluation is.  Consider
@code{factorial}:

@lisp
(define (factorial n)
  (if (< n 2)
      1
      (* n (factorial (- n 1)))))
@end lisp

@noindent
If we stop @code{factorial} in the middle of evaluating @code{(- n 1)},
the @code{(- n 1)} is at subproblem level 0.  Following the history of
the computation ``upwards,'' @code{(factorial (- n 1))} is at subproblem
level 1, and @code{(* n (factorial (- n 1)))} is at subproblem level 2.
These expressions all have @emph{reduction number} 0.  Continuing
upwards, the @code{if} combination has reduction number 1.

Moving backwards in the history of a computation, subproblem levels and
reduction numbers increase, starting from zero at the expression
currently being evaluated.  Reduction numbers increase until the next
subproblem, where they start over at zero.  The best way to get a feel
for subproblem levels and reduction numbers is to experiment with the
debugging tools, especially @code{debug}.

@node Debugger,  , Subproblems and Reductions, Debugging
@section The Debugger

@cindex debugger
@cindex continuation Browser
@cindex browser, Continuation
@findex debug
The @dfn{debugger}, called @code{debug}, is the tool you should use when
Scheme signals an error and you want to find out what caused the error.
When Scheme signals an error, it records all the information necessary
to continue running the Scheme program that caused the error; the
debugger provides you with the means to inspect this information.  For
this reason, the debugger is sometimes called a @dfn{continuation
browser}.

Here is the transcript of a typical Scheme session, showing a user
evaluating the expression @code{(fib 10)}, Scheme responding with an
unbound variable error for the variable @code{fob}, and the user
starting the debugger:

@example
1 ]=> (fib 10)

;Unbound variable: fob
;To continue, call RESTART with an option number:
; (RESTART 3) => Specify a value to use instead of fob.
; (RESTART 2) => Define fob to a given value.
; (RESTART 1) => Return to read-eval-print level 1.


2 error> (debug)

There are 6 subproblems on the stack.

Subproblem level: 0 (this is the lowest subproblem level)
Expression (from stack):
    fob
Environment created by the procedure: FIB
 applied to: (10)
The execution history for this subproblem contains 1 reduction.
You are now in the debugger.  Type q to quit, ? for commands.

3 debug> 
@end example

@noindent
@cindex execution history
This tells us that the error occurred while trying to evaluate the
expression @code{fob} while running @code{(fib 10)}.  It also tells us
this is subproblem level 0, the first of 8 subproblems that are
available for us to examine.  The expression shown is marked ``(from
stack)'', which tells us that this expression was reconstructed from the
interpreter's internal data structures.  Another source of information
is the @dfn{execution history}, which keeps a record of expressions
evaluated by the interpreter.  The debugger informs us that the
execution history has recorded some information for this subproblem,
specifically a description of one reduction.

@node Loading Files, World Images, Debugging, Top
@chapter Loading Files

To load files of Scheme code, use the procedure @code{load}:

@deffn {procedure} load filename [environment [syntax-table]]
@var{Filename} may be a string naming a file, or a list of strings
naming many files.  @var{Environment}, if given, is the environment to
evaluate the file in; if not given the current @sc{repl} environment is
used.  Likewise @var{syntax-table} is the syntax table to use.

@findex pathname-type
@code{Load} determines whether the file to be loaded is binary or source
code, and performs the appropriate action.  By convention, files of
source code have a pathname type of @code{"scm"}, and files of binary
SCode have pathname type @code{"bin"}.  Native-code binaries have
pathname type @code{"com"}.  (See the description of
@code{pathname-type} in the reference manual.)
@end deffn

@defvr {variable+} load-noisily?
If @code{load-noisily?} is set to @code{#t}, @code{load} will print the
value of each expression in the file as it is evaluated.  Otherwise,
nothing is printed except for the value of the last expression in the
file.  (Note: the noisy loading feature is implemented for source-code
files only.)
@end defvr

@defvr {variable+} load/default-types
When load is given a pathname without a type, it uses the value of thsi
variable to determine what pathname types to look for and how to load
the file.  @code{load/default-types} is a list of associations that maps
pathname types (strings) to loader procedures.  @code{Load} tries the
pathname types in the order that they appear in the list.  The initial
value of this variable has pathname types in this order:

@lisp
"com" "so" "sl" "bin" "scm"
@end lisp

This means that, for example, @code{(load "foo")} will try to load
@file{foo.com} first, and @file{foo.scm} only after looking for and
failing to find the other pathname types.
@end defvr

@cindex working directory
@findex pwd
@findex cd
All pathnames are interpreted relative to a working directory, which is
initialized when Scheme is started.  The working directory can be
obtained from the procedure @code{pwd} or modified by the procedure
@code{cd}; see the reference manual for details.

@node World Images, Compiling Files, Loading Files, Top
@chapter World Images

@cindex world image
@cindex band
A @dfn{world image} is a file that contains a complete Scheme system,
perhaps additionally including user application code.  Scheme provides
two methods for saving and restoring world images.  The first method
writes a file containing all of the Scheme code in the world, which is
called a @dfn{band}.  The file @file{runtime.com} that is loaded by the
microcode is just such a band.
To make your own band, use the procedure
@code{disk-save}.

@deffn {procedure+} disk-save filename [identify]
Causes a band to be written to the file specified by @var{filename}.
The optional argument @var{identify} controls what happens when that
band is restored, as follows:

@table @asis
@item not specified
Start up in the top-level @sc{repl}, identifying the world in the normal
way.

@item a string
Do the same thing except print that string instead of @samp{Scheme} when
restarting.

@item the constant @code{#t}
Restart exactly where you were when the call to @code{disk-save} was
performed.  This is especially useful for saving your state when an
error has occurred and you are not in the top-level @sc{repl}.

@item the constant @code{#f}
Just like @code{#t}, except that the runtime system will not perform
normal restart initializations; in particular, it will not load your
init file.
@end table
@end deffn

@findex disk-restore
To restore a saved band, give the @code{-band} option when starting
Scheme.  Alternatively, evaluate @code{(disk-restore @var{filename})}
from a running Scheme, which will destroy the current world, replacing
it with the saved world.  The argument to @code{disk-restore} may be
omitted, in which case it defaults to the filename from which the
current world was last restored.


Note: with the C back-end, @code{disk-save} is not very useful.
The reason is that compiled procedures are compiled C code that has been
dynamically linked in, and @code{disk-save} does not save any C
procedures.
If you need to build a band for a C back-end system, please contact us.

Note: when restoring a saved band, the Scheme executable must be
configured with a large enough constant space and heap to hold the
band's contents.  If you attempt to restore a band using the
@code{-band} option, and the band is too large, Scheme will write an
error message that tells you the appropriate command-line options needed
to load that band.  If you attempt restore a too-large band using
@code{disk-restore}, Scheme will signal an error, but will not provide
the configuration information.  In general, the configuration that was
used to save a band is sufficiently large to restore it.

@findex dump-world
Another method for saving the world is the @code{dump-world} procedure,
which accepts the same arguments as @code{disk-save} and works in much
the same way.  However, rather than dumping a band, @code{dump-world}
saves an executable image, which is started just like any other program.
This has the advantage of being considerably faster to start on some
systems, but the image file is typically much larger than the
corresponding band.  However, @code{dump-world} is only supported for a
few operating systems, and is not built into the distributed executable
files --- if you wish to use @code{dump-world}, you must build your own
executable file from the source code.
Note that @code{dump-world} is unlikely to work with this release as MIT
Scheme now uses shared libraries.

@node Compiling Files, GNU Emacs Interface, World Images, Top
@chapter Compiling Files

Note: the procedures described in this section are only available in the
@file{compiler.com} world image.  Furthermore, @code{cf} is only
available on machines that support native-code compilation.

@menu
* Compilation Procedures::      Compilation Procedures
* Declarations::                Declarations
@end menu

@node Compilation Procedures, Declarations,  , Compiling Files
@section Compilation Procedures

@deffn {procedure+} cf filename [destination]
This is the program that transforms a source-code file into native-code
binary form.  If @var{destination} is not given, as in

@lisp
(cf "foo")
@end lisp

@noindent
@code{cf} compiles the file @file{foo.scm}, producing the file
@file{foo.com} (incidentally it will also produce @file{foo.bin},
@file{foo.bci}, and possibly @file{foo.ext}).  If you later evaluate

@lisp
(load "foo")
@end lisp

@noindent
@file{foo.com} will be loaded rather than @file{foo.scm}.

If @var{destination} is given, it says where the output files should go.
If this argument is a directory, they go in that directory, e.g.:

@lisp
(cf "foo" "../bar/")
@end lisp

@noindent
will take @file{foo.scm} and generate the file @file{../bar/foo.com}.
If @var{destination} is not a directory, it is the root name of the
output:

@lisp
(cf "foo" "bar")
@end lisp

@noindent
takes @file{foo.scm} and generates @file{bar.com}.
@end deffn

About the @file{.bci} files: these files contain the debugging
information that Scheme uses when you call @code{debug} to examine
compiled code.  When you load a @file{.com} file, Scheme remembers where
it was loaded from, and when the debugger (or @code{pp}) looks at the
compiled code from that file, it attempts to find the @file{.bci} file
in the same directory from which the @file{.com} file was loaded.  Thus
it is a good idea to leave these files together.

@file{.bci} files are stored in a compressed format.
The debugger has to uncompress the files when it first looks at them,
and on a slow machine this can take a noticable time.
In order to reduce this behaviour, the uncompressed files may be kept
around and the debugging information is cached in memory.

@c Two variables control the behaviour.

@defvr {variable+} load-debugging-info-on-demand?
cph: What operations other than normal printing are affected by this?
@end defvr

@deffn {procedure+} discard-debugging-info!
Calling this procedure causes any debugging info cached in memory to be
discarded.
@end deffn

cph: how can a user tailor the .bci uncompressed file behaviour?

@c Unfortunately, the @file{.binf} files are somewhat large in the current
@c implementation.  If you wish to save space, these files may be deleted;
@c if Scheme tries to find one and cannot, it will still permit debugging,
@c but will be unable to produce much information about your program.


@deffn {procedure+} sf filename [destination]
@code{sf} is the program that transforms a source-code file into binary
SCode form; it is used on machines that do not support native-code
compilation.  It performs numerous optimizations that can make your
programs run considerably faster than unoptimized interpreted code.
Also, the binary files that it generates load very quickly compared to
source-code files.

The simplest way to use @code{sf} is just to say:

@lisp
(sf @var{filename})
@end lisp

@noindent
This will cause your file to be transformed, and the resulting binary
file to be written out with the same name, but with @code{pathname-type}
@code{"bin"}.  If you do not specify a @code{pathname-type} on the input
file, @code{"scm"} is assumed.

Like @code{load}, the first argument to @code{sf} may be a list of
filenames rather than a single filename.

@code{sf} takes an optional second argument, which is the filename of
the output file.  If this argument is a directory, then the output file
has its normal name but is put in that directory instead.
@end deffn

@node Declarations,  , Compilation Procedures, Compiling Files
@section Declarations
@cindex declarations

Several declarations can be added to your programs to help @code{cf} and
@code{sf} make them more efficient.

@menu
* Standard Names::              Standard Names
* In-line Coding::              In-line Coding
* Operator Reduction::          Operator Reduction
@end menu

@node Standard Names, In-line Coding,  , Declarations
@subsection Standard Names

Normally, all files have a line

@findex usual-integrations
@lisp
(declare (usual-integrations))
@end lisp

@noindent
near their beginning, which tells the compiler that free variables whose
names are defined in @code{system-global-environment} will not be
shadowed by other definitions when the program is loaded.  If you
redefine some global name in your code, for example @code{car},
@code{cdr}, and @code{cons}, you should indicate it in the declaration:

@lisp
(declare (usual-integrations car cdr cons))
@end lisp

You can obtain an alphabetically-sorted list of the names that the
@code{usual-integrations} declaration affects by evaluating the
following expression:

@lisp
(eval '(sort (append usual-integrations/constant-names
                     usual-integrations/expansion-names)
             (lambda (x y)
               (string<=? (symbol->string x)
                          (symbol->string y))))
      (->environment '(scode-optimizer)))
@end lisp

@node In-line Coding, Operator Reduction, Standard Names, Declarations
@subsection In-line Coding

Another useful facility is the ability to in-line code procedure
definitions.  In fact, the compiler will perform full beta conversion,
with automatic renaming, if you request it.  Here are the relevant
declarations:

@deffn {declaration+} integrate name @dots{}
The variables @var{name}s should be defined in the same file as this
declaration.  Any reference to one of the named variables that appears
in the same block as the declaration, or one of its descendant blocks,
will be replaced by the corresponding definition's value expression.
@end deffn

@deffn {declaration+} integrate-operator name @dots{}
Similar to the @code{integrate} declaration, except that it only
substitutes for references that appear in the operator position of a
combination.  All other references are ignored.
@end deffn

@deffn {declaration+} integrate-external filename
Causes the compiler to use the top-level integrations provided by
@var{filename}.  @var{filename} should not specify a file type, and the
source-code file that it names must have been previously processed by
the compiler.

If @var{filename} is a relative filename (the normal case), it is
interpreted as being relative to the file in which the declaration
appears.  Thus if the declaration appears in file @file{/usr/cph/foo.scm},
then the compiler looks for a file called @file{/usr/cph/@var{filename}.ext}.

Note: When the compiler finds top-level integrations, it collects them
and outputs them into an auxiliary file with extension @file{.ext}.
This @file{.ext} file is what the @code{integrate-external} declaration
refers to.
@end deffn

@findex define-integrable
@findex define
Note that the most common use of this facility, in-line coding of
procedure definitions, requires a somewhat complicated use of these
declarations.  Because this is so common, there is a special form,
@code{define-integrable}, which is like @code{define} but performs the
appropriate declarations.  For example:

@lisp
(define-integrable (foo-bar foo bar)
  (vector-ref (vector-ref foo bar) 3))
@end lisp

Here is how you do the same thing without this special form: there
should be an @code{integrate-operator} declaration for the procedure's
name, and (internal to the procedure's definition) an @code{integrate}
declaration for each of the procedure's parameters, like this:

@lisp
(declare (integrate-operator foo-bar))

(define foo-bar
  (lambda (foo bar)
    (declare (integrate foo bar))
    (vector-ref (vector-ref foo bar) 3)))
@end lisp

The reason for this complication is as follows: the
@code{integrate-operator} declaration finds all the references to
@code{foo-bar} and replaces them with the lambda expression from the
definition.  Then, the @code{integrate} declarations take effect because
the combination in which the reference to @code{foo-bar} occurred
supplies code which is substituted throughout the body of the procedure
definition.  For example:

@lisp
(foo-bar (car baz) (cdr baz))
@end lisp

@noindent
First use the @code{integrate-operator} declaration:

@lisp
((lambda (foo bar)
   (declare (integrate foo bar))
   (vector-ref (vector-ref foo bar) 3))
 (car baz)
 (cdr baz))
@end lisp

@noindent
Next use the internal @code{integrate} declaration:

@lisp
((lambda (foo bar)
   (vector-ref (vector-ref (car baz) (cdr baz)) 3))
 (car baz)
 (cdr baz))
@end lisp

@noindent
Next notice that the variables @code{foo} and @code{bar} are not used,
and eliminate them:

@lisp
((lambda ()
   (vector-ref (vector-ref (car baz) (cdr baz)) 3)))
@end lisp

@noindent
Finally, remove the @code{((lambda () @dots{}))} to produce

@lisp
(vector-ref (vector-ref (car baz) (cdr baz)) 3)
@end lisp


@node
@subsection Operator Replacement

The @code{replace-operator} declaration is provided to inform the
compiler that certain operators may be replaced by other operators
depending on the number of arguments.
For example:

@noindent
Declaration:

@lisp
(declare (replace-operator (map (2 map-2) (3 map-3))))
@end lisp

@noindent
Replacements:

@lisp
(map @var{f} @var{x} @var{y} @var{z}) @expansion{} (map @var{f} @var{x} @var{y} @var{z})
(map @var{f} @var{x} @var{y}) @expansion{} (map-3 @var{f} @var{x} @var{y})
(map @var{f} @var{x}) @expansion{} (map-2 @var{f} @var{x})
(map @var{f}) @expansion{} (map @var{f})
(map) @expansion{} (map)
@end lisp

@noindent
Presumably, @code{map-2} and @code{map-3} are efficient versions of
@code{map} because they are written for exactly two and three arguments
respectively.  All the other cases are not expanded and handled by the
general @code{map} procedure, which is less efficient because it must
handle a variable number of arguments.


@deffn {delcaration+} replace-operator name ...

The syntax of this declaration is

@lisp
(replace-operator
 (@var{name}
  (@var{nargs1} @var{value1})
  (@var{nargs2} @var{value2})
  ...))
@end lisp

where

@itemize @bullet
@item
@var{name} is a symbol.

@item
@var{nargs1}, @var{nargs2} etc. are non-negative integers, or one of the
following symbols:  @code{any}, @code{else} or @code{otherwise}.

@item
@var{value1}, @var{value2} etc. are simple
expressions in one of these forms:

@table @code

@item '@var{constant}
A constant.

@item @var{variable}
A variable.

@item (primitive @var{primitive-name} @r{[}@var{arity}@r{]})
The primitive procedure named @var{primitive-name}.  The optional
element @var{arity}, a non-negative integer, specifies the number of
arguments that the primitive accepts.

@item (global @var{var})
A global variable.
@end table
@end itemize

The meaning of these field is:

@itemize @bullet
@item
@var{name} is the name of the operator to be reduced.  If is is not
shadowed (for example, by a let) then it may be replaced according to
the following rules.

@item
If the operator has @var{nargsN} arguments then it is replaced with a
call to @var{valueN} with the same arguments

@item
If the number of arguments is not listed, and one of the @var{nargsN} is
@code{any}, @code{else} or @code{otherwise}, then the operation is
replaced with a call to the corresponding @var{valueN}.
Only one of the @var{nargsN} may be of this form.

@item
If the number of arguments is not listed and none of the @var{nargsN} is
@code{andy}, @code{else} or @code{otherwise}, then the operation is not
replace.
@end itemize
@end deffn

@node Operator Reduction,  , In-line Coding, Declarations
@subsection Operator Reduction

@findex reduce-operator
The @code{reduce-operator} declaration is provided to inform the
compiler that certain names are n-ary versions of binary operators.
Here are some examples:

@noindent
Declaration:

@lisp
(declare (reduce-operator (cons* cons)))
@end lisp

@noindent
Replacements:

@lisp
(cons* @var{x} @var{y} @var{z} @var{w}) @expansion{} (cons @var{x} (cons @var{y} (cons @var{z} @var{w}))),
(cons* @var{x} @var{y}) @expansion{} (cons @var{x} @var{y})
(cons* @var{x}) @expansion{} @var{x}
(cons*) @error{} too few arguments
@end lisp

@noindent
Declaration:

@lisp
(declare (reduce-operator (list cons (null-value '() any))))
@end lisp

@noindent
Replacements:

@lisp
(list @var{x} @var{y} @var{z} @var{w}) @expansion{} (cons @var{x} (cons @var{y} (cons @var{z} (cons @var{w} '()))))
(list @var{x} @var{y}) @expansion{} (cons @var{x} (cons @var{y} '()))
(list @var{x}) @expansion{} (cons @var{x} '())
(list) @expansion{} '()
@end lisp

@noindent
Declaration:

@lisp
(declare (reduce-operator (- %- (null-value 0 single) (group left))))
@end lisp

@noindent
Replacements:

@lisp
(- @var{x} @var{y} @var{z} @var{w}) @expansion{} (%- (%- (%- @var{x} @var{y}) @var{z}) @var{w})
(- @var{x} @var{y}) @expansion{} (%- @var{x} @var{y})
(- @var{x}) @expansion{} (%- 0 @var{x})
(-) @expansion{} 0
@end lisp

@noindent
Declaration:

@lisp
(declare (reduce-operator (+ %+ (null-value 0 none) (group right))))
@end lisp

@noindent
Replacements:

@lisp
(+ @var{x} @var{y} @var{z} @var{w}) @expansion{} (%+ @var{x} (%+ @var{y} (%+ @var{z} @var{w})))
(+ @var{x} @var{y}) @expansion{} (%+ @var{x} @var{y})
(+ @var{x}) @expansion{} @var{x}
(+) @expansion{} 0
@end lisp

Note: This declaration does not cause an appropriate definition of
@code{+} (in the last example) to appear in your code.  It merely
informs the compiler that certain optimizations can be performed on
calls to @code{+} by replacing them with calls to @code{%+}.  You should
provide a definition of @code{+} as well, although it is not required.


@noindent
Declaration:

@lisp
(declare (reduce-operator (apply (primitive cons)
                                 (group right)
                                 (wrapper (global apply) 1))))
@end lisp

@noindent
Replacements:

@lisp
(apply @var{f} @var{x} @var{y} @var{z} @var{w}) @expansion{} ((access apply ()) @var{f} (cons @var{x} (cons @var{y} (cons @var{z} @var{w}))))
(apply @var{f} @var{x} @var{y}) @expansion{} ((access apply ()) @var{f} (cons @var{x} @var{y}))
(apply @var{f} @var{x}) @expansion{} (apply @var{f} @var{x})
(apply @var{f}) @expansion{} (apply @var{f})
(apply) @expansion{} (apply)
@end lisp




@deffn {declaration+} reduce-operator name ...
The general format of the declaration is (brackets denote optional
elements):

@lisp
(reduce-operator
 (@var{name}
  @var{binop}
  @r{[}(group @var{ordering})@r{]}
  @r{[}(null-value @var{value} @var{null-option})@r{]}
  @r{[}(singleton @var{unop})@r{]}
  @r{[}(wrapper @var{wrap} @r{[}n@r{]})@r{]}
  @r{[}(maximum @var{m})@r{]}
  ))
@end lisp

@noindent
where

@itemize @bullet

@item
@var{n} and @var{m} are non-negative integers.

@item
@var{name} is a symbol.

@item
@var{binop}, @var{value}, @var{unop}, and @var{wrap} are simple
expressions in one of these forms:

@table @code

@item '@var{constant}
A constant.

@item @var{variable}
A variable.

@item (primitive @var{primitive-name} @r{[}@var{arity}@r{]})
The primitive procedure named @var{primitive-name}.  The optional
element @var{arity} specifies the number of arguments that the primitive
accepts.

@item (global @var{var})
A global variable.
@end table

@item
@var{null-option} is either @code{always}, @code{any}, @code{one},
@code{single}, @code{none}, or @code{empty}.

@item
@var{ordering} is either @code{left}, @code{right}, or
@code{associative}.
@end itemize

@noindent
The meaning of these fields is:

@itemize @bullet

@item
@var{name} is the name of the n-ary operation to be reduced.

@item
@var{binop} is the binary operation into which the n-ary operation is to
be reduced.

@item
The @code{group} option specifies whether @var{name} associates to the
right or left.

@item
The @code{null-value} option specifies a value to use in the following
cases:

@table @code

@item none
@itemx empty
When no arguments are supplied to @var{name}, @var{value} is returned.

@item one
@itemx single
When a single argument is provided to @var{name}, @var{value} becomes
the second argument to @var{binop}.

@item any
@itemx always
@var{binop} is used on the ``last'' argument, and @var{value} provides
the remaining argument to @var{binop}.
@end table

In the above options, when @var{value} is supplied to @var{binop}, it is
supplied on the left if grouping to the left, otherwise it is supplied
on the right.

@item
The @code{singleton} option specifies a function, @var{unop}, to be
invoked on the single argument left.  This option supersedes the
@code{null-value} option, which can only take the value @code{none}.

@item
The @code{wrapper} option specifies a function, @var{wrap}, to be
invoked on the result of the outermost call to @var{binop} after the
expansion.
If @var{n} is provided it must be a non-negative integer indicating a number
of arguments that are transferred verbatim from the original call to
the wrapper.  They are passed to the left of the reduction.

@item
The maximum option specifies that calls with more than @var{m} arguments
should not be reduced.

@end itemize
@end deffn

@node GNU Emacs Interface, Edwin, Compiling Files, Top
@chapter GNU Emacs Interface

There is an interface library, called @code{xscheme}, distributed with
MIT Scheme and GNU Emacs, which facilitates running Scheme as a
subprocess of Emacs.  If you wish to use this interface, please install
the version of @file{xscheme.el} that comes with MIT Scheme, as it is
guaranteed to be correct for your version of Scheme.

@findex run-scheme
@findex -emacs
To invoke Scheme from Emacs, use @kbd{M-x run-scheme}, which is defined
when either of the libraries @file{scheme} or @file{xscheme} is loaded.
You may give @code{run-scheme} a prefix argument, in which case it will
allow you to edit the command line that is used to invoke Scheme.
@emph{Do not} remove the @code{-emacs} option!

@findex scheme-interaction-mode
Scheme will be started up as a subprocess in a buffer called
@code{*scheme*}.  This buffer will be in @code{scheme-interaction-mode}
and all output from the Scheme process will go there.  The mode line for
the @code{*scheme*} buffer will have this form:

@example
-----Scheme: 1 [Evaluator]           (Scheme Interaction: input)------
@end example

@noindent
@cindex level number, REPL
The first field, showing @samp{1} in this example, is the level number.

@noindent
The second field, showing @samp{[Evaluator]} in this example, describes
the type of @sc{repl} that is running.  Other values include:

@example
[Debugger]
[Where]
@end example

@noindent
The @dfn{mode} after @samp{Scheme Interaction} is one of:

@table @samp
@item input
Scheme is waiting for input.

@item run
Scheme is running an evaluation.

@item gc
Scheme is garbage collecting.
@end table

@findex scheme-mode
When @code{xscheme} is loaded, @code{scheme-mode} is extended to include
commands for evaluating expressions (do @kbd{C-h m} in any
@code{scheme-mode} buffer for the most up-to-date information):

@table @kbd

@item @key{ESC} o
@kindex @key{ESC} o
@findex xscheme-send-buffer
Evaluates the current buffer (@code{xscheme-send-buffer}).

@item @key{ESC} z
@kindex @key{ESC} z
@findex xscheme-send-definition
Evaluates the current definition (@code{xscheme-send-definition}).  This
is also bound to @kbd{@key{ESC} C-x}.

@item @key{ESC} C-z
@kindex @key{ESC} C-z
@findex xscheme-send-region
Evaluates the current region (@code{xscheme-send-region}).

@item C-x C-e
@kindex C-x C-e
@findex xscheme-send-previous-expression
Evaluates the expression to the left of point
(@code{xscheme-send-previous-expression}).  This is also bound to
@kbd{@key{ESC} @key{RET}}.

@item C-c C-s
@kindex C-c C-s
@findex xscheme-select-process-buffer
Selects the @code{*scheme*} buffer and places you at its end
(@code{xscheme-select-process-buffer}).

@item C-c C-y
@kindex C-c C-y
@findex xscheme-yank-previous-send
Yanks the most recently evaluated expression, placing it at point
(@code{xscheme-yank-previous-send}).  This works only in the
@code{*scheme*} buffer.
@end table

The following commands provide interrupt capability:

@table @kbd

@item C-c C-c
@kindex C-c C-c
@findex xscheme-send-control-g-interrupt
Like typing @kbd{C-g} when running Scheme without Emacs
(@code{xscheme-send-control-g-interrupt}).

@item C-c C-x
@kindex C-c C-x
@findex xscheme-send-control-x-interrupt
Like typing @kbd{C-c C-x} when running Scheme without Emacs
(@code{xscheme-send-control-x-interrupt}).

@item C-c C-u
@kindex C-c C-u
@findex xscheme-send-control-u-interrupt
Like typing @kbd{C-c C-u} when running Scheme without Emacs
(@code{xscheme-send-control-u-interrupt}).

@item C-c C-b
@kindex C-c C-b
@findex xscheme-send-breakpoint-interrupt
Like typing @kbd{C-c C-b} when running Scheme without Emacs
(@code{xscheme-send-breakpoint-interrupt}).

@item C-c C-p
@kindex C-c C-p
@findex xscheme-send-proceed
Like evaluating @code{(proceed)} (@code{xscheme-send-proceed}).
@end table

@node Edwin, Win32 Package Reference, GNU Emacs Interface, Top
@chapter Edwin

This chapter describes how to start Edwin, the MIT Scheme text editor.
Edwin is very similar to GNU Emacs --- you should refer to the GNU Emacs
manual for information about Edwin's commands and key bindings ---
except that Edwin's extension language is MIT Scheme, while GNU Emacs
extensions are written in Emacs Lisp.  This manual does not discuss
customization of Edwin.

To use Edwin, start Scheme with a world image containing Edwin (for
example by giving the @code{-edwin} command-line option), then call the
procedure @code{edit}:

@deffn {procedure+} edit
Enter the Edwin text editor.  If entering for the first time, the editor
is initialized (by calling @code{create-editor} with no arguments).
Otherwise, the previously-initialized editor is reentered.

@findex edwin
The procedure @code{edwin} is an alias for @code{edit}.
@end deffn

@defvr {variable+} inhibit-editor-init-file?
When Edwin is first initialized, it loads your init file (called
@file{~/.edwin} on unix, @file{edwin.ini} on PCs) if you have one.  If
the Scheme variable @code{inhibit-editor-init-file?} is true, however,
your init file will not be loaded even if it exists.  By default, this
variable is false.
@end defvr

@deffn {procedure+} create-editor arg @dots{}
Initializes Edwin, or reinitializes it if already initialized.
@code{Create-editor} is normally invoked automatically by @code{edit}.

If no @var{arg}s are given, the value of @code{create-editor-args} is
used instead.  In other words, the following are equivalent:

@lisp
(create-editor)
(apply create-editor create-editor-args)
@end lisp

@noindent
On the other hand, if @var{arg}s are given, they are used to update
@code{create-editor-args}, making the following equivalent:

@lisp
(apply create-editor @var{args})
(begin (set! create-editor-args @var{args}) (create-editor))
@end lisp
@end deffn

@defvr {variable+} create-editor-args
This variable controls the initialization of Edwin.  The following
values are defined:

@table @code

@item (console)
This says to run Edwin on Scheme's console, or in unix terminology, the
standard input and output.  If the console is not a terminal device, or
is not powerful enough to run Edwin, an error will be signalled at
initialization time.

@item (x)
@findex DISPLAY
This says to create an X window and run Edwin on it.  This requires the
@code{DISPLAY} environment variable to have been set to the appropriate
value before Scheme was started.

@item (x @var{geometry})
This is like @code{(x)} except that @var{geometry} specifies the
window's geometry in the usual way.  @var{Geometry} must be a character
string whose contents is an X geometry specification.

@item (#f)
This is the default.  It says to try running Edwin on Scheme's console,
and failing that, to create an X window and run Edwin on that.  This
signals an error if neither the console nor the X display is usable.
@end table
@end defvr

Once Edwin has been entered, it can be exited in the following ways:

@table @kbd

@item C-x z
@kindex C-x z
@findex suspend-edwin
Stop Edwin and return to Scheme (@code{suspend-edwin}).  The call to the
procedure @code{edit} that entered Edwin returns normally.  A subsequent
call to @code{edit} will resume Edwin where it was stopped.

@item C-x c
@kindex C-x c
@findex save-buffers-kill-edwin
Offer to save any modified buffers, then kill Edwin, returning to Scheme
(@code{save-buffers-kill-edwin}).  This is like the @code{suspend-edwin}
command, except that a subsequent call to @code{edit} will reinitialize
the editor.

@item C-x C-z
@kindex C-x C-z
@findex suspend-scheme
Stop Edwin and suspend Scheme, returning control to the operating
system's command interpreter (@code{suspend-scheme}).  When Scheme is
resumed (using the command interpreter's job-control commands), Edwin is
automatically restarted where it was stopped.  This command is identical
to the @kbd{C-x C-z} command of GNU Emacs.

@item C-x C-c
@kindex C-x C-c
@findex save-buffers-kill-scheme
Offer to save any modified buffers, then kill both Edwin and Scheme
(@code{save-buffers-kill-scheme}).  Control is returned to the operating
system's command interpreter, and the Scheme process is terminated.
This command is identical to the @kbd{C-x C-c} command of GNU Emacs.
@end table



The following Scheme procedures are useful for recovering from bugs in
Edwin's implementation.  All of them are designed for use when Edwin is
@emph{not} running --- they should not be used when Edwin is running.
These procedures are designed to help Edwin's implementors deal with
bugs during the implementation of the editor; they are not intended for
casual use, but as a means of recovering from bugs that would otherwise
require reloading the editor's world image from the disk.

@deffn {procedure+} save-editor-files
Examines Edwin, offering to save any unsaved buffers.  This is useful if
some bug caused Edwin to die while there were unsaved buffers, and you
want to save the information without restarting the editor.
@end deffn

@deffn {procedure+} reset-editor
Resets Edwin, causing it to be reinitialized the next time that
@code{edit} is called.  If you encounter a fatal bug in Edwin, a good
way to recover is to first call @code{save-editor-files}, and then to
call @code{reset-editor}.  That should completely reset the editor to
its initial state.
@end deffn

@deffn {procedure+} reset-editor-windows
Resets Edwin's display structures, without affecting any of the buffers
or their contents.  This is useful if a bug in the display code causes
Edwin's internal display data structures to get into an inconsistent
state that prevents Edwin from running.
@end deffn

@c WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
@node Win32 Package Reference, Variable Index, Edwin, Top
@chapter Win32 Package Reference

@ifinfo
The Win32 implementation is still in a state of development.  It is
expected that changes will be necessary when MIT Scheme is ported to
Microsoft Windows NT on the DEC Alpha architecture.  In particular, the
current system is not arranged in a way that adequately distinguishes 
between issues that are a consequence of the NT operating system and
those which are a consequence of the Intel architecture.
@end ifinfo

@menu
* Overview::                    
* Foreign function interface::  
* Device Independent Bitmap Utilities::  
@end menu

@c @node Acknowledgements, Overview, Top, Top
@c @unnumbered Acknowledgements
@c 
@c Somebody must have helped!
@c GJR, Alan Bawden.

@node Overview, Foreign function interface,  , Win32 Package Reference
@section Overview


The Win32 implementation is still in a state of development.  It is
expected that changes will be necessary when MIT Scheme is ported to
Microsoft Windows NT on the DEC Alpha architecture.  In particular, the
current system is not arranged in a way that adequately distinguishes
between issues that are a consequence of the NT operating system and
those which are a consequence of the Intel architecture.
@cindex limitations

Thus this documentation is not definitive, it merely outlines how the
current system works.  Parts of the system will change and any project
implemented using the win32 system must plan for a re-implementation
stage.


The Win32 implementation has several compononents:

@itemize @bullet

@item
Special microcode primitives.

@item
A foreign function interface (FFI) for calling procedures in dynamically
linked libraries (DLLs).

@item
An interface for Edwin.

@item
The Win32 package provides support for using the features of the
Microsoft Windows 3.1 and Microsoft Windows NT 3.1 environments.

@item
Device Independent Bitmap utilities.  These are used by the win32 Scheme
Graphics implementation.  (The Scheme Graphics implementation is
described in the Reference Manual).

@end itemize

Note that all the names in the Win32 support are part of the
@code{win32} package.  The names are bound in the @code{(win32)}
environment, and do not appear as bindings in the user or root
environments.
An effect of this is that it is far easier to develop Win32 software in
the @code{(win32)} package environment or a child environment.

@node Foreign function interface, Device Independent Bitmap Utilities, Overview, Win32 Package Reference
@section Foreign Function Interface

The Win32 foreign function interface (FFI) is a primitive and fairly
simple system for calling procedures written in C in a
dynamically linked library (DLL).  Both user's procedures from a custom
DLL and system procedures (e.g.  MessageBox) are called using the same
mechanism.

@cindex limitations
@strong{Warning:} The FFI as it stands has several flaws which make it
difficult to use reliably.  It is expected that both the interface to
and the mechanisms used by the FFI will be changed in the future.  We
provide it, and this documentation, only to give people an early start
in accessing some of the features of Win32 from Scheme.  Should you use
it in an experiment we welcome any feedback.

The FFI is designed for calling C procedures that use C data types
rather than Scheme data objects.  Thus it is not possible to write and
call a C procedure that returns, for example, a Scheme list.  The object
returned will always be an integer (which may represent the address of a
C data structure).

@cindex warning
@strong{Warning:} It is extremely dangerous to try to pass Scheme
callback procedures to C procedures.  It is only possible by passing
integer `handles' rather than the actual procedures, and even so, if a
garbage collection occurs during the execution of the callback procedure
objects in Scheme's heap will have moved.  Thus in a foreign procedure
that has a callback and a string, after calling the callback the string
value may no longer be valid.  Playing this game requires a profound
knowledge of the implementation.


The interface to the FFI has two main components: a language for
declaring the types of values passed to and returned from the foreign
procedures and a form for declaring foreign procedures.

@menu
* Windows Types::               
* Windows Foreign Procedures::  
* Win32 API names and procedures::  
@end menu

@node  Windows Types, Windows Foreign Procedures,  , Foreign function interface
@subsection Windows Types

@cindex Windows types
@cindex foreign type declarations
@cindex types, Windows
@cindex defining foreign types
Foreign types are designed to represent a correspondence between a
Scheme data type that is used to represent an object within the Scheme
world and a C data type that represents the data object in the C world.
Thus we cannot manipulate true C objects in Scheme, nor can we
manipulate Scheme objects in C.

Each foreign type has four aspects that together ensure that the
correspondence between the Scheme and C objects is maintained.  These
aspects are all encoded as procedures that either check for validity or
convert between representations.  Thus a foreign type is not a
declarative type so much as a procedural description of how to pass the
type.  The underlying foreign procedure call mechanism can pass integers
and vector-like Scheme objects, and returns integer values.  All other
objects must be translated into integers or some other basic type, and
must be recovered from integers.

The aspects are:

@table @var

@item check
A predicate that returns @code{#t} if the argument is of an acceptable
Scheme type, otherwise returns @code{#f}.
The @var{check} procedure is used for type-checking.

@item convert
A procedure of one argument which returns a Scheme object of one of the
basic types.
It is used to convert an object into a `simpler' object that will
eventually be converted into a C object.
The legal simpler objects are integers and strings.

@item return-convert
A procedure of one argument that, given an integer, returns a Scheme
object of a type satisfying @var{check}.
Its purpose is to convert the result returned by the foreign procedure
into a Scheme value.

@item revert
Some C procedures modify one or more of their arguments.  These
arguments are passed by reference, i.e. as a pointer to their address.
Since a Scheme object might have a different memory layout and storage
conventions, it must be passed by copy-in and copy-out rather than by
reference.
@var{Revert} is a procedure of two parameters, the original object
passed and the result of @var{convert} on that object.
@var{Revert} may then inspect the converted object and copy back the
changes to the original.

@end table

@deffn {special form+} define-windows-type name check convert return revert
@deffnx {special form+} define-similar-windows-type name model [check [convert [return [revert]]]]
@cindex defining foreign types
Both forms define a windows type.
The first form defines a type in terms of its aspects as described
above.
The second defines the type as being like another type, except for
certain aspects, which are redefined.
@var{Name} is the name of the type.
@var{Model} is the name of a type.
@var{Check}, @var{convert}, @var{return} and @var{revert} are
procedures or the value @code{#f}.
A @code{#f} means use the default value, which in the second form means
use the definition provided for @var{model}.
The defaults are

@table @var
@item check
@code{(lambda (x) #t)}, i.e. unchecked.
@item convert
@code{(lambda (x) x)}, i.e. no translation performed.
@item return
@code{(lambda (x) x)}, i.e. no translation performed.
@item revert
@code{(lambda (x y) unspecific)}, i.e. no update performed
@end table

The @code{unchecked} windows type (see below) is defined as:

@example
(define-windows-type unchecked #f #f #f #f)
@end example

Windows types are @emph{not} first class values, so they cannot be
stored in variables or defined using @code{define}:

@example
(define my-type unchecked)                        @error{}  Unbound variable
(define-similar-windows-type umy-type unchecked)  @r{;; the correct way}
@end example

Scheme characters must be converted to integers.  This is accomplished
as follows:

@example
(define-windows-type char
   char?          @r{; check}
   char->integer  @r{; convert}
   integer->char  @r{; convert return value}
   #f             @r{; cannot be passed by reference}
)
@end example
@end deffn

@deffn {windows type} unchecked
The type which is not checked and undergoes only the basic conversion
from a Scheme integer to a C integer or from a Scheme string to a C
pointer to the first byte of the string.
Returned @code{unchecked} values are returned as integers.
@end deffn

@deffn {windows type} bool
Scheme booleans are analogous to C integers @code{0} and @code{1}.
Windows type @code{bool} have been defined as:

@example
(define-windows-type bool
   boolean?
   (lambda (x) (if x 1 0))
   (lambda (x) (if (eq? x 0) #f #t))
   #f)
@end example
@end deffn

@deffn {windows type} char
Scheme characters are converted into C objects of type @code{char},
which are indistinguishable from small integers.
@end deffn

@deffn {windows type} int
@deffnx {windows type} uint
@deffnx {windows type} long
@deffnx {windows type} ulong
@deffnx {windows type} short
@deffnx {windows type} ushort
@deffnx {windows type} word
@deffnx {windows type} byte
Various integer types that are passed without conversion.
@end deffn

@deffn {windows type} string
A string that is passed as a C pointer of type @code{char*} to the first
character in the string.
@end deffn

@deffn {windows type} char*
A string or @code{#f}.  The string is passed as a pointer to characters.
The string is correctly nul-terminated.  @code{#f} is passed as the null
pointer.  This is an example where there is a more complex mapping
between C objects and Scheme objects.  C's @code{char*} type is
represented as one of two Scheme types depending on its value.  This
allows us us to distinguish between the C string (pointer) that points
to the empty sequence of characters and the null pointer (which doesnt
point anywhere).
@end deffn

@deffn {windows type} handle
@deffnx {windows type} hbitmap
@deffnx {windows type} hbrush
@deffnx {windows type} hcursor
@deffnx {windows type} hdc
@deffnx {windows type} hicon
@deffnx {windows type} hinstance
@deffnx {windows type} hmenu
@deffnx {windows type} hpalette
@deffnx {windows type} hpen
@deffnx {windows type} hrgn
@deffnx {windows type} hwnd
Various kinds of Win32 handle.  These names correspond to the same, but
all uppercase, names in the Windows C language header files.  Win32 API
calls are the source of values of this type and the values are
meaningless except as arguments to other Win32 API calls.  Currently
these values are represented as integers but we expect that Win32
handles will in future be represented by allocated Scheme objects (e.g. records)
that will allow predicates (e.g. @code{hmenu?}) and sensible
interlocking with the garbage collector to free the programmer of the
current tedious allocation and deallocation of handles.
@end deffn

@deffn {windows type} resource-id
A Windows resource identifier is either a small integer or a string.
In C, this distinction is possible because pointers look like
larger integers, so a machine word representing a small integer can be
distinguished from a machine word that is a pointer to the text of the
name of the resource.
@end deffn


@node Windows Foreign Procedures, Win32 API names and procedures, Windows Types, Foreign function interface
@subsection Windows Foreign Procedures

Foreign procedures are declared as callable entry-points in a module,
usually a dynamically linked library (DLL).


@deffn {procedure+} find-module name
@cindex loading DLLs
@cindex DLL, loading
Returns a module suitable for use in creating procedures with
@code{windows-procedure}.  @var{Name} is a string which is the name of a
DLL file.  Internally, @code{find-module} uses the @code{LoadLibrary}
Win32 API, so @var{name} should conform to the specifications for this
call.  @var{Name} should be either a full path name of a DLL, or the
name of a DLL that resides in the same directory as the Scheme binary
@file{SCHEME.EXE} or in the system directory.

The module returned is a description for the DLL, and the DLL need not
necessarily be linked at or immediately after this call.  DLL modules
are linked on need and unlinked before Scheme exits and when there
are no remaining references to entry points after a garbage-collection.
This behaviour ensures that the Scheme system can run when a DLL is
absent, provided the DLL is not actually used (i.e. no attempt is made
to call a procedure in the DLL).
@end deffn


@defvr {variable+} gdi32.dll
@cindex DLL, GDI32.DLL
This variable is bound to the module describing the @file{GDI32.DLL}
library, which contains the Win32 API graphics calls, e.g.
@code{LineTo}.
@end defvr

@defvr {variable+} kernel32.dll
@cindex DLL, KERNEL32.DLL
This variable is bound to the module describing the @file{KERNEL32.DLL}
library.
@end defvr

@defvr {variable+} user32.dll
@cindex DLL, USER32.DLL
This variable is bound to the module describing the @file{USER32.DLL}
library.  This module contains many useful Win32 API procedures, like
@code{MessageBox} and @code{SetWindowText}.
@end defvr


@deffn {special form+} windows-procedure (name (parameter type) ...) return-type module entry-name [options]
@cindex defining foreign procedures
This form creates a procedure, and could be thought of as
``foreign-named-lambda''.  The form creates a Scheme procedure that
calls the C procedure identified by the exported entry point
@var{entry-name} in the module identified by the value of @var{module}.
Both @var{entry-name} and @var{module} are evaluated at procedure
creation time, so either may be expression.  @var{Entry-name} must
evaluate to a string and @var{module} must evaluate to a module as
returned by @code{find-module}.
These are the only parts of the form that are evaluated at procedure
creation time.

@var{Name} is the name of the procedure and is for documentation
purposes only.  This form @emph{does not} define a procedure called
@var{name}.  It is more like @code{lambda}.  The name might be used for
debugging and pretty-printing.

A windows procedure has a fixed number of parameters (i.e.  no `rest'
parameters or `varargs'), each of which is named and associated with a
windows type @var{type}.  Both the name @var{parameter} and the windows
type @var{type} must be symbols and are not evaluated.  The procedure
returns a value of the windows type @var{return-type}.

The following example creates a procedure that takes a window handle
(@code{hwnd}) and a string and returns a boolean (@code{bool}) result.
The procedure does this by calling the @code{SetWindowText} entry in the
module that is the value of the variable @code{user32.dll}.  The
variable @code{set-window-title} is defined to have this procedure as
it's value.

@example
(define set-window-title
  (windows-procedure (set-window-text (window hwnd) (text string))
    bool user32.dll "SetWindowText"))

(set-window-title  my-window "Hi")   @result{}  #t
                                     @r{;; Changes window's title/text}

set-window-title                     @result{}  #[compiled-procedure 56 ...]
set-window-text                      @error{}  Unbound variable
@end example


When there are no @var{options} the created procedure will (a) check its
arguments against the types, (b) convert the arguments, (c) call the C
procedure and (d) convert the returned value.  No reversion is
performed, even if one of the @var{types} has a reversion defined.
(Reverted types are rare [I have never used one], so paying a cost for
this unless it is used seems silly).

The following options are allowed:

@table @asis
@item @code{with-reversions}
The reversions are included in the type conversions.

@item @code{expand}
A synonym for @code{with-reversions}.

@item @var{Scheme code}
The @var{Scheme code} is placed between steps (a) and (b) in the default
process.  The Scheme code can enforce constraints on the arguments,
including constraints between arguments such as checking that an index
refers to a valid position in a string.
@end table

If both options (i.e. @code{with-reversions} and Scheme code) are used,
@code{with-reversions} must appear first.  There can be arbitrarily many
Scheme expression.
@end deffn

@node Win32 API names and procedures,  , Windows Foreign Procedures, Foreign function interface
@subsection Win32 API names and procedures

This section is a moving target.
@cindex Win32 API names
@cindex naming conventions

The @code{#define} values from @file{wingdi.h} and @file{winuser.h} are
available as bindings in the @code{(win32)} package environment.  The
@code{#define} symbols are all uppercase; these have been translated to
all lowercase Scheme identifiers, thus @code{WM_LBUTTONUP} is the scheme
variable @code{wm_lbuttonup}.  As Scheme is case insensitive, the
upper-case version may be used and probably should to make the code look
more like conventional Windows code.  The Scheme bindings have been
produced automagically.  Most of the @code{#define}-symbols contain an
underscore so there are not many name clashes.  There is one very
notable name clash, however: @code{ERROR} is @code{#define}d to 0, which
shadows the scheme procedure @code{error} in the root package
environment.  To signal an error, use @code{access}:

@example
((access error ()) "Whine moan" ...)
@end example


The set of procedures is incomplete because procedures have been added
on a by-need basis for the implementation of other parts of the system,
e.g.  Scheme Graphics.  Look in the implementation for further details.

Win32 API procedure names have been uniformly converted into Scheme
identifiers as follows:

@itemize @bullet
@item
A leading uppercase letter is translated into a lowercase letter.
@item
Subsequent sequences of uppercase letters are translated into lowercase
letters preceeded by a hyphen (minus symbol), i.e. hyphens are inserted
at a lowercase to uppercase transition.
@item
Predicates beginning with @code{Is} finally have a
question-mark appended.
@end itemize
Example: applying these rules to @code{IsWindow} yields
@code{is-window?}, and @code{GetDC} is translated into @code{get-dc}.


[It might be worthwhile just keeping the same names.  As the
Win32 API procedure names are uniformly `WordWordWordACRONYMWord', case
insensitivity is unlikely to be a problem.  The only problem is the
protential for a clash between a procedure name and a type
name.]


@node Device Independent Bitmap Utilities,  , Foreign function interface, Win32 Package Reference
@section Device Independent Bitmap Utilities


The Device Independent Bitmap (DIB) utilities DLL @file{DIBUTILS.DLL}
and the associated procedures in @file{dib.scm} in the Win32 system
source is an example of how to use the foreign function interface to
access and manipulate non-Scheme objects.
@cindex DLL, DIBUTILS.DLL

@deffn {windows type} dib
In the C world a DIB is a handle to a piece of memory containing the
bits that represent information about the image and the pixels of the
image.  The handle is a machine-word sized piece of data which may be
thought of as a 32 bit integer.  The handle may be null, indicating that
there is no block of memory describing the DIB.  The null value is
usually returned by C functions that are supposed to create a DIB but
failed, for some reason like the memory could not be allocated or a file
could not be opened.

In the Scheme world a DIB is a structure containing information
about the bitmap (specifically the integer that represents the handle).
We also include @code{#f} in the @code{dib} windows type to mirror the
null handle error value.
@example
(define dib-result
  (lambda (handle)
    (if (= handle 0)
        #f
        (make-dib handle))))

(define dib-arg
  (lambda (dib)
    (if dib
        (cell-contents (dib-handle dib))
        0)))  

(define-windows-type dib
  (lambda (thing) (or (dib? thing) (eq? thing #f)))
  dib-arg
  dib-result)
@end example
@end deffn


@menu
* DIB procedures::              
* Other parts of the DIB Utilities implementation::  
@end menu

@node DIB procedures, Other parts of the DIB Utilities implementation,  , Device Independent Bitmap Utilities
@subsection DIB procedures

The following procedures have typed parameters, using the same
convention as @code{windows-procedure}.

@deffn {procedure+} open-dib (filename string)
Return type: @var{dib}.  Calls the "OpenDIB" entry of
@file{DIBUTILS.DLL}.  If the return value is not @code{#f} then the file
@var{filename} was found, successfully opened, and the contents were
suitable for loading into memory as a device independent bitmap.
@end deffn

@deffn {procedure+} write-dib (filename string) (dib dib) 
Return type: @var{bool}.  Calls the "WriteDIB" entry of
@file{DIBUTILS.DLL}.  Returns @code{#t} if the file @var{filename} could
be opened and written to.  After this operation the file contains the
bitmap data in a standard format that is understood by @code{open-dib}
and various system utilities like the bitmap editor.  Any problems
resulting in failure are signalled by a @code{#f} return value.
@end deffn

@deffn {procedure+} bitmap-from-dib (dib dib) (palette hpalette)
Return type: @var{hbitmap}.
Calls the "BitmapFromDib" entry of @file{DIBUTILS.DLL}.  The returned
value is a device dependent bitmap.  The colours from the DIB are
matched against colors in @var{palette}.
@end deffn

@deffn {procedure+} dib-from-bitmap (bitmap hbitmap) (style dword) (bits word) (palette hpalette)
Return type: @var{dib}.
Returns a DIB containing the same image as the device dependent bitmap
@var{bitmap}.
@var{Style} determines the kind of DIB, e.g. compression style.
Calls the  "DibFromBitmap" entry of @file{DIBUTILS.DLL}.
@end deffn

@deffn {procedure+} dib-blt (dest hdc) (x int) (y int) (w int) (h int) (src dib) (src-x int) (src-y int) (raster-op long)
Return type: @var{bool}.  Calls the "DibBlt" entry of
@file{DIBUTILS.DLL}.  Similar to the Win32 API @code{BitBlt} call, but
draws a DIB rather than a piece of another device context.  Draws the
@var{dib} on device context @var{hdc} at position (@var{x},@var{y}).  A
rectange of width @var{w} and height @var{h} is copied from position
(@var{src-x},@var{src-y}) of @var{dib}.
@var{Raster-op} is supposed to allow the source and destination to be
combined but I don't think I got this right so stick to @code{SRCCOPY}.
@end deffn

@deffn {procedure+} %delete-dib (dib-handle handle)
Return type: @var{bool}.
Calls the "DeleteDIB" entry of @file{DIBUTILS.DLL}.
Note that the parameter is a @var{handle}, and not a @var{dib}.
This allows us to destroy a DIB and reclaim its memory by knowing only
the handle value, and not needing the @code{dib} record.
The importance of this is that if the @code{dib} record is GC-ed then a
GC hook can reclaim the storage knowing only the handle.
@end deffn

@deffn {procedure+} delete-dib (dib dib)
Return type: @var{bool}.
This procedure calls @code{%delete-dib} to reclaim the storage occupied
by a DIB.
After being deleted, the DIB should not be used.
This procedure allows the programmer to reclaim external heap storage
rather than risking it running out before the next garbage collection.
@end deffn

@deffn {procedure+} dib-height (dib dib)
Return type: @var{int}.
Calls the "DibHeight" expand entry of @file{DIBUTILS.DLL}, which returns
the height of the bitmap in pixels.
@end deffn

@deffn {procedure+} dib-width (dib dib)
Return type: @var{int}.
Calls the "DibWidth" entry of @file{DIBUTILS.DLL}, which returns
the width of the bitmap in pixels.
@end deffn

@deffn {procedure+} copy-bitmap (bm hbitmap)
Return type: @var{hbitmap}.
Calls the "CopyBitmap" of @file{DIBUTILS.DLL}, which creates a new
bitmap with the same size and contents as the original.
@end deffn

@deffn {procedure+} create-dib (width int) (height int) (style int) (depth int) (palette hpalette)
Return type: @var{dib}.
Calls the "CreateDIB" entry of @file{DIBUTILS.DLL}.
Creates a DIB of @var{width} by @var{height} pixels and @var{depth} bits
of colour information.
The @var{style} parameter determines how the bitmap is stored.
I have only ever used @code{BI_RGB}.
If @var{depth}<=8 then the @var{palette} determines the DIB's colour table.
@end deffn

@deffn {procedure+} crop-bitmap (bm hbitmap) (left int) (top int) (right int) (bottom int)
Return type: @var{hbitmap}.
Calls the "CropBitmap" entry of @file{DIBUTILS.DLL}.
Returns a new bitmap containing the image from a region of the original.
@end deffn

@deffn {procedure+} dib-set-pixels-unaligned dib (pixels string)
Return type: @var{bool}.
Calls the "DIBSetPixelsUnaligned" entry of @file{DIBUTILS.DLL}.  Stuffs
bytes from @var{pixels} into the bitmap.  There are no alignment
constraints on @var{pixels} (the usual way of doing this is to use the
@code{SetDIBits} function which requires that every scan line of the
bitmap is 32-bit word aligned, even if the scan lines are not a multiple
of 4 bytes long).  doing this
@end deffn

@node Other parts of the DIB Utilities implementation,  , DIB procedures, Device Independent Bitmap Utilities
@subsection Other parts of the DIB Utilities implementation


The @file{DIBUTILS.DLL} library is an ordinary DLL.  See the standard
Microsoft documentation on how to create DLLs.  Look at the code in the
@file{WIN32/DIBUTILS} directory of the Scheme source.

Please note:
@itemize
@item
@cindex DLL, exports
For the foreign function interface to find the procedures they must be
declared as exports in the @file{.DEF} definition file.

@item
To load the @file{.DLL} file use the @code{find-module} Scheme function.
Look at @file{WIN32/DIB.SCM} to see how this is done.

@item
The current system works with C procedures with the @code{__stdcall} and
@code{__cdecl} calling conventions but @emph{not} the @code{__fastcall}
calling convention.
@end itemize


@c @node Writing windows procedures, Procedure Index, Device Independent Bitmap Utilities, Top
@c @section Writing windows procedures
@c 
@c @cindex warning
@c @strong{Warning:} Do not try to do this.  It is very hard to get it even
@c partly right and probably impossible to make the program 100% reliable.
@c 
@c It is possible to write Scheme procedures that determine the behaviour
@c of windows and controls on the screen.  To succeed at this you need a
@c good understanding of how you would do the same thing in C using the
@c Windows SDK, the limitations of mixed language working when C calls
@c Scheme, and lots of patience because debugging this kind of code is very
@c painful.
@c The only major example of this kind of code is the Scheme Graphics
@c implementation (source in @file{WIN32/GRAPHICS.SCM}, but you will need
@c to read @file{RUNTIME/GRAPHICS.SCM} and the DIB utilities too).
@c 
@c Currently, Scheme `wndprocs' are run during interrupt processing.  They
@c are run in the dynamic context of whatever was running when the
@c interrupt was signalled.  Any procedure that relies upon a fluid
@c variable cannot be used reliably.  Thus doing, say, a @code{display}
@c might result in the output unintentionally being inserted in a file
@c rather than appearing on the screen.  Errors are not handled, thus a
@c call to @code{(+ #f 5)} can result in the interrupt processing mechanism
@c becoming confused, and subsequently causing the system to lock up, as
@c all user input ultimately is processed using this same mechanism.
@c Obviously this state of affairs is not satisfactory and I intend to
@c improve things by running the wndprocs in a known dynamic context and
@c trapping errors, but not until Edwin's I/O handling is changed to
@c separate it more from this mechanism, and definitely not until after the
@c release.
@c 
@c @menu
@c * Procedures::                  
@c * Scheme WndProcs::             
@c @end menu
@c 
@c @node Procedures, ,  , Writing windows procedures
@c @subsection Procedures
@c 
@c @deffn {procedure+} get-handle index
@c Return a magic number that cannot be found any other way.
@c Subject to change, the current behaviour is:
@c 
@c @table @code
@c @item 0
@c The handle of the instance, @code{hInstance}, of the Scheme application
@c @item 1
@c The handle of the master tty window
@c @item 3
@c The address of the C function that invokes a Scheme wndproc.
@c @end table
@c @end deffn
@c 
@c @deffn {procedure+} create-scheme-window ex-style class name style x y w h parent menu inst param proc
@c Creates a window by calling @code{CreateWindowEx} with all the
@c parameters except @var{proc}.
@c 
@c @table @var
@c @item ex-style
@c Integer.
@c @item class
@c String.  Must name a window class created with a @code{lpfnWndProc}
@c entry that has the value of @code{(get-handle 3)}.
@c @item name
@c String.  Title of window.
@c @item style
@c Integer.
@c @item x y
@c Integer. Window position.
@c @item w h
@c Integer. Window size.
@c @item parent
@c Integer.  Handle of parent window.
@c @item menu
@c Integer or string.  Number or name of menu resource for this window's
@c menu.
@c 0 means no menu.
@c @item inst
@c Integer, should be the result of @code{(get-handle 0)}.
@c @item param
@c Integer.
@c @item proc
@c @var{Proc} is a Scheme procedure with four parameters, i.e. of the form
@c 
@c @example
@c (lambda (@var{hwnd} @var{msg} @var{wparam} @var{lparam})
@c   ...)
@c @end example
@c This procedure is the Scheme analogue of the C function that would
@c normally have been installed as the @code{lpfnWndProc} of the window
@c class.
@c @end table
@c @end deffn
@c 
@c @deffn {procedure+} subclass-window! hwnd subclass-behaviour
@c Replace @var{hwnd}'s wndproc with a wndproc formed by calling
@c @var{subclass-behaviour} on the original wndproc.
@c @end deffn
@c 
@c @deffn {procedure+} register-class  style wndproc clsExtra wndExtra hInstance hIcon hCursor hBackground menu-name class-name
@c A way to call @code{RegisterClass} without first constructing a C
@c @code{WNDCLASS} object.
@c @end deffn
@c 
@c @deffn {procedure+} default-scheme-wndproc
@c The Scheme equivalent of the C @code{DefWindowProc}.
@c @end deffn
@c 
@c @node Scheme WndProcs,  , Procedures, Writing windows procedures
@c @subsection  Scheme WndProcs
@c 
@c 
@c A Scheme wndproc is of the form
@c 
@c @cindex wndproc
@c @example
@c (lambda (hwnd msg wparam lparam)
@c   (cond ((= msg WM_CREATE)
@c          ...)
@c         (...
@c          ...)
@c         (else
@c          (default-scheme-wndproc hwnd msg wparam lparam))))
@c @end example
@c 
@c @cindex wndproc, higher-order
@c Scheme has the advantage over C that first class procedures can be used
@c to organize the data used by the window.
@c A useful idiom idiom is to parameterize the code with the default
@c behaviour.
@c This example behaves like @var{default-wndproc}, except that it
@c beeps every time the left mouse button is pressed.
@c 
@c @example
@c (define ((my-wndproc default-wndproc) hwnd msg wparam lparam)
@c   (define (default) (default-wndproc hwnd msg wparam lparam))
@c   (cond ((= msg WM_LBUTTONDOWN)
@c            (message-beep MB_OK)
@c            (default))
@c         (else
@c            (default))))
@c @end example
@c 
@c @noindent
@c @code{my-wndproc} is suitable for use with @code{subclass-window!}
@c For example,
@c 
@c @example
@c (subclass-window! (get-handle 1) my-wndproc)
@c @end example
@c Will cause the main Scheme window to beep every time the left mouse
@c button is pressed, but otherwise work normally.
@c 
@c In a similar fashion, Scheme wndprocs can be closed over state
@c describing the object that the window displays or edits.
@c An idiom for a complex kind of window is to have a record (structure)
@c representing the object, and to create the window procedure with that
@c object in scope.
@c The following extended example is a framework for an editor.
@c The @code{whizz-editor} record's @code{hwnd} field is set at window
@c creation time so that we can get the window handle from the record.  The
@c utility of this is demonstrated in @code{whizz-editor/set-title}.
@c 
@c @example
@c (define-structure whizz-editor
@c   hwnd
@c   magic-flag?
@c   @var{other stuff})
@c 
@c 
@c (define (make-whizz-editor-wndproc data)
@c   ;; @r{The following string is created once before the window comes}
@c   ;; @r{into existence}
@c   (define window-local-string (make-string 100))
@c 
@c   ;; @r{The normal wndproc}
@c   (define ((wndproc default-wndproc) hwnd msg wparam lparam)
@c     (define (default) (default-wndproc hwnd msg wparam lparam))
@c     (cond ((= msg WM_CREATE)
@c              (set-whizz-editor-hwnd! data hwnd)
@c              ...
@c              (default))
@c           (...
@c              ... (if (whizz-editor-magic-flag? data) ... ...)
@c              ...)
@c           (else
@c              (default))))
@c 
@c   wndproc)
@c      
@c 
@c (define (create-whizz-editor)
@c   (let* ((data     (make-whizz-editor 0 ...))
@c          (wndproc  (make-whizz-editor-wndproc data))
@c          
@c     (create-scheme-window
@c        0 "WHIZZ_EDITOR_CLASS" "Whizz Editor"
@c        (+ WS_VISIBLE WS_OVERLAPPED)
@c        CW_USEDEFAULT CW_USEDEFAULT CW_USEDEFAULT CW_USEDEFAULT
@c        0 0 (get-handle 0) 0
@c        (wndproc default-scheme-wndproc)))
@c     data))
@c 
@c (define (whizz-editor/set-title wh title)
@c   (set-window-text (whizz-editor-hwnd wh) title))
@c @end example
@c 
@c @noindent
@c Now we are ready to create a Whizz Editor and set its title:
@c 
@c @example
@c (define my-editor (create-whizz-editor))
@c (whizz-editor/set-title my-editor "A new title")
@c @end example
@c 
@c @node Procedure Index, Concept Index, , Top
@c @unnumbered Index of Procedures, Special Forms, and Variables
@c @printindex fn
@c 
@c @node Concept Index,  , Procedure Index, Top
@c @unnumbered Index of Concepts
@c @printindex cp
@c 
@c @node Procedure Index,  , Writing windows procedures, Top
@c @unnumbered Index
@c @printindex fn
@c 
@c @c @summarycontents
@c 
@c @contents
@c 
@c @c Local Variables:
@c @c eval: (auto-save-mode -1)
@c @c End:
@c 
@c @bye

@c WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

@node Variable Index, Key Index, Win32 Package Reference, Top
@unnumbered Variable, Declaration, and Option Index
@printindex fn

@node Key Index, Concept Index, Variable Index, Top
@unnumbered Key Index
@printindex ky

@node Concept Index,  , Key Index, Top
@unnumbered Concept Index
@printindex cp

@contents
@bye

@c Local Variables:
@c selective-display: t
@c truncate-lines: t
@c End:
