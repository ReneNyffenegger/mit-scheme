/* -*-C-*-

$Id: os2msg.h,v 1.2 1994/12/02 20:42:38 cph Exp $

Copyright (c) 1994 Massachusetts Institute of Technology

This material was developed by the Scheme project at the Massachusetts
Institute of Technology, Department of Electrical Engineering and
Computer Science.  Permission to copy this software, to redistribute
it, and to use it for any purpose is granted, subject to the following
restrictions and understandings.

1. Any copy made of this software must include this copyright notice
in full.

2. Users of this software agree to make their best efforts (a) to
return to the MIT Scheme project any improvements or extensions that
they make, so that these may be included in future releases; and (b)
to inform MIT of noteworthy uses of this software.

3. All materials developed as a consequence of the use of this
software shall duly acknowledge such use, in accordance with the usual
standards of acknowledging credit in academic research.

4. MIT has made no warrantee or representation that the operation of
this software will be error-free, and MIT is under no obligation to
provide any services, by way of maintenance, update, or otherwise.

5. In conjunction with products arising from the use of this material,
there shall be no use of the name of the Massachusetts Institute of
Technology nor of any adaptation thereof in any advertising,
promotional, or sales literature without prior written consent from
MIT in each case. */

#ifndef SCM_OS2MSG_H
#define SCM_OS2MSG_H

typedef enum
{
  /* This is sent to acknowledge that the other end of a qid pair has
     been opened.  Sometimes it is necessary to wait until the
     connection is established before proceeding.  */
  mt_init,

  /* This is sent by a "readahead" thread whenever it has some data to
     give to the other end of the connection.  These messages are
     generated asynchronously whenever the readahead is available.  */
  mt_readahead,

  /* This is sent by the receiver or a readahead message.  It is used
     to regulate the amount of readahead in the connection.
     Typically, the readahead thread won't generate any more readahead
     messages until the readahead_ack is received.  */
  mt_readahead_ack,

  /* This is a console interrupt event.  It is generated automatically
     by the console readahead thread (or the PM thread if the console
     is implemented as a PM window), and causes a Scheme character
     interrupt to be signalled in the interrupt-code register.  */
  mt_console_interrupt,

  /* This is a timer interrupt event.  It is generated automatically
     by the timer thread when the timer is active.  */
  mt_timer_event,

  /* These are error messages.  They are sent as a reply to a request
     when an error is generated during the processing of the request.  */
  mt_error,
  mt_syscall_error,

  /* This is a generic reply that is used to acknowledge requests that
     return no meaningful data other than that they have completed.  */
  mt_generic_reply,

  /* This is a request/reply pair that asks the PM thread to create a
     terminal window.  */
  mt_twindow_open_request,
  mt_twindow_open_reply,

  /* This requests the PM thread to close an existing terminal window.  */
  mt_twindow_close_request,

  /* This requests the PM thread to write some characters on a
     terminal window.  */
  mt_twindow_write_request,

  /* This requests the PM thread to move the cursor of a terminal
     window.  */
  mt_twindow_move_cursor_request,

  /* This requests the PM thread to clear a terminal window.  */
  mt_twindow_clear_request,

  /* This requests the PM thread to clear to the end of a line in a
     terminal window.  */
  mt_twindow_clear_eol_request,

  /* This requests the PM thread to scroll a rectangular region in a
     terminal window.  */
  mt_twindow_scroll_request,

  /* These are messages that are automatically generated by the PM
     thread when the corresponding events occur.  */
  mt_key_event,			/* key press */
  mt_button_event,		/* mouse button press */
  mt_close_event,		/* window close */
  mt_visibility_event,		/* window visibility change */
  mt_resize_event,		/* window resized */

  /* This requests the thread on the other end of the connection to
     kill itself.  At present this request is not used.  */
  mt_kill_request,
  mt_supremum
} msg_type_t;
#define MSG_TYPE_SUP ((unsigned int) mt_supremum)
#define MSG_TYPE_MAX (MSG_TYPE_SUP - 1)

typedef unsigned char qid_t;
#define QID_MAX (UCHAR_MAX - 1)
#define QID_NONE UCHAR_MAX

typedef unsigned short msg_length_t;
#define MSG_LENGTH_MAX USHRT_MAX

/* Fields of message header:
   type: small integer classifying the type of message
   sender: qid identifying the message sender (used for replies)
   */

#define DECLARE_MSG_HEADER_FIELDS					\
  unsigned char type;							\
  qid_t sender

typedef struct
{
  DECLARE_MSG_HEADER_FIELDS;
} msg_t;

#define _MSG(m) ((msg_t *) (m))
#define _MSG_TYPE(m) ((_MSG (m)) -> type)
#define MSG_TYPE(m) ((msg_type_t) (_MSG_TYPE (m)))
#define MSG_SENDER(m) ((_MSG (m)) -> sender)

typedef enum
{
  tqt_std,
  tqt_scm,
  tqt_pm
} tqueue_type_t;

typedef struct
{
  tqueue_type_t type;
} tqueue_t;
#define TQUEUE_TYPE(q) (((tqueue_t *) (q)) -> type)

typedef msg_t * (* qid_receive_filter_t) (msg_t *);

extern tqueue_t * OS2_scheme_tqueue;
extern qid_t OS2_interrupt_qid;

extern void OS2_make_qid_pair (qid_t *, qid_t *);
extern void OS2_open_qid (qid_t, tqueue_t *);
extern int OS2_qid_openp (qid_t);
extern void OS2_close_qid (qid_t);
extern void OS2_set_qid_receive_filter (qid_t, qid_receive_filter_t);
extern msg_length_t OS2_message_type_length (msg_type_t);
extern void OS2_set_message_type_length (msg_type_t, msg_length_t);
extern msg_t * OS2_create_message (msg_type_t);
extern void OS2_destroy_message (msg_t *);
extern void OS2_send_message (qid_t, msg_t *);
extern msg_t * OS2_receive_message (qid_t, int);
extern msg_t * OS2_wait_for_message (qid_t, msg_type_t);
extern msg_t * OS2_message_transaction (qid_t, msg_t *, msg_type_t);
extern tqueue_t * OS2_make_std_tqueue (void);
extern void OS2_close_std_tqueue (tqueue_t *);

#define MSG_LENGTH(m) (OS2_message_type_length (MSG_TYPE (m)))

#define SET_MSG_TYPE_LENGTH(t, s)					\
  OS2_set_message_type_length ((t), (sizeof (s)))

typedef struct msg_list_s
{
  msg_t * message;
  struct msg_list_s * next;
} msg_list_t;

typedef struct
{
  DECLARE_MSG_HEADER_FIELDS;
  int code;
} sm_console_interrupt_t;
#define SM_CONSOLE_INTERRUPT_CODE(m) (((sm_console_interrupt_t *) (m)) -> code)

typedef msg_t sm_timer_event_t;
typedef msg_t sm_init_t;
typedef msg_t sm_generic_reply_t;

#endif /* SCM_OS2MSG_H */
