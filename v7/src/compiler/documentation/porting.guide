Emacs: Please use -*- Text -*- mode.  Thank you.

$Header: /Users/cph/tmp/foo/mit-scheme/mit-scheme/v7/src/compiler/documentation/porting.guide,v 1.8 1991/02/26 03:35:50 jinx Exp $


			LIAR PORTING GUIDE
			     *DRAFT*


Notes: 

This porting guide applies to Liar version 4.78, but most of the
relevant information has not changed for a while, nor is it likely to
change in major ways any time soon.

This is an early version of this document, and the order of
presentation leaves a lot to be desired.  In particular, the document
does not follow a monotonic progression, but is instead organized in a
dictionary-like or graph-like manner.  We recommed that you read
through the whole document twice since some important details,
apparently omitted, may have their explanation later on in the
document.  When reading the document for the second time, you will
have an idea of where this other information is to be found, if it is
at all present.  We have attempted to insert sufficient forward
pointers to make the first reading bearable, but we may have missed
some.

This document implicitly assumes that you are trying to build the
compiler under Unix.  The only compiler sources that depend on Unix
are the sources that contain the pathnames of other files.
The syntax could easily be changed for other file systems.
This document uses Unix pathname syntax and assumes a hierarchical
file system, but it should easy to map these directories to a
different file system.

For questions on Liar not covered by this document, or questions about
this document, contact liar-implementors@zurich.ai.mit.edu .

Text tagged by ==> is intended primarily for the compiler developers,
and text tagged by *** is meant for the people writing this document.

Good luck!


		Acknowledgments

Liar is the work of many people.  The current version is mostly the
effort of Chris Hanson and Bill Rozas, with significant contributions
from Mark Friedman.  Arthur Gleckler, Brian LaMacchia, Jim Miller,
and Henry Wu have also contributed to the current version of Liar.
Many other people have offered suggestions and criticisms.

The current Liar may never have existed had it not been for the
efforts and help of the now-extinct BBN Butterfly Lisp group.  That
group included Don Allen, Seth Steinberg, Larry Stabile, and Anthony
Courtemanche.  Don Allen, in particular, babysat computers to
painstakingly bootstrap the first version of the then new Liar.

Many of the ideas and algorithms used in Liar, and in particular at
the RTL level, are taken from the GNU C compiler, written by Richard
Stallman and many others.

This document was written by Bill Rozas, with modifications and hints
from the people listed above.

		0. Introduction and a brief walk through Liar.

Liar translates Scode as produced by the procedure SYNTAX, or by the
file syntaxer (SF) into compiled code objects.  The Scode is
translated into a sequences of languages, the last of which is the
binary representation of the compiled code.

The sequence of languages manipulated is

    Characters --READ--> 
    S-Expressions --SYNTAX--> 
    Scode --COMPILE-SCODE--> 
    compiled code objects.

Liar is a multi-pass compiler, where each major pass has multiple
subpasses.  Many of the subpasses do not manipulate the whole code
graph, but instead follow threads that link the relevant parts of the
graph.

COMPILE-SCODE is the main entry point to Liar, although CF is the
usual entry point.  CF uses COMPILE-SCODE, and assumes that the code
has been syntaxed by SF producing a .bin file, and dumps the resulting
compiled code into a .com file.

The internal sublanguages used by Liar are:

    Scode --FGGEN--> 
    Flow-graph --RTLGEN--> 
    RTL (Register Transfer Language) --LAPGEN-->
    LAP (Lisp assembly program) --ASSEMBLER--> 
    bits --LINK--> 
    compiled code object.

where FGGEN, etc., are some of the major passes of the compiler.  

The remaining major passes are FGOPT (the flow-graph optimizer), and
RTLOPT (the RTL-level optimizer).  RTL-level register allocation is
performed by RTLOPT, and hardware-level register allocation is
performed by LAPGEN.  Branch-tensioning of the output code is
performed by ASSEMBLER.  LINK constructs a Scheme compiled code object
from the bits representing the code and the fixed data that the
compiled code uses at runtime.

compiler/toplev.scm contains the top-level calls of the compiler and
its pass structure.

	0.1.  Liar's package structure

The package structure of the compiler reflects the pass structure.
The package structure is specified in compiler/machines/port/comp.pkg.
The major packages are:

(COMPILER):
	Utilities and data structures shared by most of the compiler.

(COMPILER MACROS):
	Syntax extensions used by the compiler to define language
translation rules.

(COMPILER TOP-LEVEL):
	Top level pass structure of the compiler.

(COMPILER FG-GENERATOR):
	This package contains the flow-graph generator, FGGEN.

(COMPILER FG-OPTIMIZER):
	This package contains the flow-graph analyzer and optimizer,
FGOPT. It has many sub-packages to contain the individual sub-passes.

(COMPILER RTL-GENERATOR):
	This package contains the flow-graph to RTL translator,
RTLGEN. It contains a few sub-packages for the major kinds of
flow-graph operations.

(COMPILER RTL-OPTIMIZER):
	This package contains most of the RTL-level optimizer, RTLOPT.
It has various sub-packages corresponding to some of its sub-passes.

(COMPILER RTL-CSE):
	This package contains the RTL-level common (redundant)
subexpression eliminator pass of the RTL-level optimizer.

(COMPILER LAP-SYNTAXER):
	This package contains most of the machine-dependent parts of
the compiler and the back end utilities.  In particular, it contains
the RTL -> LAP translation rules, and the LAP -> bits translation
rules, ie. the LAPGEN and ASSEMBLER passes respectively.  It has some
sub-packges for various major utilities (linearizer, map-merger,
etc.).

(COMPILER ASSEMBLER):
	This package contains most of the machine-independent portion
of the assembler.  In particular, it contains the bit-assembler, ie.
the portion of the assembler that accumulates the bit strings produced
by ASSEMBLER and performs branch-tensioning on the result.

(COMPILER DISASSEMBLER):
	This package contains the disassembler.  It is not needed for
ordinary compiler operation, but is useful for low-level debugging,
and debugging of the compiler and assembler.

	0.2. Liar's sources' directory structure

The directory structure loosely reflects the pass structure of the
compiler.  compiler/machines/port/comp.pkg declares the packages and
the files that constitute them.

compiler/back:
	This directory contains the machine-independent portion of the
back end.  It contains bit-string utilities, symbol table utilities,
label management procedures, the hardware register allocator, and the
top-level assembler calls.

compiler/base:
	This directory contains common utilities used by the whole
compiler, and the top level procedures provided by the compiler.

compiler/etc:
	This directory contains utilities used for cross-compiling,
and checking re-compilations.

compiler/fggen:
	This directory contains the front end of the compiler.  The
code in this directory translates Scode into a flow-graph used by the
analyzer and optimizer.

compiler/fgopt:
	This directory contains the flow-graph analyzer and optimizer.

compiler/rtlbase:
	This directory contains utilities used by the RTL generator and
optimizer.

compiler/rtlgen:
	This directory contains the code that translates the
flow-graph into register transfer language (RTL).

compiler/rtlopt:
	This directory contains the RTL-level optimizer.  It contains
code to perform lifetime analysis, redundant subexpression
elimination, elimination of dead code, etc.

compiler/machines:
	This directory contains a subdirectory for each port of the
compiler.  Each of these subdirectories contains the port (machine)
dependent files of the compiler.

compiler/machines/port:
	This directory contains the definition of machine parameters,
the assembler rules, the disassembler, and RTL to assembly-language
rules for the port.  

All machine-dependent files are in compiler/machines/port and is the
only directory that needs to be written to port the compiler to a new
architecture.

		1. Liar's runtime model.

Liar does not open-code all operations that the code would need to
execute.  In particular, it leaves error handling and recovery,
interrupt processing, and initialization, to a runtime library written
in assembly language.

Although this runtime library need not run in the context of the
CScheme interpreter, currently the only implementation of this library
runs from the interpreter and uses it for many of its operations.

In other words, Liar does not depend on the interpreter directly, but
indirectly through the runtime library.  It does depend on the ability
to invoke CScheme primitives at runtime, some of which (eval, etc.)
require the interpreter to be present.  It should be possible,
however, to provide an alternate runtime library and primitive set
that would allow code produced by Liar to run without the interpreter
being present (F1).

On the other hand, since the only instance of the runtime library is
that supplied by the interpreter, Liar currently assumes that the
Scheme object representation is the same as that used by the
interpreter, but this is relatively well abstracted and should not be
hard to change (F2).

The runtime library is currently implemented by microcode/cmpaux-md.m4
and microcode/cmpint.c .

microcode/cmpaux-md.m4 is an assembly language port-dependent file
that allows compiled Scheme to call the C-written library routines and
viceversa.  It is described in microcode/cmpaux.txt .

microcode/cmpint.c defines the library in a machine/port-independent
way, but requires some information about the port and this is provided
in microcode/cmpint2.h, a copy (or link) of the appropriate
microcode/cmpint-md.h file.  The microcode/cmpint-md.h files are
described in microcode/cmpint.txt .

microcode/cmpint.txt also describes a lot of the data structures that
the compiled code and runtime library manipulate, and defines some of
the concepts needed to understand the compiler.

The rest of this document assumes that you are using the runtime
library provided by the CScheme interpreter.  If you wish to use Liar
as a compiler for stand-alone programs, a lot of work needs to be
done, and this work is not described here.  Perhaps we will do it in
the future.

If you have not yet read microcode/cmpaux.txt and
microcode/cmpint.txt, please do so before reading the rest of this
document.

(F1) We often toy with this idea.

(F2) Famous last words.

		2. Preliminary Observations

	2.1. Constraints on architectures to which Liar can be ported:

- Liar assumes that the target machine has an address space that is
flat enough that all Scheme objects can be addressed uniformly.  In
other words, segmented address spaces with segments necessarily
smaller than the Scheme runtime heap will make Liar very hard or
inefficient to port.

- Liar assumes that code and data can coexist in the same address
space.  In other words, a true Harvard architecture, with separate
code and data spaces, would be hard to support without relatively
major changes.  This assumption conflicts with some current hardware
that has programmer-visible split data and instruction caches, but
most of these problems can be resolved if the user is given enough
control over flushing of the hardware caches.  At some point in the
future we may provide a C back end for Liar that solves some of these
problems.  Whatever technique the C back end may use can probably be
emulated by architectures with such a strong division.

- Liar assumes that the target machine is a general-register machine.
Ie. operations are based on processor registers, and there is a
moderately large set of general-purpose registers that can be used
interchangeably.  It would be very hard to port Liar to a stack
machine, a graph-reduction engine, or a 4-counter machine.  It is
probably also hard to port Liar to an Intel 386/486 because of the
small number of registers and the fact that most of them are special
to some common instructions.

	2.2. Some implementation decisions that may make your job
harder:

- Liar generates code that passes arguments to procedures on a stack.
This decision especially affects the performance on load-store
architectures, common these days.  This may change in the future due
to the fact that most modern machines have large register sets and
memory-based operations are noticeably slower than register-based
operations even when the memory locations have mappings in the cache.

- Liar assumes that pushing and popping elements from a stack is
cheap.  Currently Liar does not attempt to bump the stack pointer once
per block of operations, but instead bumps it once per item.  This is
expensive on many modern machines where pre-and-post incrementing are
not supported by the hardware.  This may also change in the
not-too-far future.

- Liar assumes that it is cheap to compute overflow conditions on
integer arithmetic operations.  Generic arithmetic primitives have the
frequent fixnum (small integer) case open-coded, and the overflow and
non-fixnum cases coded out of line, but this depends on the ability of
the code to detect overflow conditions cheaply.  This is not true of
some modern machines, notably MIPS processors.  If your processor does
not detect such conditions, you may have to use code similar to that
used in the MIPS port.

- Liar assumes that extracting, inserting, and comparing bit-fields is
relatively cheap.  The current object representation for Liar
(compatible with the interpreter) consists of using a number (6-8) of
bits in the most significant bit positions of a word as a type tag,
and the rest as the datum, usually an encoded address.  Not only
must extracting, comparing, and inserting these tags be cheap, but
decoding the address must be cheap as well.  These operations are
relatively cheap on architectures with bit-field instructions, but
more expensive if they must be emulated with bitwise boolean
operations and shifts, as on the MIPS R3000.  Note that decoding the
address may include inserting segment bits in some of the positions
where the tag is placed, further increasing the dependency on cheap
bit-field manipulation.

	2.3. Emulating an existing port.

The simplest way to port Liar is to find an architecture to which Liar
has already been ported that is sufficiently similar to the desired
architecture that a port can be obtained by small modifications.  In
particular, if the architectures are really close, there may be no
need for architecture-specific additional tuning.

Note that the compiler is developed on Motorola >=68020 processors, so
this is the best-tuned version, and the other ports are not very well
tuned or not tuned at all.  If you improve an existing port, please
share the improvements by notifying liar-implementors.

- If you have a Vax-like CISC machine, you can try starting from the
Vax or the Motorola 68020 ports.  The Vax port was written by starting
from the 68020 port.  This is probably the best solution for some
architectures like the NS32000, and perhaps even the IBM 370.

- If you have an ``enlarged'' RISC processor, with some complex
addressing modes, and bit-field instructions, you may want to start by
looking at the Spectrum (HP Precision Architecture) port.  This is
probably a good starting point for the Motorola 88000 and for the IBM
RS/6000.

- If you have a bare-bones RISC processor, similar to a MIPS R3000
processor, you may want to start from this port.  Since the MIPS R3000
is a minimalist architecture, it almost subsumes all other RISCs, and
may well be a good starting point for all of them.  This is probably a
good starting point for the Sparc.  Note that the MIPS port used the
Spectrum port as its model.

- If you have a machine significantly different from those listed
above, you are out of luck and will have to write a port from scratch.
In particular, a port to an Intel 386/486 would use some of the
concepts and code from ports to ther CISCs, but due to the reduced
register set, would probably have to redo all the register allocation.

Of course, no architecture is identical to any other, so you may want
to mix and match ideas from many of the ports already done, and it is
probably a good idea for you to compare how the various ports solve
the various problems.

		3. Compiler operation, LAPGEN rules and ASSEMBLER rules.

The front end of the compiler translates Scode into a flow-graph that
is then translated into RTL.  The back end does machine-independent
optimization on the RTL, generates assembly language (in LAP format)
from the RTL, and assembles the resulting bits.

Although RTL is a machine-independent language, the particular RTL
generated for a given program will vary from machine to machine.

The RTL can vary in the following ways:

- RTL is a language for manipulating the contents of conceptual
registers.  RTL registers are divided into ``pseudo-registers'' and
``machine registers''.  Machine registers represent physical hardware
registers, some of which have been reserved by the port to hold useful
quantities (stack pointer, value register, etc.)  while
pseudo-registers represent quantities that will need physical
registers or memory locations to hold them in the final translation.
In order to make the RTL more homogenous, the registers are not
distinguished syntactically in the RTL, but are instead distinguished
by their value range.  Machine registers are represented as the N
lowest numbered RTL registers (where N is the number of hardware
registers), and all others are pseudo-registers. Since some RTL
instructions explicitly mention machine registers and these (and their
numbers) vary from architecture to architecture, the register numbers
in an RTL program will vary depending on the back end in use.  Note
that all pseudo-registers are equivalent, and all can hold arbitrary
Scheme objects, while machine registers can be further divided into
separate classes (eg. address, data, and floating-point registers).

- RTL assumes only a load-store architecture, but can accommodate
architectures that allow memory operands and rich addressing modes.
RTL is constructed by generating statements that include relatively
complex expressions.  These expressions may represent multiple memory
indirections or other operations.  An RTL simplifier runs over this
initial RTL, assigning these intermediate quantities to new pseudo
registers and rewriting the original statements to manipulate the
original and new pseudo-registers.  Typically this simplification
results in a sequence of assignments to pseudo-registers with single
operations per assignment and where the only memory operations are
load and store.  However, this simplification pass is controlled by
the port.  The port supplies a set of rewriting rules to the
simplifier that causes the simplifier to leave more complex
expressions untouched, or to be simplified in different ways,
depending on the availability of memory operands or richer addressing
modes.  Since these rules vary from port to port, the final RTL
differs for the different ports.

- The open coding of Scheme primitives is port-dependent.  On some
machines, for example, there is no instruction to multiply integers,
and it may not be advantageous to open code the multiplication
primitive.  The RTL for a particular program may reflect the set of
primitive operations that the back end for the port can open code.

The resulting RTL program is represented as a control flow-graph where
each of the nodes has an associated list of RTL statements.  The edges
in the graph correspond to conditional and unconditional branches in
the code, and include a low-level predicate used to choose between the
alternatives.  Linearization of the graph does not occur at the RTL
level, but at the LAP level.  There is a debugging RTL linearizer used
by the RTL output routine.

Besides assignments and tests, the RTL has some higher level
statements that correspond to procedure headers, continuation (return
address) headers, etc.  Thus an RTL program is made mostly of register
to register operation statements, a few conditional tests, and a few
higher-level ``glue'' statements.

Once a program has been translated to RTL, the RTL code is optimized
in a machine-independent way by minimizing the number of RTL
<pseudo-registers used, removing redundant subexpressions, eliminating
dead code, and various other techniques.

The RTL program is then translated into a Lisp-format
assembly-language program (LAP).  Hardware register allocation occurs
during this translation.  The register allocator is
machine-independent and can accommodate different register classes,
but does not currently accomodate register pairs (this is why floating
point operations are not currently open coded on the Vax).

The register allocator works by considering unused machine registers
(those not reserved by the port) to be a cache for the
pseudo-registers.  Thus a particular pseudo-register may map into
multiple machine registers of different types, and these aliases are
invalidated as the pseudo-registers are written or the corresponding
machine registers reused.  Thus the most basic facility that the
register allocator provides is a utility to allocate an alias of a
particular type for a given pseudo-register.

The port defines the types and numbers of machine registers and the
subset that is available for allocation, and the register allocator
manages the associations between the pseudo-registers and their
aliases and the set of free machine registers.  The register allocator
also automatically spills the contents of machine registers to memory
when pressed for machine registers, and reloads the values when
necessary.

Thus the resultint LAP program is the collection of the code issued by
the rules that translate RTL into LAP, the instructions issued behind
the scenes by the register allocator, and the instructions used to
linearize the control flow graph.

The back end provides a set of rules for the translation of RTL to
LAP, and a set of procedures that the register allocator and the
linearizer use to generate such instructions.  The rules are written
using a special syntax that creates entries in a data base used by a
pattern matcher to translate the RTL into LAP.

The linear LAP is then translated into binary form by using the same
pattern matcher with a different set of rules.  These rules define the
translation between assembly language and machine language for the
architecture.  Most of these rules output bits to be collected
together, but some output a set of directives to the bit-level
assembler to define labels, or choose between alternative encoding of
the fields depending on the final value of a displacement.  These
alternative encodings are typically used for PC-relative quantities.

The machine-independent bit-assembler collects all the bits together
and keeps track of a virtual program counter used to determine the
distance between instruction fields.  A relaxation process is used to
minimize the size of the resulting encoding (to tension branches, i.e.
to choose the smallest encoding that will do the job when there are
alternatives).

Since most of the LAPGEN rules generate almost fixed assembly language,
where the only difference is the register numbers, most of the LAP to
bits translation can be done when the compiler is compiled.  A
compiler switch, ``compiler:enable-expansion-declarations?'' allows this
process to take place.  This mechanism has not been used for a while,
however, because the resulting compiler was, although somewhat faster,
considerably bigger.

Several other compiler parameters and switches control various aspects
of the operation of the back end.  Most parameters and switches are
machine independent, and are defined in compiler/base/switch.scm .
The remaining parameters and switches are defined in
compiler/machines/port/machin.scm.  All compiler parameters and
switches are exported to the Scheme global package for easy
manipulation.

The following switches are of especial importance to the back end
writer:

* compiler:compile-by-procedures? This switch controls whether the
compiler should compile each top-level lambda expression independently
or compile the whole input program (or file) as a block.  It is
usually set to true, but must be set to false for cross-compilation.
The cross-compiler does this automatically.

* compiler:open-code-primitives? This switch controls whether Liar
will open code (inline code) MIT Scheme primitives.  It is usually set
to true and should probably be left that way.  On the other hand, it
is possible to do a lot less work in porting the compiler by not
providing the open coding of primitives and turning this switch off.
Note that some of the primitives are open coded by the
machine-independent portion of the compiler, since they depend only on
structural information, and not on the details of the particular
architecture.  In other words, CAR, CONS, and many others can be
open-coded in a port-independent way since their open codings are
performed directly in the RTL.  Turning this switch to false would
prevent the compiler from open coding these primitives as well.

* compiler:generate-rtl-files? and compiler:generate-lap-files? These
are mostly compiler debugging switches.  They control whether the
compiler will issue .rtl and .lap files for every file compiled.  The
.rtl file will contain the RTL for the program, and the .lap file will
contain the input to the assembler.  Their usual value is false.

* compiler:open-code-floating-point-arithmetic? This switch is
defined in compiler/machines/port/machin.scm and determines whether
floating point primitives can and should be open coded by the compiler
or not.  If the port provides open codings for them, it should be set
to true, otherwise to false.

* compiler:primitives-with-no-open-coding This parameter is defined in
compiler/machines/port/machin.scm.  It contains a list of primitive
names that the port cannot open code.

==> These last two parameters should probably be combined and
inverted, ie. compiler:primitives-with-open-codings should replace
both of the above.  This has the advantage that if the RTL level is
taught how to deal with additional primitives, but not all ports have
open codings for them, there is no need to change the various
machin.scm files.

		4. Description of the port-specific files

The following is the list of files that usually appears in the port
directory.  The files can be organized differently for each port, but
it is probably easiest if the same pattern is kept.  In particular,
the best way to write most is by editting the corresponding files from
an existing port.  Keeping the structure identical will make writing
decls.scm, comp.pkg, and comp.sf straightforward, and will make future
updates easier to track.

A useful thing to do when writing new port files is to keep
track of the original version from which you started, and
additionally, that on which your original is based.  For example, if
you use machines/mips/assmd.scm as a model for your version, in it you
would find something like
  $ Header: assmd.scm,v 1.1 90/05/07 04:10:19 GMT jinx Exp $
  $MC68020-Header: assmd.scm,v 1.36 89/08/28 18:33:33 GMT cph Exp $
In order to allow an easier merge in the future, it would
be good if you transformed this header into
  $ Header $
  $mips-Header: assmd.scm,v 1.1 90/05/07 04:10:19 GMT jinx Exp $
  $MC68020-Header: assmd.scm,v 1.36 89/08/28 18:33:33 GMT cph Exp $
The new $ Header $ line would be used by RCS to keep track of the
versions of your port and the others could be used to find updates to
the originals that would make updating your port easier.

	4.1 Compiler building files:

* comp.pkg:
	This file describes the Scheme package structure of the
compiler, the files loaded into each package, and what names are
exported and imported from each package.
	To write this file, copy the similar file from an existing
port, change the name of the port (ie. mips -> sparc), and add or
remove files as appropriate.  You should only need to add or remove
assembler and LAPGEN files.

* comp.cbf:
	This file is a script that can be used to compile the compiler
from scratch.  You can copy this file from another port, and change
the port name.  There is more information in a later section about how
to build the compiler.

* comp.sf:
	This file is a script that is used to pre-process the compiler
sources before they are loaded to be interpreted or compiled.  You
should be able to copy the file from an existing port and replace the
name of the port.  You should also edit the names of the instruction
files in the assembler instruction database section, although this
section is no longer used by default.

The previous three files should be copied or linked to the top-level
compiler directory.  Ie., compiler/comp.pkg should be a link (symbolic
preferably) or copy of compiler/machines/port/comp.pkg .

* make.scm:
	This file is used to load the compiler on top of a runtime
system that has the file syntaxer (SF) loaded, and defines the version
of the compiler.  The list of files does not appear here because the
comp.pkg already declares them, and when comp.pkg is pre-processed,
two files, comp.con, and comp.ldr, that generate the package structure
and load and link the files, are automatically generated.

* decls.scm:
	This file defines the pre-processing dependencies between the
various source files.  There are three kinds of pre-processing
dependencies:
- Syntactic: Different files need to be processed in different syntax
tables that define the macros used by the files.
- Integrations: Different files import integrable (inline) definitions
from other files, and must be processed in the right sequence in order
to obtain the maximum effect from the integrations (mostly because of
transitive steps).
- Expansions: Certain procedures can be expanded at compiler
pre-processing time into accumulations of simpler calls.  This is how
the assembly language in the LAPGEN rules can be translated into bits at
compiler pre-processing time.  The files that define the
pre-processing-time expansion functions must be loaded in order to
process those files that use the procedures that can be expanded.
decls.scm builds a database of the dependencies.  This database is
topologically sorted by the some of the code in decls.scm itself in
order to determine the processing sequence.  Since there are
circularities in the integration dependencies, some of the files are
processed multiple times, but the mechanism in decls takes care of
doing this the correct way.
You should be able to edit the version from another port in the
appropriate way.  Mostly you will need to rename the port (ie. mips ->
sparc), and add/delete instruction and rules files as needed.
==> decls.scm should probably be split into two sections:  The
machine-independent dependency management code, and the actual
declaration of the dependencies for each port.  This would allow us to
share more of the code, and make the task of rewriting it less daunting.

	4.2 Miscellaneous files:

* rgspcm.scm:
	This file declares a set of primitives that can be coded by
invoking runtime library procedures.  This file is no longer machine
dependent, since the portable library has made all the sets identical.
It lives in machines/port for historical reasons, and should probably
move elsewhere.  Obviously, you can just copy it from another port.
==> Let's move it or get rid of it!

* rulrew.scm:
	This file defines the simplifier rules that allow more
efficient use of the hardware's addressing modes and other
capabilities.  The rules use the same syntax as the LAPGEN rules, but
belong in the (rule) rewriting database.  Although these rules are
port-dependent, it should be possible to emulate what other ports have
done in order to arrive at a correct set.  In addition, examination of
the assembly language issued by the compiler may lead to further
beneficial rewriting rules.  A later section of this document
describes these rules in some detail.  It is possible to start out
with no port-dependent rules and only add them as local inefficiencies
are discovered in the output assembly language.

* machin.scm:
	This file defines architecture and port parameters needed by
various parts of the compiler.  The following is the current list of
the primary parameters.  The definitions of derived parameters not
mentioned here should be copied verbatim from existing ports.  Some of
these parameters are not currently in use, but should all be provided
for completeness.

- endianness: Should be the symbol LITTLE if an address, when used as
a byte address, refers to the least significant byte of the long-word
addressed by it.  It should be BIG if it refers to the most
significant byte of the long-word.  Note that the compiler has not been
ported to any machines where the quantum of addressability is not an
8-bit byte, so the notion may not apply to those.

- addressing-granularity: How many bits are addressed by the
addressing quantum.  Ie., increasing an address by 1 will bump the
address to point past this number of bits.  Again, the compiler has
not been ported to any machine where this value is not 8.

- scheme-object-width: How many bits are taken up by a Scheme object.
This should be the number of bits in a C ``unsigned long'', since Scheme
objects are declared as such by the portable runtime library.

- scheme-type-width: How many bits at the most-significant end of a
Scheme object are taken up by the type tag.  The value of
TYPE_CODE_LENGTH in the microcode must match this value.  The value is
currently 6 for systems with a compiler and 8 for systems without one.

- flonum-size: This is the ceiling of the ratio of the size of a C
``double'' to the size of a C ``unsigned long''.  It reflects how many
Scheme units of memory (measured in Scheme objects) the data in a
Scheme floating point object will take.

- float-alignment: This value defines the bit-alignment constraints
for a C ``double''.  It must be a multiple of scheme-object-width.  If
floating point values can only be stored at even long-word addresses,
for example, this value should be twice scheme-object-width.

- address-units-per-packed-char: This parameter defines how much to
increment an address by in order to make it point to the next
character in a string.  The compiler has not been ported in any
configuration where this is not 1, but may be if 16-bit characters are
used in the future.

- signed-fixnum/upper-limit: This parameter should be derived from
others, but is specified as a constant due to a shortcoming of the
compiler pre-processing system (expt is not constant-folded).  Use the
commented-out expression to derive the value for your port.  Note that
all values that should be derived but are instead specified as
constants are tagged by a comment containing ``***''.

- stack->memory-offset: This procedure is provided to accomodate
stacks that grow in either direction, but we have not tested any port
in which the stack grows towards larger addresses, especially because
the CScheme interpreter imposes its own direction of growth.  It
should probably be copied verbatim.

- execute-cache-size: This should match EXECUTE_CACHE_ENTRY_SIZE in
microcode/cmpint-md.h, and is explained in microcode/cmpint.txt .
==> We should probably rename one or the other to be alike.

The following parameters specify the format of closures containing
multiple entry points to the front-end of the compiler.  These
closures are described in some detail in microcode/cmpint.txt and in
more detail in the section that explains the rules used to generate
such objects.
	
- closure-object-first-offset: This procedure takes a single argument,
the number of entry points in a closure object, and computes the
distance in long-words between the first long-word in the closure
object, and the first long-word containing a free variable.  This is
the number of long-words taken up by the closure object's header, and
the code to represent N closure entry points.

- closure-first-offset: This procedure takes two arguments, the number
of entry points in a closure object, and the index of one of them, the
first being zero.  It computes the distance between that entry's
environment pointer and the first free variable in the closure object.
The entry's environment pointer will be the address of the entry point
itself if closure entry points are always aligned on long-word
boundaries, or the address of the first entry point if they are not.

- closure-entry-distance: This procedure is given the number of entry
points in a closure object, and the indices for two of its entry
points, and computes the number of bytes that separate the two entry
points in the closure object.  This distance should be a multiple of
the parameter COMPILED_CLOSURE_ENTRY_SIZE described in
microcode/cmpint.txt and defined in microcode/cmpint-md.h.

- closure-environment-adjustment: This procedure takes two parameters,
the number of entry points in a closure object, and the index of one
of them.  It computes the number of bytes that must be added to the
entry point's address to result in the entry point's environment
pointer.  If entry points are always aligned on long-word boundaries,
this number should always be zero, otherwise it should be the distance
to the zeroth entry point.

The remaining code in machin.scm describes the register set of the
architecture and defines the register conventions imposed by the port.
These conventions must match the expectations of
microcode/cmpaux-md.m4 described in microcode/cmpaux.txt.

Machine registers are assigned a contiguous range of non-negative
integers starting from zero.  Typically symbolic names are given to
each of these integers for use in some of the rules, especially those
dealing with the assembly language interface.

- number-of-machine-registers should be the number of machine registers,
ie. one greater than the number assigned to the last machine register.

- number-of-temporary-registers is the number of reserved memory
locations used for storing the contents of spilled pseudo-registers.

Liar requires certain fixed locations to hold various implementation
variables such as the stack pointer, the free memory pointer, the
pointer to the runtime library and interpreter's ``register'' array, and
the dynamic link ``register''.  Typically each of these locations is a
fixed machine register.  In addition, typically a processor register
is reserved for returning values and another for holding a bit-mask
used to clear type tags from objects (the pointer or datum mask).  All
of these registers should be given additional symbolic names.

==> What the heck is machine-register-known-value used for?  It would
seem that the datum mask is a known value, but...  Currently all the
ports seem to have the same definition.

The contents of pseudo-registers are divided into various classes to
allow some consistency checking.  Some machine registers always
contain values in a fixed class (eg. floating point registers and the
register holding the datum mask).

- machine-register-value-class is a procedure that maps a register to
its inherent value class.  The main value classes are
value-class=object, value-class=address, and value-class=float.
The registers allocated for the special implementation quantities have
fixed value classes.  The remaining registers, managed by the
compiler's register allocator, may be generic (value-class=word) or
allow ony certain values to be stored in them (value-class=float,
value-class=addres, etc.).

Most of the remainder of compiler/machines/port/machin.scm is a set of
procedures that return and compare the port's chosen locations for
various operations.  Some of these operations are no longer used by
the compiler, and reflect a previous reliance on the interpreter to
accomplish certain environment operations.  These operations are now
handled by invoking the appopriate primitives rather than using
special entry points in the runtime library for them.  Under some
compiler switch settings the older methods for handling these
operations can be re-activated.

- rtl:machine-register? should return a machine register for those
special RTL registers that have been allocated to fixed registers, and
false otherwise.

- rtl:interpreter-register? should return the long-word offset in the
runtime library's memory ``register'' array for those special RTL
registers not allocated to fixed registers, and false otherwise.

- rtl:interpreter-register->offset errors when the special RTL
register has not been allocated to a fixed register, and otherwise
returns the long-word offset into the register  array.

- rtl:constant-cost is a procedure that computes some metric of how
expensive is to generate a particular constant.  If the constant is
cheaply reconstructed, the register allocator may decide to flush it
(rather than spill it to memory) and re-generate it the next time it
is needed.  The best estimate is the number of cycles that
constructing the constant would take, but the number of bytes of
instructions can be used instead.

- copiler:open-code-floating-point-arithmetic? and
compiler:primitives-with-no-open-coding have been described in the
section on compiler switches and parameters.

	4.3 LAPGEN files:

The following files control the RTL -> LAP translation.  They define
the rules used by the pattern matcher to perform the translation, and
procedures used by the register allocator and linearizer to connect
the code that results from each rule.  The rules, and how to write
them, are described further in a later section.

The rule set is partitioned into multiple subsets.  This is not
necessary, but makes recompiling the compiler faster and reduces the
memory requirements of the compiler.  The partition can be done in a
different way, but is probably best left as uniform as possible
between the different ports to facilitate comparison and updating.

The LAPGEN (RTL->LAP) rules are separated into two different data
bases.  The larger is the statement data base, used to translate whole
RTL instructions.  The smaller is the predicate data base, used to
translate decisions to branch between the RTL basic blocks.

* lapgen.scm:
	This file does not define any rules, but provides a set of
utilities for the back end.  It provides utilities for the rules,
typically procedures for generating code that manipulates the object
representation, additional entry points to the register allocator that
are better suited to the port, and the interface procedures for the
register allocator and the linearizer.

The following definitions constitute the register allocator interface
and must be provided by lapgen.scm:
  available-machine-registers
  sort-machine-registers
  register-type
  register-types-compatible?
  register-reference
  register->register-transfer
  reference->register-transfer
  pseudo-register-home
  home->register-transfer
  register->home-transfer

*** Describe, especially, homes, types, and references.

The following definitions constitute the linearizer interface, and
must be provided by lapgen.scm:
  lap:make-label-statement
  lap:make-unconditional-branch
  lap:make-entry-point

The rest of the code in lapgen.scm is a set of utilities for the rule
code, and is port-specific.

*** Describe useful abstractions:
  standard-target-reference
  standard-temporary-reference
  indirect-reference!
  set-standard-branches!
  invoke-interface
  invoke-interface-jsr

* rules1.scm:
	This file contains RTL statement rules for simple register assignments
and operations.  In particular, it contains the rules for constructing
and destructuring Scheme objects, allocating storage, and memory <->
register transfers.

* rules2.scm:
	This file contains RTL predicate rules for simple equality
predicates (EQ-TEST, TYPE-TEST).

* rules3.scm:
	This file contains RTL statement rules for control-flow
statements like continuation (return address) invocation, several
mechanisms for invoking procedures, stack reformatting prior to
invocation, procedure headers, closure object allocation, expression
headers and declaring the data segment of compiled code blocks for
assembly.

* rules4.scm:
	This file contains RTL statement rules for the runtime library
routines that handle manipulation of variables in first class
environments.  Most of these rules are no longer used by the compiler
unless some switch settings vary.

* rulfix.scm:
	This file contains statement and predicate rules for
manipulating fixnums (small integers represented in immediate
form).  The rules handle tagging and detagging fixnum objects,
arithmetic on them, comparison predicates, and overflow tests.

* rulflo.scm:
	This file contains statement and predicate rules for
manipulating flonums (floating point data in boxed form).  The rules
handle boxing and unboxing of flonums, arithmetic on them, and
comparison predicates.

	4.4 Assembler files:

* assmd.scm:
	This file defines the following machine-dependent parameters
and utilities for the bit-level assembler:

- maximum-padding-length: If instructions are not always long-word
aligned, the maximum distance in bits between the end of an
instruction and the next (higher) long-word boundary.

- padding-string: A bit-string used for padding the instruction block
to a long-word boundary.  If possible, it should encode a HALT or
ILLEGAL instruction.  The length of this bit-string should evenly
divide maximum-padding-length.

- block-offset-width: This should be the size in bits of format_word
described in microcode/cmpint.txt.  It should be 16 for all
byte-addressed machines where registers hold 32 bits.

- maximum-block-offset: The maximum byte offset that can be encoded in
block-offset-width bits.  This depends on the encoding described in
microcode/cmpint.txt.  The least significant bit is always used to
indicate whether this block offset points to the start of the object
or to another block offset, so the range may be smaller than the
obvious value.  Furthermore, if instruction alignment constraints are
tighter than byte boundaries, this range may be larger.  For example,
if instructions always start on even long-word boundaries, the bottom
two bits (always zero) are encoded implicitly, and the range is
accordingly larger.

- block-offset->bit-string: This procedure is given a byte offset and
a boolean flag indicating whether this is the offset to the start of a
compiled code block or to another block-offset, and returns the
encoded value of this offset.

- make-nmv-header: This procedure is given the size in long-words of a
block of instructions, and constructs the non-marked-vector header
that must precede the instructions in memory in order to prevent the
garbage collector from examining the data as Scheme objects.  This
header is just an ``object'' whose type tag is manifest-nm-vector
(TC_MANIFEST_NM_VECTOR in the microcode) and whose datum is the size
in long-words (excluding the header itself).

The following three parameters define how instruction fields are to be
assembled in memory depending on the ``endianness'' (byte ordering) of
the architecture.  You should be able to use the MC68020 (big endian)
or the Vax (little endian) version.

- instruction-insert! is a procedure, that given a bit-string
encoding instruction fields, a larger bit-string into which the
smaller should be inserted, a position within the larger one, and a
continuation, it inserts the smaller bit-string into the larger at the
specified position, and returns the new bit position at which the
immediately following instruction field should be inserted.

* coerce.scm:
	This file defines a set of coercion procedures.  These
procedures are used to fill fields in instructions.  Each coercion
procedure checks the range of its argument and produces a bit string
of the appropriate length encoding the argument.  Most coercions will
coerce their signed or unsigned argument into a bit string of the
required fixed length.

* insmac.scm:
	This file defines port-specific syntax used in the assembler,
and the procedure PARSE-INSTRUCTION, invoked by the syntax expander
for DEFINE-INSTRUCTION to parse the body of each of the instruction
rules.  This code is typically complex and you are encouraged to
emulate one of the existing ports in order to reuse its code.

The following ports use the following syntax for describing
instructions in machine language:

- Spectrum and MIPS:
(LONG (<width 1> <value 1> <coercion type 1>)
      (<width 2> <value 2> <coercion type 2>)
      ...	
      (<width n> <value n> <coercion type n>))
where all the widths must add up to an even multiple of 32.

- Vax:
Instructions descriptions are made of arbitrary sequences of the
following field descriptors:
(BYTE (<width 1> <value 1> <coercion type 1>)
      (<width 2> <value 2> <coercion type 2>)
      ...	
      (<width n> <value n> <coercion type n>))
(OPERAND <size> <value>)
(DISPLACEMENT (<width> <value>)

The total width of each of these field descriptors must add up to a
multiple of 8.
BYTE is used primarily for instruction opcodes.
OPERAND is used for general addressing modes.
DISPLACEMENT is used for PC-relative branch displacements.

- MC68020:
(WORD (<width 1> <value 1> <coercion type 1> <size 1>)
      (<width 2> <value 2> <coercion type 2> <size 2>)
      ...	
      (<width n> <value n> <coercion type n> <size 3>))
where all the widths must add up to an even multiple of 16.
Size refers to immediate operands to be encoded in the instruction,
and are omitted when irrelevant.

Typically, missing coercion types imply ordinary unsigned coercion.

In addition, each of these ports provides a VARIABLE-WIDTH syntax for
specifying instructions whose final format must be determined by the
branch tensioning algorithm in the bit assembler.  The syntax of these
instructions is typically
(VARIABLE-WIDTH (<name> <expression>)
  ((<low 1> <high 1>)
   <instruction specifier 1>)
  ((<low 2> <high 2>)
   <instruction specifier 2>)
  ...
  ((() ())
   <instruction specifier n>))

Each instruction specifier is an ordinary (ie. not VARIABLE-WIDTH)
instruction specifier.  NAME is a variable to be bound to the
bit-assembly-time value of EXPRESSION.  Each of the ranges <low
1>-<high 1> <low 2>-<high 2>, etc. must be properly included in the
next, and () specifies no bound.  The final format chosen is that
corresponding to the lowest numbered range containing the value of
EXPRESSION.  Successive instruction specifiers must yield
instructions of non-decreasing lengths for the branch tensioner to
work correctly.

==> The 68k port uses the keyword GROWING-WORD instead of
VARIABLE-WIDTH.  This should probably be changed.

* inerly.scm:
	This file provides alternative expanders for the port-specific
syntax.  This alternative expanders are used when the assembly
language that appears in the LAPGEN rules is assembled (early) at
compiler pre-processing time.  That is, the procedures defined in this
file are only used if COMPILER:ENABLE-EXPANSION-DECLARATIONS? is set
to true.  If you reuse the code in insmac.scm from another port, you
should be able to reuse the inerly.scm file from the same port.
Alternatively, you can write a dummy version of this code and require
COMPILER:ENABLE-EXPANSION-DECLARATIONS? to be always false.  This
switch defaults to false, currently.  The Spectrum and MIPS versions
currently have dummy versions of this code.

* insutl.scm:
	This file defines port-specific rule qualifiers and
transformers.  It is often used to define addressing-mode filters and
handling procedures for architectures with general addressing modes.
This file does not exist in the Spectrum port because all the relevant
code has been placed in instr1.scm, and the MIPS port has no
port-specific qualifiers and transformers.  Qualifiers and
transformers are described further in the chapter on the syntax of
translation rules.

* instr<n>.scm:
	These files define the instruction set of the architecture by
using the syntax defined in insmac.scm and inerly.scm.  There can be
as many of these files or as few as desired by whoever writes the
assembler.  They are usually split according to the size of the files
or along the divisions in the architecture manual.  Not all
instructions in the architecture need to be listed here -- only those
actually used by the back end in the LAPGEN rules and utility procedures.
Priviledged/supervisory instructions, BCD (binary coded decimal)
instructions, COBOL-style EDIT instructions, etc., can probably be
safely ignored.

	4.5 Disassembler files:

	The disassembler is almost completely machine dependent.  For
many machines, a reasonable disassembler could be derived from the
description of the instruction set used to assemble programs.  The Vax
disassembler, is essentially constructed this way.  Unfortunately this
has not been generalized, and currently each port has its own
disassembler, often duplicating information contained in the
assembler.

* dassm1.scm:
	This file contains the top-level of the disassembler.  It is
not machine-dependent, and should probably be moved to another directory.
==> Is back the right place for this?

* dassm2.scm:
	This file contains various utilities for the disassembler.  In
particular, it contains the code for
compiled-code-block/bytes-per-object
compiled-code-block/objects-per-procedure-cache
compiled-code-block/objects-per-variable-cache
==> Should these not be in machin.scm?  In particular, the first two
have corresponding definitions there.
disassembler/read-variable-cache
disassembler/read-procedure-cache
disassembler/instructions
disassembler/instructions/null?
disassembler/instructions/read
and the state machine to heuristically disassemble offsets, etc.
*** Describe all of these.

* dassm3.scm:
	This file contains the code to disassemble one instruction at
a time.  It is completely machine dependent at the time, and any old
way of doing it is fine.

* dinstr<n>.scm:
	In the VAX port, these are copies (or links) to the
instr<n>.scm files.  They are processed with a different syntax table
to construct the disassembler tables instead of the assembler tables.

* dsyn.scm:
	In the VAX port, this file provides the alternative expansion
of DEFINE-INSTRUCTION used to construct the disassembler tables
instead of the assembler rule data base.

		5. All about rules

*** This section needs to be written.  What follows is a list of
topics that need to be addressed. ***

- Syntax of rules.  transformers, qualifiers, variables, etc.

Get CPH to help with the LAPGEN rules.
- Closures, multi closures, uuo-link calls, and block-linking.  Other
hairy stuff in rules3.  Rules4 and part of rules3 should go away, they
are fossils.  On the other hand, they are easy to take care of because
of the portable runtime library.
- Branches, condition codes, set-current-branches!, etc.

- Important rules when writing RTL:
  - delete-dead-registers! must be invoked before allocating an alias
for a target pseudo-register.  Define a utility that does the common
case.
  - all source registers aliases need to be need-register!d, before
allocating the target register.  This is done by the usual utilities.
  - describe the common utilities for reusing and 2/3 operand opcodes.

- Describe the RTL rewriter and what it does.
  Suggest looking at the 68000 and the Spectrum versions.

- How to interface to the runtime library.  How to write
special-purpose optimized entries.

		6. Building and testing the compiler.

Once the port files have been written, you are ready to build and test
the compiler.  The first step is to build an interpreted compiler and
run simple programs.  Most simple bugs will be caught by this.

	6.1 Re-building scheme

You need to build a version of the microcode with the compiled code
interface (portable runtime library) in it.  Besides writing
cmpint-port.h and cmpaux-port.m4, you will need to do the following:

- Copy (or link) cmpint-port.h to cmpint2.h.

- Modify m.h to use 6-bit-long type tags (rather than the default 8)
if you did not do this when you installed the microcode.  Note that if
you do this, you will not be able to load .bin files created with 6
bit type tags.  You can overcome this problem by using the original
.psb files again to regenerate the .bin files, or using a version of
Bintopsb compiled with 8-bit tags to generate new .psb files, and a
version of Psbtobin compiled with 6-bit tags to generate the new .bin
files.  Alternatively, you can try to bring the whole compiler up
using 8 bit tags, but you may run out of address space.  The simplest
way to specify 6-bit type tags is to add a definition of
C_SWITCH_MACHINE that includes -DTYPE_CODE_LENGTH=6 .  Be sure to add
any m4 switches that you may need so that the assembly language will
agree on the number of tag bits if it needs it at all.  If your
version of m4 does not support command-line definitions, you can use
the s/ultrix.m4 script to overcome this problem.  Look at the m/vax.h
and s/ultrix.h files for m4-related definitions.
==> We should just switch the default to 6 bits and be done with it.

- Modify ymakefile to include the a processor dependent section that
lists the cmpint-port.h and cmpaux-port.m4 files.  You can emulate the
version for any other compiler port.  It is especially important that
the microcode sources be compiled with HAS_COMPILER_SUPPORT defined.

- Remove (or save elsewhere) all the .o files and scheme, the linked
scheme microcode.

- Do ``make scheme'' or ``make xmakefile;make -f xmakefile scheme'' to
generate a new linked microcode.

Once you have a new linked microcode, you need to regenerate the
runtime system image files even if you have not changed the length of
the type tags.  This is done as follows:

- Re-generate a runtime.com (actually runtime.bin) image file by
invoking scheme with the options ``-large -fasl make.bin'' while
connected to the runtime directory, and then typing
  (disk-save "<lib directory pathname>/runtime.com")
at the Scheme prompt.

- You should probably also generate a runtime+sf.com file by typing
  (begin
    (cd "<sf directory pathname>")
    (load "make")
    (disk-save "<lib directory pathname>/runtime+sf.com"))
at the Scheme prompt.

You also need to have a working version of cref.  This can be done by
invoking scheme with the options ``-band runtime+sf.com'', and then
typing
  (begin
     (cd "<cref directory pathname>")
     (load "cref.sf"))
at the Scheme prompt.

If this errors because of the lack of a ``runtim.glob'' file, try it
again after executing
  (begin
     (cd "<runtime directory pathname>")
     (load "runtim.sf"))
	
	6.2 Building an interpreted compiler

Once you have a new microcode, compatible runtime system, and ready
cref, you can pre-process the compiler as follows:

- Copy (or link) comp.pkg, comp.sf, and comp.cbf from the
compiler/machines/port directory to the compiler directory.

- For convenience, make a link from compiler/machines/port to
compiler/port .

- Invoke scheme with the ``-band runtime+sf.com'' option, and then
execute
  (begin
     (cd "<compiler directory pathname>")
     (load "comp.sf"))
This will take quite a while, and pre-process some of the files twice.
At the end of this process, you should have a .bin file for each of
the .scm files, a .ext file for some of them, and a bunch of
additional files in the compiler directory (comp.con, comp.ldr,
comp.bcon, comp.bldr, comp.glob, comp.free, comp.cref).

It is a good idea to look at the comp.cref file.  This is a
cross-reference of the compiler and may lead you to find typos or
other small mistakes.  The first section of the cref file (labeled
``Free References:'') lists all variables that are not defined in the
compiler or the runtime system.  The only variables that should be in
this list are SF, and SF/PATHNAME-DEFAULTING.  The ``Undefined
Bindings:'' section lists those variables defined in the runtime
system and referenced freely by the compiler sources.  The remainder
of the cref file lists the compiler packages and the cross reference
of the procedures defined by it.

- Load up the compiler.  Invoke scheme with the options 
``-compiler -band runtime+sf.com'', and then type
  (begin
     (cd "<compiler directory pathname>")
     (load "port/make")
     (disk-save "<lib directory pathname>/compiler.com"))

You should then be able to invoke the compiler by giving scheme the
``-compiler'' option, and use it by invoking CF.

	6.3 Testing the compiler

There is no comprehensive test suite for the compiler.  There is,
however, a small test suite that is likely to catch gross errors.  The
files for the test suite are in compiler/tests/port.  Each file
contains a short description of how it can be used.

A good order to try them is

	expr.scm
	pred.scm
	close.scm
	blast.scm
	reverse.scm
	arith.scm
	bitwse.scm
	fib.scm
	vector.scm
	reptd.scm
	lexpr.scm
	klexpr.scm
	tail.scm

	close2.scm
	prim.scm
	free.scm
	uvuuo.scm
	link.scm
	uuo.scm
	unv.scm

	tail.scm
	sort/*.scm

The programs in the first list test various aspects of code generation.
The programs in the first list test the handling of various dynamic
conditions (ie. error recovery).
The programs in the third list are somewhat larger, and register
allocation bugs, etc., are more likely to show up in them.

A good idea at the beginning is to turn COMPILER:GENERATE-RTL-FILES?
and COMPILER:GENERATE-LAP-FILES? on and compare them for plausibility.
If you've ported the disassembler as well, you should try
disassembling some files and comparing them to then input LAP.  They
won't be identical, but they should be similar.

Various runtime system files make good tests as well.  You may want to
try list.scm, vector.scm, and arith.scm.  Note that to test procedures
from arith.scm, you must execute
    (initialize-microcode-dependencies!)
after loading the file.

*** Mention how to test the assembler by using LAP->CODE?

	6.4 Compiling the compiler

The real test of the compiler comes when it is used to compile itself
and the runtime system.  Recompiling the system is a slow process,
that can take a few hours even with a compiled compiler on a fast
machine.  Compiling the compiler with an interpreted compiler would
probably take days.

There are two ways to speed up the process:

* Cross-compiling:

If you can access some machines on which the compiler already runs,
you can cross-compile the sources using a compiled compiler.  This
method is somewhat involved because you will need binaries for both
machines, since neither can load or dump the other's .bin files.

Say that you have a Vax, and you are porting to a Sparc.  You will
need to pre-process and compile the Sparc's compiler on the Vax to use
it as a cross-compiler.  This can be done by following the same
pattern that you used to generate the interpreted compiler on the
Sparc, but running everything on the Vax, and then compiling the
cross-compiler on the Vax by running scheme with the ``-compiler''
option, and typing
    (begin
	(cd "<sparc compiler directory>")
	(load "comp.cbf"))
before loading and dumping the compiler.

Once you have the cross-compiler, you can use CROSS-COMPILE-BIN-FILE
to generate .moc files.  The .moc files can be translated to .psb
files on the Vax.  These .psb files can in turn be translated to .moc
files on the Sparc, and you can generate the final .com files by using
CROSS-COMPILE-BIN-FILE-END define in compiler/base/crsend.  Note that
compiler/base/crsend can be loaded on a plain runtime system (ie.
without SF or a compiler).  You will probably find the following
idioms useful:
    (for-each cross-compile-bin-file (directory-read "<some dir>/*.bin"))
    (for-each cross-compile-bin-file-end (directory-read "<some dir>/*.moc")).

To translate the original .moc files to .psb files, you should use
microcode/Bintopsb on the Vax as follows:
    Bintopsb upgrade_cc ci_version=?? ci_processor=?? <foo.moc >foo.psb
where the value of ci_version should be the value of
COMPILER_INTERFACE_VERSION in microcode/cmpint.c, and the value of
ci_processor should be the value of COMPILER_PROCESSOR_TYPE defined in
microcode/cmpint-port.h.
==> This is redundant.  If ci_processor or ci_version are supplied,
Bintopsb should assume upgrade_cc.  Furthermore, it should not be
necessary to supply ci_version when it is not changing.

You can then generate the target .moc files by using
microcode/Psbtobin on the Sparc as follows:
    Psbtobin allow_cc <foo.psb >foo.moc

* Distributing the task over several machines:

You can use more than one machine to compile the sources.  If the
machines do not share a file system, you will have to pre-partition
the job and generate a script for each machine.  If the machines share
a (network) file system, you can try to use compiler/etc/xcbfdir.
This file defines two procedures, COMPILE-DIRECTORY, and
CROSS-COMPILE-DIRECTORY, that use a simple-minded protocol based on
creating .tch files to reserve files to compile, and can therefore be
run on many machines simultaneously without uselessly repeating work
or getting in each other's way.

These two methods are not exclusive.  We typically bring up the
compiler on a new machine by distributing the cross-compilation job.

Note that the compiler (and the cross-compiler) use a lot of memory
while running, and that virtual memory is really no substitute for
physical memory.  You may want to increase your physical memory limit
on those systems where this can be controlled (eg. under BSD use the
``limit'' command).  If your machines don't have much physical memory,
or it is too painful to increase your limit (ie. you have to recompile
or relink the kernel), you may want to use microcode/bchscheme instead
of microcode/scheme.  Bchscheme uses a disk file for the spare heap,
rather than a region of memory, putting the available memory to use at
all times.

	6.5 Compiler convergence test


*** Here ***

Testing for convergence by doing stages and comparing binaries.
Common bugs.  interrupts, dlinks, register allocation bus, and bugs
in the interface.

