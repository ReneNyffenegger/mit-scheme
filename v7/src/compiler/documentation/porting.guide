Emacs: Please use -*- Text -*- mode.  Thank you.

$Header: /Users/cph/tmp/foo/mit-scheme/mit-scheme/v7/src/compiler/documentation/porting.guide,v 1.4 1991/02/23 05:34:01 jinx Exp $


			LIAR PORTING GUIDE
			(Very Preliminary)


Notes: 

This porting guide applies to Liar version 4.78, but most of the
relevant information has not changed for a while, nor is it likely to
change in a while.

Text preceded with *** is meant mostly for the compiler developers and
for the people writing this document.

For questions on Liar not covered by this document, or questions about
this document, contact liar-implementors@zurich.ai.mit.edu .



		Acknowledgments

Liar is the work of many people.  The current version is mostly the
effort of Chris Hanson and Bill Rozas, with significant contributions
from Mark Friedman.  Arthur Gleckler, Brian LaMacchia, Jim Miller,
and Henry Wu have also helped develop Liar.

The new Liar may never have existed if it had not been for the efforts
and help of the now-extinct BBN Butterfly Lisp group that included Don
Allen, Seth Steinberg, Larry Stabile, and Anthony Courtemanche.  Don
Allen, in particular, babysat computers to painstakingly bootstrap the
first version of the new Liar.

Many of the ideas and algorithms used in Liar, and in particular at
the RTL level, are taken from the GNU C compiler, written by Richard
Stallman and many others.

This document was written by Bill Rozas, with modifications and hints
from the people listed above.


		0. Introduction and a brief walk through Liar.

Liar translates Scode as produced by the procedure SYNTAX, or by the
file syntaxer (SF) into compiled code objects.  The Scode is
translated into a sequences of languages, the last of which is the
binary representation of the compiled code.

The sequence of languages manipulated is

    Characters --READ--> 
    S-Expressions --SYNTAX--> 
    Scode --COMPILE-SCODE--> 
    compiled code objects.

Liar is a multi-pass compiler, where each major pass has multiple
subpasses.  Many of the subpasses do not manipulate the whole code
graph, but instead follow threads that link the relevant parts of the
graph.

Compile-Scode is the main entry point to Liar, although CF is the
usual entry point.  CF uses COMPILE-SCODE, and assumes that the code
has been syntaxed by SF producing a .bin file, and dumps the resulting
compiled code into a .com file.

The internal sublanguages used by Liar are:

    Scode --FGGEN--> 
    Flow-graph --RTLGEN--> 
    RTL (Register Transfer Language) --LAPGEN-->
    LAP (Lisp assembly program) --ASSEMBLER--> 
    bits --LINK--> 
    compiled code object.

where FGGEN, etc., are some of the major passes of the compiler.  

The remaining major passes are FGOPT (the flow-graph optimizer), and
RTLOPT (the RTL-level optimizer).  RTL-level register allocation is
performed by RTLOPT, and hardware-level register allocation is
performed by LAPGEN.  Branch-tensioning of the output code is
performed by ASSEMBLER.  LINK constructs a Scheme compiled code object
from the bits representing the code and the fixed data that the
compiled code uses at runtime.

compiler/toplev.scm contains the top-level calls of the compiler and
its pass structure.

	0.1.  Package structure for Liar

The package structure of the compiler reflects the pass structure.
The package structure is specified in compiler/machines/port/comp.pkg.
The major packages are:

(COMPILER):
	Utilities and data structures shared by most of the compiler.

(COMPILER MACROS):
	Syntax extensions used by the compiler to define language
translation rules.

(COMPILER TOP-LEVEL):
	Top level pass structure of the compiler.

(COMPILER FG-GENERATOR):
	This package contains the flow-graph generator, FGGEN.

(COMPILER FG-OPTIMIZER):
	This package contains the flow-graph analyzer and optimizer,
FGOPT. It has many sub-packages to contain the individual sub-passes.

(COMPILER RTL-GENERATOR):
	This package contains the flow-graph to RTL translator,
RTLGEN. It contains a few sub-packages for the major kinds of
flow-graph operations.

(COMPILER RTL-OPTIMIZER):
	This package contains most of the RTL-level optimizer, RTLOPT.
It has various sub-packages corresponding to some of its sub-passes.

(COMPILER RTL-CSE):
	This package contains the RTL-level common (redundant)
subexpression eliminator pass of the RTL-level optimizer.

(COMPILER LAP-SYNTAXER):
	This package contains most of the machine-dependent parts of
the compiler and the back end utilities.  In particular, it contains
the RTL -> LAP translation rules, and the LAP -> bits translation
rules, ie. the LAPGEN and ASSEMBLER passes respectively.  It has some
sub-packges for various major utilities (linearizer, map-merger,
etc.).

(COMPILER ASSEMBLER):
	This package contains most of the machine-independent portion
of the assembler.  In particular, it contains the bit-assembler, ie.
the portion of the assembler that accumulates the bit strings produced
by ASSEMBLER and performs branch-tensioning on the result.

(COMPILER DISASSEMBLER):
	This package contains the disassembler.  It is not needed for
ordinary compiler operation, but is useful for low-level debugging,
and debugging of the compiler and assembler.

	0.2. Directory structure for Liar

The directory structure loosely reflects the pass structure of the
compiler.  compiler/machines/port/comp.pkg lists the packages and the
files that they include.

compiler/back:
	This directory contains the machine-independent portion of the
back end.  It contains bit-string utilities, symbol table utilities,
label management procedures, the hardware register allocator, and the
top-level assembler calls.

compiler/base:
	This directory contains common utilities used by the whole
compiler, and the top level procedures provided by the compiler.

compiler/etc:
	This directory contains utilities used for cross-compiling,
and checking re-compilations.

compiler/fggen:
	This directory contains the front end of the compiler.  The
code in this directory translates Scode into a flow-graph used by the
analyzer and optimizer.

compiler/fgopt:
	This directory contains the flow-graph analyzer and optimizer.

compiler/rtlbase:
	This directory contains utilities used by the RTL generator and
optimizer.

compiler/rtlgen:
	This directory contains the code that translates the
flow-graph into register transfer language (RTL).

compiler/rtlopt:
	This directory contains the RTL-level optimizer.  It contains
code to perform lifetime analysis, redundant subexpression
elimination, elimination of dead code, etc.

compiler/machines:
	This directory contains a subdirectory for each port of the
compiler.  Each of these subdirectories contains the port (machine)
dependent files of the compiler.

compiler/machines/port:
	This directory contains the definition of machine parameters,
the assembler rules, the disassembler, and RTL to assembly-language
rules for the port.  

All machine-dependent files are in compiler/machines/port and is the
only directory that needs to be written to port the compiler to a new
architecture.

		1. Liar's runtime model.

Liar does not open-code all operations that the code would need to
execute.  In particular, it leaves error handling and recovery,
interrupt processing, and initialization, to a runtime library written
in assembly language.

Although this runtime library need not run in the context of the
CScheme interpreter, currently the only implementation of this library
runs from the interpreter and uses it for many of its operations.

In other words, Liar does not depend on the interpreter directly, but
indirectly through the runtime library.  It does depend on the ability
to invoke CScheme primitives at runtime, some of which (eval, etc.)
require the interpreter to be present.  It should be possible,
however, to provide an alternate runtime library and primitive set
that would allow code produced by Liar to run without the interpreter
being present (F1).

On the other hand, since the only instance of the runtime library is
that supplied by the interpreter, Liar currently assumes that the
Scheme object representation is the same as that used by the
interpreter, but this is relatively well abstracted and should not be
hard to change (F2).

The runtime library is currently implemented by microcode/cmpaux-md.m4
and microcode/cmpint.c .

microcode/cmpaux-md.m4 is an assembly language port-dependent file
that allows compiled Scheme to call the C-written library routines and
viceversa.  It is described in microcode/cmpaux.txt .

microcode/cmpint.c defines the library in a machine/port-independent
way, but requires some information about the port and this is provided
in microcode/cmpint2.h, a copy (or link) of the appropriate
microcode/cmpint-md.h file.  The microcode/cmpint-md.h files are
described in microcode/cmpint.txt .

microcode/cmpint.txt also describes a lot of the data structures that
the compiled code and runtime library manipulate, and defines some of
the concepts needed to understand the compiler.

The rest of this document assumes that you are using the runtime
library provided by the CScheme interpreter.  If you wish to use Liar
as a compiler for stand-alone programs, a lot of work needs to be
done, and this work is not described here.  Perhaps we will do it in
the future.

If you have not yet read microcode/cmpaux.txt and
microcode/cmpint.txt, please do so before reading the rest of this
document.

(F1) We often toy with this idea.

(F2) Famous last words.

		2. Preliminary Observations

A. Constraints on architectures to which Liar can be ported:

- Liar assumes that the target machine has an address space that is
flat enough that all Scheme objects can be addressed uniformly.  In
other words, segmented address spaces with segments necessarily
smaller than the Scheme runtime heap will make Liar very hard or
inefficient to port.

- Liar assumes that code and data can coexist in the same address
space.  In other words, a true Harvard architecture, with separate
code and data spaces, would be hard to support without relatively
major changes.  This assumption conflicts with some current hardware
that has programmer-visible split data and instruction caches, but
most of these problems can be resolved if the user is given enough
control over flushing of the hardware caches.  At some point in the
future we may provide a C back end for Liar that solves some of these
problems.  Whatever technique the C back end may use can probably be
emulated by architectures with such a strong division.

- Liar assumes that the target machine is a general-register machine.
Ie. operations are based on processor registers, and there is a
moderately large set of general-purpose registers that can be used
interchangeably.  It would be very hard to port Liar to a stack
machine, a graph-reduction engine, or a 4-counter machine.  It is
probably also hard to port Liar to an Intel 386/486 because of the
small number of registers and the fact that most of them are special
to some common instructions.

B. Some implementation decisions that may make your job harder:

- Liar generates code that passes arguments to procedures on a stack.
This decision especially affects the performance on load-store
architectures, common these days.  This may change in the future due
to the fact that most modern machines have large register sets and
memory-based operations are noticeably slower than register-based
operations even when the memory locations have mappings in the cache.

- Liar assumes that pushing and popping elements from a stack is
cheap.  Currently Liar does not attempt to bump the stack pointer once
per block of operations, but instead bumps it once per item.  This is
expensive on many modern machines where pre-and-post incrementing are
not supported by the hardware.  This may also change in the
not-too-far future.

- Liar assumes that it is cheap to compute overflow conditions on
integer arithmetic operations.  Generic arithmetic primitives have the
common fixnum case open-coded, and the overflow and non-fixnum cases
coded out of line, but this depends on the ability of the code to
detect overflow conditions cheaply.  This is not true of some modern
machines, notably the MIPS R3000 processor.  If your  processor does
not detect such conditions, you may have to emulate what the port to
the MIPS processor does.

- Liar assumes that extracting, inserting, and comparing bit-fields is
relatively cheap.  The current object representation for Liar
(compatible with the interpreter) consists of using a number (6-8) of
bits in the most significant bit positions of a word as a type tag,
and the rest as the datum, typically an encoded address.  Not only
must extracting, comparing, and inserting these tags be cheap, but
decoding the address must be cheap as well.  These operations are
relatively cheap on architectures with bit-field instructions, but
more expensive if they must be emulated with bitwise boolean
operations and shifts, as on the MIPS R3000.

C. Emulating an existing port.

The simplest way to port Liar is to find an architecture to which Liar
has already been ported that is sufficiently similar to the desired
architecture that a port can be obtained by small modifications.  In
particular, if the architectures are really close, there may be no
need for architecture-specific additional tuning.

Note that the compiler is developed on Motorola >=68020 processors, so
this is the best-tuned version, and the other ports are not very well
tuned or not tuned at all.  If you improve an existing port, please
share the improvements by notifying liar-implementors.

- If you have a Vax-like CISC machine, you can try starting from the
Vax or the Motorola 68020 ports.  The Vax port was written by starting
from the 68020 port.  This is probably the best solution for some
architectures like the NS32000, and perhaps even the IBM 370.

- If you have an "enlarged" RISC processor, with some complex
addressing modes, and bit-field instructions, you may want to start by
looking at the Spectrum (HP Precision Architecture) port.  This is
probably a good starting point for the Motorola 88000 and for the IBM
RS6000 architectures.

- If you have a bare-bones RISC processor, similar to a MIPS
R2000/R3000 processor, you may want to start from this port.  Since
the MIPS R2000 is a minimalist architecture, it should almost subsume
all other RISCs, and may well be a good starting point for all of
them.  This is probably a good starting point for the Sparc
architecture.  Note that the MIPS port was done by starting from the
Spectrum port.

- If you have a machine significantly different from those listed
above, you are out of luck and will have to write a port from scratch.

Of course, no architecture is identical to any other, so you may want
to mix and match ideas from many of the ports already finished, and it
is probably a good idea for you to compare how the various ports solve
the various problems.

		3. Compiler operation, RTL rules and LAP rules.

The front end of the compiler translates Scode into a flow-graph that
is then translated into RTL.  The back end does machine-independent
optimization on the RTL, generates assembly language (in LAP format)
from the RTL, and assembles the resulting bits.

Although RTL is a machine-independent language, the particular RTL
generated for a given program will vary from machine to machine.

The RTL can vary in the following ways:

- RTL is a language for manipulating the contents of conceptual
registers.  RTL registers are divided into `pseudo registers' and
`machine registers'.  Machine registers represent physical hardware
registers, some of which have been reserved by the port to hold useful
quantities (stack pointer, value register, etc.)  while pseudo
registers represent quantities that will need physical registers or
memory locations to hold them in the final translation.  In order to
make the RTL more homogenous, the registers are not distinguished
syntactically in the RTL, but are instead distinguished by the value
range.  Machine registers are represented as the N lowest numbered RTL
registers (where N is the number of hardware registers), and all
others are pseudo registers. Since some RTL instructions explicitly
mention machine registers and these (and their numbers) vary from
architecture to architecture, the register numbers in an RTL program
will vary depending on the back end in use.  Note that all pseudo
registers are equivalent, and all can hold arbitrary Scheme objects,
while machine registers can be further divided into separate classes
(eg. address, data, and floating-point registers).

- RTL assumes only a load-store architecture, but can accommodate
architectures that allow memory operands and rich addressing modes.
RTL is constructed by generating statements that include relatively
complex expressions.  These expressions may represent multiple memory
indirections or other operations.  An RTL simplifier runs over this
initial RTL, assigning these intermediate quantities to new pseudo
registers and rewriting the original statements to manipulate the
original and new pseudo registers.  Typically this simplification
results in a sequence of assignments to pseudo registers with single
operations per assignment and where the only memory operations are
load and store.  However, this simplification is modulated by the
port.  The port supplies a set of rewriting rules to the simplifier
that causes the simplifier to leave more complex expressions in place,
or to be simplified in different ways, depending on the availability
of memory operands or richer addressing modes.  Since these rules
vary from port to port, the final RTL differs for the different ports.

- The open coding of Scheme primitives is port-dependent.  On some
machines, for example, there is no integer multiply instruction, and
it may not be advantageous to open code the primitive that multiplies.
The RTL for a particular program may reflect the set of primitive
operations that the back end for the port can open code.


The RTL program is represented as a control flow-graph where each of
the nodes has an associated list of RTL statements.  The edges in the
graph correspond to conditional and unconditional branches in the
code, and include a low-level predicate used to choose between the
alternatives.  Linearization of the graph does not occur at the RTL
level, but at the LAP level.  There is a debugging RTL linearizer used
by the RTL output routine.

Besides assignments and tests, the RTL has some higher level concepts
that correspond to procedure headers, continuation (return address)
headers, etc.  Thus an RTL program is made mostly of register to
register operation statements, a few conditional tests, and a few
higher-level glue statements.

Once a program has been translated to RTL, the RTL code is optimized
in a machine-independent way by minimizing the number of RTL pseudo
registers used, removing redundant subexpressions, eliminating dead
code, and various other techniques.

The RTL program is then translated into a Lisp-format
assembly-language program (LAP).  Hardware register allocation occurs
during this translation.  The register allocator is
machine-independent and can accommodate different register classes,
but does not currently accomodate register pairs (this is why floating
point operations are not currently open coded on the Vax).

The register allocator works by considering unused machine registers
(those not reserved by the port) to be a cache for the pseudo
registers.  Thus a particular pseudo register may map into multiple
machine registers of different types, and these aliases are
invalidated as the pseudo registers are written or the corresponding
machine registers reused.  Thus the most basic facility that the
register allocator provides is a utility to allocate an alias of a
particular type for a given pseudo register.

The port defines the types and numbers of machine registers and the
subset that is available for allocation, and the register allocator
manages the associations between the pseudo registers and their
aliases and the set of free machine registers.  The register allocator
also automatically spills the contents of machine registers to memory
when pressed for machine registers, and reloads the values when
necessary.

Thus the resultint LAP program is the collection of the code issued by
the rules that translate RTL into LAP, the instructions issued behind
the scenes by the register allocator, and the instructions used to
linearize the control flow graph.

The back end provides a set of rules for the translation of RTL to
LAP, and a set of procedures that the register allocator and the
linearizer use to generate such instructions.  The rules are written
using a special syntax that creates entries in a data base used by a
pattern matcher to translate the RTL into LAP.

The linear LAP is then translated into binary form by using the same
pattern matcher with a different set of rules.  These rules define the
translation between assembly language and machine language for the
architecture.  Most of these rules output bits to be collected
together, but some output a set of directives to the bit-level
assembler to define labels, or choose between alternative encoding of
the fields depending on the final value of a displacement.  These
alternative encodings are typically used for PC-relative quantities.

The machine-independent bit-assembler collects all the bits together
and keeps track of a virtual program counter used to determine the
distance between instruction fields.  A relaxation process is used to
minimize the size of the resulting encoding (to tension branches, i.e.
to choose the smallest encoding that will do the job when there are
alternatives).

Since most of the RTL rules generate almost fixed assembly language,
where the only difference is the register numbers, most of the LAP to
bits translation can be done when the compiler is compiled.  A
compiler switch, `compiler:enable-expansion-declarations?' allows this
process to take place.  This mechanism has not been used for a while,
however, because the resulting compiler was, although somewhat faster,
considerably bigger.

Several other compiler parameters and switches control various aspects
of the operation of the back end.  Most parameters and switches are
machine independent, and are defined in compiler/base/switch.scm .
The remaining parameters and switches are defined in
compiler/machines/port/machin.scm.  All compiler parameters and
switches are exported to the Scheme global package for easy
manipulation.

The following switches are of especial importance to the back end
writer:

compiler:compile-by-procedures?
	This switch controls whether the compiler should compile each
top-level lambda expression independently or compile the whole input
program (or file) as a block.  It is usually set to true, but must be
set to false for cross-compilation.  The cross-compiler does this
automatically.

compiler:open-code-primitives?
	This switch controls whether Liar will open code (inline code)
MIT Scheme primitives.  It is usually set to true and should probably
be left that way.  On the other hand, it is possible to do a lot less
work in porting the compiler by not providing the open coding of
primitives and turning this switch off.  Note that some of the
primitives are open coded by the machine-independent portion of the
compiler, since they depend only on structural information, and not on
the details of the particular architecture.  In other words, CAR,
CONS, and many others can be open-coded in a port-independent way
since their open codings are performed directly in the RTL.  Turning
this switch to false would prevent the compiler from open coding these
primitives as well.

compiler:generate-rtl-files?
compiler:generate-lap-files?
	These are mostly compiler debugging switches.  They control
whether the compiler will issue .rtl and .lap files for every file
compiled.  The .rtl file will contain the RTL for the program, and the
.lap file will contain the input to the assembler.  Their usual value
is false.

compiler:open-code-floating-point-arithmetic?
	This switch is defined in compiler/machines/port/machin.scm
and determines whether floating point primitives can and should be
open coded by the compiler or not.  If the port provides open codings
for them, it should be set to true, otherwise to false.

compiler:primitives-with-no-open-coding
	This parameter is defined in compiler/machines/port/machin.scm.
It contains a list of primitive names that the port cannot open code.

*** These last two parameters should probably be combined and their
sense inverted, ie. there should be a
compiler:primitives-with-known-open-codings parameter that would
replace both of the above.  This has the advantage that if the RTL
level is taught how to deal with additional primitives, but not all
ports have open codings for them, there is no need to change the
various machin.scm files.

		4. Description of the files in compiler/machines/port.

The following is the list of files that usually appears in the port
directory.  The files can be organized differently for each port, but
it is probably easiest if the same pattern is kept.  In particular,
the best way to write most is by editting appropriately the files from
an existing port.

A useful thing to do when writing new port files is to keep
track of the original version from which you started, and
additionally, that on which your original is based.  For example, if
you use machines/mips/assmd.scm as a model for your version, in it you
would find something like
  $Header: /Users/cph/tmp/foo/mit-scheme/mit-scheme/v7/src/compiler/documentation/porting.guide,v 1.4 1991/02/23 05:34:01 jinx Exp $
  $MC68020-Header: assmd.scm,v 1.36 89/08/28 18:33:33 GMT cph Exp $
In order to allow an easier merge in the future, it would
be good if you transformed this header into
  $Header: /Users/cph/tmp/foo/mit-scheme/mit-scheme/v7/src/compiler/documentation/porting.guide,v 1.4 1991/02/23 05:34:01 jinx Exp $
  $mips-Header: assmd.scm,v 1.1 90/05/07 04:10:19 GMT jinx Exp $
  $MC68020-Header: assmd.scm,v 1.36 89/08/28 18:33:33 GMT cph Exp $
The new $Header: /Users/cph/tmp/foo/mit-scheme/mit-scheme/v7/src/compiler/documentation/porting.guide,v 1.4 1991/02/23 05:34:01 jinx Exp $ line would be used by RCS to keep track of the
versions of your port and the others could be used to find updates to
the originals that would make updating your port easier.

	Compiler building files:

comp.pkg:
	This file describes the Scheme package structure of the
compiler, the files loaded into each package, and what names are
exported and imported from each package.
	To write this file, copy the similar file from an existing
port, change the name of the port (ie. mips -> sparc), and add or
remove files as appropriate.  You should only need to add or remove
assembler and LAPGEN files.

comp.cbf:
	This file is a script that can be used to compile the compiler
from scratch.  You can copy this file from another port, and change
the port name.  There is more information in a later section about how
to build the compiler.

comp.sf:
	This file is a script that is used to pre-process the compiler
sources before they are loaded to be interpreted or compiled.  You
should be able to copy the file from an existing port and replace the
name of the port.  You should also edit the names of the instruction
files in the assembler instruction database section, although this
section is no longer used by default.

The previous three files should be copied or linked to the top-level
compiler directory.  Ie., compiler/comp.pkg should be a link (symbolic
preferably) or copy of compiler/machines/port/comp.pkg .

make.scm:
	This file is used to load the compiler on top of a runtime
system that has the file syntaxer (SF) loaded, and defines the version
of the compiler.  The list of files does not appear here because the
comp.pkg already declares them, and when comp.pkg is pre-processed,
two files, comp.con, and comp.ldr, that generate the package structure
and load and link the files, are automatically generated.

decls.scm:
	This file defines the pre-processing dependencies between the
various source files.  There are three kinds of pre-processing
dependencies:
- Syntactic: Different files need to be processed in different syntax
tables that define the macros used by the files.
- Integrations: Different files import integrable (inline) definitions
from other files, and must be processed in the right sequence in order
to obtain the maximum effect from the integrations (mostly because of
transitive steps).
- Expansions: Certain procedures can be expanded at compiler
pre-processing time into accumulations of simpler calls.  This is how
the assembly language in the RTL rules can be translated into bits at
compiler pre-processing time.  The files that define the
pre-processing-time expansion functions must be loaded in order to
process those files that use the procedures that can be expanded.
decls.scm builds a database of the dependencies.  This database is
topologically sorted by the some of the code in decls.scm itself in
order to determine the processing sequence.  Since there are
circularities in the integration dependencies, some of the files are
processed multiple times, but the mechanism in decls takes care of
doing this the correct way.
You should be able to edit the version from another port in the
appropriate way.  Mostly you will need to rename the port (ie. mips ->
sparc), and add/delete instruction and rules files as needed.
*** decls.scm should probably be split into two sections:  The
machine-independent dependency management code, and the actual
declaration of the dependencies for each port.  This would allow us to
share more of the code, and make the task of rewriting it less daunting.

	Miscellaneous files:

rgspcm.scm:
	This file declares a set of primitives that can be coded by
invoking runtime library procedures.  This file is no longer machine
dependent, since the portable library has made all the sets identical.
It lives in machines/port for historical reasons, and should probably
move elsewhere.  Obviously, you can just copy it from another port.
*** Let's move it or get rid of it!

rulrew.scm:
	This file defines the simplifier rules that allow more
efficient use of the hardware's addressing modes and other
capabilities.  The rules use the same syntax as the LAPGEN rules, but
belong in the (rule) rewriting database.  Although these rules are
port-dependent, it should be possible to emulate what other ports have
done in order to arrive at a correct set.  In addition, examination of
the assembly language issued by the compiler may lead to further
beneficial rewriting rules.  A later section of this document
describes these rules in some detail.  It is possible to start out
with no port-dependent rules and only add them as local inefficiencies
are discovered in the output assembly language.

machin.scm:
	This file defines architecture and port parameters needed by
various parts of the compiler.  The following is the current list of
the primary parameters.  The definitions of derived parameters not
mentioned here should be copied verbatim from existing ports.  Some of
these parameters are not currently in use, but should all be provided
for completeness.

- endianness: Should be the symbol LITTLE if an address, when used as
a byte address, refers to the least significant byte of the long-word
addressed by it.  It should be BIG if it refers to the most
significant byte of the long-word.  Note that the compiler has not been
ported to any machines where the quantum of addressability is not an
8-bit byte, so the notion may not apply to those.

- addressing-granularity: How many bits are addressed by the
addressing quantum.  Ie., increasing an address by 1 will bump the
address to point past this number of bits.  Again, the compiler has
not been ported to any machine where this value is not 8.

- scheme-object-width: How many bits are taken up by a Scheme object.
This should be the number of bits in a C `unsigned long', since Scheme
objects are declared as such by the portable runtime library.

- scheme-type-width: How many bits at the most-significant end of a
Scheme object are taken up by the type tag.  Note that the definition
in the microcode must match this one.  This number is currently 6 for
systems with a compiler and 8 for systems without one.

- flonum-size: This is the ceiling of the ratio of the size of a C
`double' to the size of a C `unsigned long'.  It reflects how many
Scheme units of memory (measured in Scheme objects) the data in a
Scheme floating point object will take.

- float-alignment: This value defines the bit-alignment constraints
for a C `double'.  It must be a multiple of scheme-object-width.  If
floating point values can only be stored at even long-word addresses,
for example, this value should be twice scheme-object-width.

- address-units-per-packed-char: This parameter defines how much to
increment an address by in order to make it point to the next
character in a string.  The compiler has not been ported in any
configuration where this is not 1, but may be if 16-bit characters are
used in the future.

- signed-fixnum/upper-limit: This parameter should be derived from
others, but is specified as a constant due to a shortcoming of the
compiler pre-processing system (expt is not constant-folded).  Use the
commented-out expression to derive the value for your port.  Note that
all values that should be derived but are instead specified as
constants are tagged by a comment containing `***'.

- stack->memory-offset: This procedure is provided to accomodate
stacks that grow in either direction, but we have not tested any port
in which the stack grows towards larger addresses, especially because
the CScheme interpreter imposes its own direction of growth.  It
should probably be copied verbatim.

- execute-cache-size: This should match EXECUTE_CACHE_ENTRY_SIZE in
microcode/cmpint-md.h, and is explained in microcode/cmpint.txt .
*** We should probably rename one or the other to be alike.

The following parameters specify the format of closures containing
multiple entry points to the front-end of the compiler.  These
closures are described in some detail in microcode/cmpint.txt and in
more detail in the section that explains the rules used to generate
such objects.
	
- closure-object-first-offset: This procedure takes a single argument,
the number of entry points in a closure object, and computes the
distance in long-words between the first long-word in the closure
object, and the first long-word containing a free variable.  This is
the number of long-words taken up by the closure object's header, and
the code to represent N closure entry points.

- closure-first-offset: This procedure takes two arguments, the number
of entry points in a closure object, and the index of one of them, the
first being zero.  It computes the distance between that entry's
environment pointer and the first free variable in the closure object.
The entry's environment pointer will be the address of the entry point
itself if closure entry points are always aligned on long-word
boundaries, or the address of the first entry point if they are not.

- closure-entry-distance: This procedure is given the number of entry
points in a closure object, and the indices for two of its entry
points, and computes the number of bytes that separate the two entry
points in the closure object.  This distance should be a multiple of
the parameter COMPILED_CLOSURE_ENTRY_SIZE described in
microcode/cmpint.txt and defined in microcode/cmpint-md.h.

- closure-environment-adjustment: This procedure takes two parameters,
the number of entry points in a closure object, and the index of one
of them.  It computes the number of bytes that must be added to the
entry point's address to result in the entry point's environment
pointer.  If entry points are always aligned on long-word boundaries,
this number should always be zero, otherwise it should be the distance
to the zeroth entry point.

The remaining code in machin.scm describes the register set of the
architecture and defines the register conventions imposed by the port.
These conventions must match the expectations of
microcode/cmpaux-md.m4 described in microcode/cmpaux.txt.

Machine registers are assigned a contiguous range of non-negative
integers starting from zero.  Typically symbolic names are given to
each of these integers for use in some of the rules, especially those
dealing with the assembly language interface.

- number-of-machine-registers should be the number of machine registers,
ie. one greater than the number assigned to the last machine register.

- number-of-temporary-registers is the number of reserved memory
locations used for storing the contents of spilled pseudo registers.

Liar requires certain fixed locations to hold various implementation
variables such as the stack pointer, the free memory pointer, the
pointer to the runtime library and interpreter's "register" array, and
the dynamic link "register".  Typically each of these locations is a
fixed machine register.  In addition, typically a processor register
is reserved for returning values and another for holding a bit-mask
used to clear type tags from objects.  All of these registers are
given additional symbolic names.

*** What the heck is machine-register-known-value used for?  It seems
that the pointer mask is a known value, but...  Currently all the
ports seem to have the same definition.

The contents of pseudo registers are divided into various classes to
allow some simple forms of consistency checking.  Some machine
registers always contain values in a fixed class (eg. floating point
registers and registers holding the pointer mask).

- machine-register-value-class is a procedure that maps a register to
its inherent value class.  The main value classes are
value-class=object, value-class=address, and value-class=float.
The registers allocated for the special implementation quantities have
fixed value classes.  The remaining registers, managed by the
compiler's register allocator, may be generic (value-class=word) or
allow ony certain values to be stored in them (value-class=float,
value-class=addres, etc.).

Most of the remainder of compiler/machines/port/machin.scm is a set of
procedures that return and compare the port's chosen locations for
various operations.  Some of these operations are no longer used by
the compiler, and reflect a previous reliance on the interpreter to
accomplish certain environment operations.  These operations are now
handled by invoking the appopriate primitives rather than using
special entry points in the runtime library for them.  Under some
compiler switch settings the older methods for handling these
operations can be re-activated.

- rtl:machine-register? should return a machine register for those
special RTL registers that have been allocated to fixed registers, and
false otherwise.

- rtl:interpreter-register? should return the long-word offset in the
runtime library's memory "register" array for those special RTL
registers not allocated to fixed registers, and false otherwise.

- rtl:interpreter-register->offset errors when the special RTL
register has not been allocated to a fixed register, and otherwise
returns the long-word offset into the register  array.

- rtl:constant-cost is a procedure that computes some metric of how
expensive is to generate a particular constant.  If the constant is
cheaply reconstructed, the register allocator may decide to flush it
(rather than spill it to memory) and re-generate it the next time it
is needed.

- copiler:open-code-floating-point-arithmetic? and
compiler:primitives-with-no-open-coding have been described in the
section on compiler switches and parameters.

	LAPGEN files:

*** Mention that the partition could be done differently, but this is
not bad.  The names are not great.

lapgen.scm:

rules1.scm:

rules2.scm:

rules3.scm:

rules4.scm:

rulfix.scm:

rulflo.scm:

	Assembler files:

assmd.scm:

coerce.scm:

inerly.scm:

insmac.scm:

insutl.scm:

instr<n>.scm:

	Disassembler files:

dassm1.scm:

dassm2.scm:

dassm3.scm:

dinstr.*:

dsyn.scm:

		5. How to test the compiler once the port files have
been written.
?? How to test the assembler by using LAP->CODE .
Include my upgraded test suite in the compiler directory, and perhaps
some scripts that do the testing.

		6. How to build a compiler once it has been
preliminarly tested.  
Cross compiling.
Spreading the computation over a bunch of machines.
Testing for convergence by doing stages and comparing binaries.
Common bugs.  interrupts, dlinks, register allocation bus, and bugs
in the interface.

		7. How to write RTL rules and use the register allocator.
Get CPH to help with this.
- Closures, multi closures, uuo-link calls, and block-linking.  Other
hairy stuff in rules3.  Rules4 and part of rules3 should go away, they
are fossils.  On the other hand, they are easy to take care of because
of the portable runtime library.
- Branches, condition codes, set-current-branches!, etc.

- Important rules when writing RTL:
  - delete-dead-registers! must be invoked before allocating an alias
for a target pseudo-register.  Define a utility that does the common
case.
  - all source registers aliases need to be need-register!d, before
allocating the target register.  This is done by the usual utilities.
  - describe the common utilities for reusing and 2/3 operand opcodes.


		8. How to use the RTL rewriter to improve the output
code.
- Suggest looking at the 68000 and the Spectrum versions.

		9. How to interface to the runtime library.  How to
write special-purpose optimized entries.
